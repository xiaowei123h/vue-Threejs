webpackJsonp([110],{GTcO:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n("QEtz"),r=n("wIBv"),a={data:function(){return{fragmentShader:null,vertexShader:null,dolly:null,camera:null,scene:null,renderer:null,geometry:null,material:null,mesh:null,stats:null,clock:null,canvas:null,config:null,gui:null}},mounted:function(){var t=this;this.fragmentShader="\n            precision highp float;\n\t\t\tuniform vec2 resolution;\n\t\t\tuniform mat4 viewMatrix;\n\t\t\tuniform vec3 cameraPosition;\n\t\t\tuniform mat4 cameraWorldMatrix;\n\t\t\tuniform mat4 cameraProjectionMatrixInverse;\n\t\t\tconst float EPS = 0.01;\n\t\t\tconst float OFFSET = EPS * 100.0;\n\t\t\tconst vec3 lightDir = vec3(-0.48666426339228763, 0.8111071056538127, -0.3244428422615251);\n\t\t\t// distance functions\n\t\t\tvec3 opRep(vec3 p, float interval) {\n\t\t\t\tvec2 q = mod(p.xz, interval) - interval * 0.5;\n\t\t\t\treturn vec3(q.x, p.y, q.y);\n\t\t\t}\n\t\t\tfloat sphereDist(vec3 p, float r) {\n\t\t\t\treturn length(opRep(p, 3.0)) - r;\n\t\t\t}\n\t\t\tfloat floorDist(vec3 p){\n\t\t\t\treturn dot(p, vec3(0.0, 1.0, 0.0)) + 1.0;\n\t\t\t}\n\t\t\tvec4 minVec4(vec4 a, vec4 b) {\n\t\t\t\treturn (a.a < b.a) ? a : b;\n\t\t\t}\n\t\t\tfloat checkeredPattern(vec3 p) {\n\t\t\t\tfloat u = 1.0 - floor(mod(p.x, 2.0));\n\t\t\t\tfloat v = 1.0 - floor(mod(p.z, 2.0));\n\t\t\t\tif ((u == 1.0 && v < 1.0) || (u < 1.0 && v == 1.0)) {\n\t\t\t\t\treturn 0.2;\n\t\t\t\t} else {\n\t\t\t\t\treturn 1.0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvec3 hsv2rgb(vec3 c) {\n\t\t\t\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\t\t\t\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\t\t\t\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n\t\t\t}\n\t\t\tfloat sceneDist(vec3 p) {\n\t\t\t\treturn min(\n\t\t\t\t\tsphereDist(p, 1.0),\n\t\t\t\t\tfloorDist(p)\n\t\t\t\t);\n\t\t\t}\n\t\t\tvec4 sceneColor(vec3 p) {\n\t\t\t\treturn minVec4(\n\t\t\t\t\t// 3 * 6 / 2 = 9\n\t\t\t\t\tvec4(hsv2rgb(vec3((p.z + p.x) / 9.0, 1.0, 1.0)), sphereDist(p, 1.0)),\n\t\t\t\t\tvec4(vec3(0.5) * checkeredPattern(p), floorDist(p))\n\t\t\t\t);\n\t\t\t}\n\t\t\tvec3 getNormal(vec3 p) {\n\t\t\t\treturn normalize(vec3(\n\t\t\t\t\tsceneDist(p + vec3(EPS, 0.0, 0.0)) - sceneDist(p + vec3(-EPS, 0.0, 0.0)),\n\t\t\t\t\tsceneDist(p + vec3(0.0, EPS, 0.0)) - sceneDist(p + vec3(0.0, -EPS, 0.0)),\n\t\t\t\t\tsceneDist(p + vec3(0.0, 0.0, EPS)) - sceneDist(p + vec3(0.0, 0.0, -EPS))\n\t\t\t\t));\n\t\t\t}\n\t\t\tfloat getShadow(vec3 ro, vec3 rd) {\n\t\t\t\tfloat h = 0.0;\n\t\t\t\tfloat c = 0.0;\n\t\t\t\tfloat r = 1.0;\n\t\t\t\tfloat shadowCoef = 0.5;\n\t\t\t\tfor (float t = 0.0; t < 50.0; t++) {\n\t\t\t\t\th = sceneDist(ro + rd * c);\n\t\t\t\t\tif (h < EPS) return shadowCoef;\n\t\t\t\t\tr = min(r, h * 16.0 / c);\n\t\t\t\t\tc += h;\n\t\t\t\t}\n\t\t\t\treturn 1.0 - shadowCoef + r * shadowCoef;\n\t\t\t}\n\t\t\tvec3 getRayColor(vec3 origin, vec3 ray, out vec3 pos, out vec3 normal, out bool hit) {\n\t\t\t\t// marching loop\n\t\t\t\tfloat dist;\n\t\t\t\tfloat depth = 0.0;\n\t\t\t\tpos = origin;\n\t\t\t\tfor (int i = 0; i < 64; i++){\n\t\t\t\t\tdist = sceneDist(pos);\n\t\t\t\t\tdepth += dist;\n\t\t\t\t\tpos = origin + depth * ray;\n\t\t\t\t\tif (abs(dist) < EPS) break;\n\t\t\t\t}\n\t\t\t\t// hit check and calc color\n\t\t\t\tvec3 color;\n\t\t\t\tif (abs(dist) < EPS) {\n\t\t\t\t\tnormal = getNormal(pos);\n\t\t\t\t\tfloat diffuse = clamp(dot(lightDir, normal), 0.1, 1.0);\n\t\t\t\t\tfloat specular = pow(clamp(dot(reflect(lightDir, normal), ray), 0.0, 1.0), 10.0);\n\t\t\t\t\tfloat shadow = getShadow(pos + normal * OFFSET, lightDir);\n\t\t\t\t\tcolor = (sceneColor(pos).rgb * diffuse + vec3(0.8) * specular) * max(0.5, shadow);\n\t\t\t\t\thit = true;\n\t\t\t\t} else {\n\t\t\t\t\tcolor = vec3(0.0);\n\t\t\t\t}\n\t\t\t\treturn color - pow(clamp(0.05 * depth, 0.0, 0.6), 2.0);\n\t\t\t}\n\t\t\tvoid main(void) {\n\t\t\t\t// screen position\n\t\t\t\tvec2 screenPos = (gl_FragCoord.xy * 2.0 - resolution) / resolution;\n\t\t\t\t// ray direction in normalized device coordinate\n\t\t\t\tvec4 ndcRay = vec4(screenPos.xy, 1.0, 1.0);\n\t\t\t\t// convert ray direction from normalized device coordinate to world coordinate\n\t\t\t\tvec3 ray = (cameraWorldMatrix * cameraProjectionMatrixInverse * ndcRay).xyz;\n\t\t\t\tray = normalize(ray);\n\t\t\t\t// camera position\n\t\t\t\tvec3 cPos = cameraPosition;\n\t\t\t\t// cast ray\n\t\t\t\tvec3 color = vec3(0.0);\n\t\t\t\tvec3 pos, normal;\n\t\t\t\tbool hit;\n\t\t\t\tfloat alpha = 1.0;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tcolor += alpha * getRayColor(cPos, ray, pos, normal, hit);\n\t\t\t\t\talpha *= 0.3;\n\t\t\t\t\tray = normalize(reflect(ray, normal));\n\t\t\t\t\tcPos = pos + normal * OFFSET;\n\t\t\t\t\tif (!hit) break;\n\t\t\t\t}\n\t\t\t\tgl_FragColor = vec4(color, 1.0);\n            }",this.vertexShader="\n            attribute vec3 position;\n\t\t\tvoid main(void) {\n\t\t\t\tgl_Position = vec4(position, 1.0);\n            }",this.canvas=document.querySelector("#canvas"),this.config={saveImage:function(){t.renderer.render(t.scene,t.camera),window.open(t.canvas.toDataURL())},resolution:"512"},this.init(),this.render()},beforeDestroy:function(){this.gui.destroy()},methods:{init:function(){this.renderer=new this.$THREE.WebGLRenderer({canvas:this.canvas}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(this.config.resolution,this.config.resolution),window.addEventListener("resize",this.onWindowResize),this.scene=new this.$THREE.Scene,this.dolly=new this.$THREE.Group,this.scene.add(this.dolly),this.clock=new this.$THREE.Clock,this.camera=new this.$THREE.PerspectiveCamera(60,this.canvas.width/this.canvas.height,1,2e3),this.camera.position.z=4,this.dolly.add(this.camera),this.geometry=new this.$THREE.PlaneBufferGeometry(2,2),this.material=new this.$THREE.RawShaderMaterial({uniforms:{resolution:{value:new this.$THREE.Vector2(this.canvas.width,this.canvas.height)},cameraWorldMatrix:{value:this.camera.matrixWorld},cameraProjectionMatrixInverse:{value:(new this.$THREE.Matrix4).copy(this.camera.projectionMatrixInverse)}},vertexShader:this.vertexShader,fragmentShader:this.fragmentShader}),this.mesh=new this.$THREE.Mesh(this.geometry,this.material),this.mesh.frustumCulled=!1,this.scene.add(this.mesh),new r.a(this.camera,this.canvas).enableZoom=!1,this.gui=new i.a,this.gui.add(this.config,"saveImage").name("Save Image"),this.gui.add(this.config,"resolution",["256","512","800","full"]).name("Resolution").onChange(this.onWindowResize),this.stats=new this.$Stats,this.stats.dom.style.left="280px",document.getElementsByClassName("webglRaymarchingReflect-container")[0].appendChild(this.stats.dom)},onWindowResize:function(){"full"===this.config.resolution?this.renderer.setSize(window.innerWidth-281,window.innerHeight):this.renderer.setSize(this.config.resolution,this.config.resolution),this.camera.aspect=this.canvas.width/this.canvas.height,this.camera.updateProjectionMatrix(),this.material.uniforms.resolution.value.set(this.canvas.width,this.canvas.height),this.material.uniforms.cameraProjectionMatrixInverse.value.copy(this.camera.projectionMatrixInverse)},render:function(){this.stats.begin();var t=this.clock.getElapsedTime();this.dolly.position.z=-t,this.renderer.render(this.scene,this.camera),this.stats.end(),requestAnimationFrame(this.render)}}},o={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"webglRaymarchingReflect-container"},[n("div",{attrs:{id:"info"}},[n("a",{attrs:{href:"https://threejs.org",target:"_blank",rel:"noopener"}},[t._v("three.js")]),t._v(" - webgl raymarching example"),n("br"),t._v("\n\t\t\treflect by "),n("a",{attrs:{href:"https://github.com/gam0022",target:"_blank",rel:"noopener"}},[t._v("gam0022")]),t._v(" ("),n("a",{attrs:{href:"http://qiita.com/gam0022/items/03699a07e4a4b5f2d41f",target:"_blank",rel:"noopener"}},[t._v("article")]),t._v(")\n\t\t")]),t._v(" "),n("div",{attrs:{id:"container"}},[n("canvas",{attrs:{id:"canvas"}})])])}]};var s=n("VU/8")(a,o,!1,function(t){n("yXRT")},"data-v-6cbb1fc3",null);e.default=s.exports},yXRT:function(t,e){}});
//# sourceMappingURL=110.9c8d9ac5ef21c549d59b.js.map