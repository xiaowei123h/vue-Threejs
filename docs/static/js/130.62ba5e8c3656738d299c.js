webpackJsonp([130],{ZbHv:function(e,t){},wvaw:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=n("wIBv"),a={data:function(){return{PCSS:null,PCSSGetShadow:null,stats:null,camera:null,scene:null,renderer:null,group:null}},mounted:function(){this.PCSS="\n            #define LIGHT_WORLD_SIZE 0.005\n            #define LIGHT_FRUSTUM_WIDTH 3.75\n            #define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\n            #define NEAR_PLANE 9.5\n            #define NUM_SAMPLES 17\n            #define NUM_RINGS 11\n            #define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n            #define PCF_NUM_SAMPLES NUM_SAMPLES\n            vec2 poissonDisk[NUM_SAMPLES];\n            void initPoissonSamples(const in vec2 randomSeed) {\n                float ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\n                float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\n                // jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n                float angle = rand(randomSeed) * PI2;\n                float radius = INV_NUM_SAMPLES;\n                float radiusStep = radius;\n                for(int i = 0; i < NUM_SAMPLES; i ++) {\n                    poissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\n                    radius += radiusStep;\n                    angle += ANGLE_STEP;\n                }\n            }\n            float penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\n                return (zReceiver - zBlocker) / zBlocker;\n            }\n            float findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\n                // This uses similar triangles to compute what\n                // area of the shadow map we should search\n                float searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\n                float blockerDepthSum = 0.0;\n                int numBlockers = 0;\n                for(int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\n                    float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n                    if (shadowMapDepth < zReceiver) {\n                        blockerDepthSum += shadowMapDepth;\n                        numBlockers ++;\n                    }\n                }\n                if(numBlockers == 0) return -1.0;\n                return blockerDepthSum / float(numBlockers);\n            }\n            float PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\n                float sum = 0.0;\n                for(int i = 0; i < PCF_NUM_SAMPLES; i ++) {\n                    float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\n                    if(zReceiver <= depth) sum += 1.0;\n                }\n                for(int i = 0; i < PCF_NUM_SAMPLES; i ++) {\n                    float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\n                    if(zReceiver <= depth) sum += 1.0;\n                }\n                return sum / (2.0 * float(PCF_NUM_SAMPLES));\n            }\n            float PCSS (sampler2D shadowMap, vec4 coords) {\n                vec2 uv = coords.xy;\n                float zReceiver = coords.z; // Assumed to be eye-space z in this code\n                initPoissonSamples(uv);\n                // STEP 1: blocker search\n                float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\n                //There are no occluders so early out (this saves filtering)\n                if(avgBlockerDepth == -1.0) return 1.0;\n                // STEP 2: penumbra size\n                float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\n                float filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n                // STEP 3: filtering\n                //return avgBlockerDepth;\n                return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\n            }",this.PCSSGetShadow="\n            return PCSS(shadowMap, shadowCoord);",this.init(),this.animate()},methods:{init:function(){var e=document.createElement("div");document.getElementsByClassName("webglShadowmapPcss-container")[0].appendChild(e),this.scene=new this.$THREE.Scene,this.scene.fog=new this.$THREE.Fog(13426943,5,100),this.camera=new this.$THREE.PerspectiveCamera(30,this.$webglInnerWidth/window.innerHeight,1,1e4),this.camera.position.x=7,this.camera.position.y=13,this.camera.position.z=7,this.scene.add(this.camera),this.scene.add(new this.$THREE.AmbientLight(6710886));var t=new this.$THREE.DirectionalLight(14674943,1.75);t.position.set(2,8,4),t.castShadow=!0,t.shadow.mapSize.width=1024,t.shadow.mapSize.height=1024,t.shadow.camera.far=20,this.scene.add(t),this.scene.add(new this.$THREE.CameraHelper(t.shadow.camera)),this.group=new this.$THREE.Group,this.scene.add(this.group);for(var n=new this.$THREE.SphereBufferGeometry(.3,20,20),a=0;a<20;a++){var s=new this.$THREE.MeshPhongMaterial({color:16777215*Math.random()}),r=new this.$THREE.Mesh(n,s);r.position.x=Math.random()-.5,r.position.z=Math.random()-.5,r.position.normalize(),r.position.multiplyScalar(2*Math.random()+1),r.castShadow=!0,r.receiveShadow=!0,r.userData.phase=Math.random()*Math.PI,this.group.add(r)}var o=new this.$THREE.MeshPhongMaterial({color:4210752,specular:1118481}),h=new this.$THREE.Mesh(new this.$THREE.PlaneBufferGeometry(2e4,2e4,8,8),o);h.rotation.x=-Math.PI/2,h.receiveShadow=!0,this.scene.add(h);var d=new this.$THREE.Mesh(new this.$THREE.BoxBufferGeometry(1,4,1),o);d.position.y=2,d.castShadow=!0,d.receiveShadow=!0,this.scene.add(d);var l=this.$THREE.ShaderChunk.shadowmap_pars_fragment;l=(l=l.replace("#ifdef USE_SHADOWMAP","#ifdef USE_SHADOWMAP"+this.PCSS)).replace("#if defined(SHADOWMAP_TYPE_PCF)",this.PCSSGetShadow+"#if defined(SHADOWMAP_TYPE_PCF)"),this.$THREE.ShaderChunk.shadowmap_pars_fragment=l,this.renderer=new this.$THREE.WebGLRenderer({antialias:!0}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(this.$webglInnerWidth,window.innerHeight),this.renderer.setClearColor(this.scene.fog.color),e.appendChild(this.renderer.domElement),this.renderer.outputEncoding=this.$THREE.sRGBEncoding,this.renderer.shadowMap.enabled=!0;var c=new i.b(this.camera,this.renderer.domElement);c.maxPolarAngle=.5*Math.PI,c.minDistance=10,c.maxDistance=75,c.target.set(0,2.5,0),c.update(),this.stats=new this.$Stats,this.stats.dom.style.left="280px",e.appendChild(this.stats.dom),window.addEventListener("resize",this.onWindowResize,!1)},onWindowResize:function(){this.$onWindowResize(this.camera,this.renderer)},animate:function(){var e=performance.now()/1e3;this.group.traverse(function(t){"phase"in t.userData&&(t.position.y=4*Math.abs(Math.sin(e+t.userData.phase))+.3)}),this.renderer.render(this.scene,this.camera),this.stats.update(),requestAnimationFrame(this.animate)}}},s={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"webglShadowmapPcss-container"},[t("div",{attrs:{id:"info"}},[this._v("Percent Closer Soft-Shadows (PCSS) by "),t("a",{attrs:{href:"http://eduperiment.com"}},[this._v("spidersharma03")])])])}]};var r=n("VU/8")(a,s,!1,function(e){n("ZbHv")},"data-v-5cab269d",null);t.default=r.exports}});
//# sourceMappingURL=130.62ba5e8c3656738d299c.js.map