{"version":3,"sources":["webpack:///./src/components/jsm/math/ConvexHull.js","webpack:///./src/components/jsm/geometries/ConvexGeometry.js","webpack:///src/views/geometries/webglGeometryConvex.vue","webpack:///./src/views/geometries/webglGeometryConvex.vue?2e99","webpack:///./src/views/geometries/webglGeometryConvex.vue"],"names":["ConvexHull","line3","plane","closestPoint","triangle","Visible","v1","Vector3","this","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","Face","normal","midpoint","area","constant","outside","mark","edge","HalfEdge","vertex","face","prev","next","twin","VertexNode","point","head","tail","Object","assign","prototype","setFromPoints","points","Array","isArray","console","error","length","makeEmpty","i","l","push","compute","setFromObject","object","updateMatrixWorld","traverse","node","geometry","undefined","isGeometry","clone","applyMatrix4","matrixWorld","isBufferGeometry","attribute","attributes","position","count","fromBufferAttribute","containsPoint","distanceToPoint","intersectRay","ray","target","tNear","Infinity","tFar","vN","origin","vD","dot","direction","t","Math","min","max","at","intersectsRay","addVertexToFace","append","insertBefore","removeVertexFromFace","remove","removeAllVerticesFromFace","start","end","removeSubList","deleteFaceVertices","absorbingFace","faceVertices","appendChain","nextVertex","resolveUnassignedPoints","isEmpty","first","maxDistance","maxFace","distance","computeExtremes","j","minVertices","maxVertices","copy","getComponent","setComponent","Number","EPSILON","abs","x","y","z","computeInitialHull","Line3","Plane","v0","v2","v3","extremes","index","set","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","create","getEdge","setTwin","reindexFaces","activeFaces","nextVertexToAdd","eyeVertex","eyeFace","computeHorizon","eyePoint","crossEdge","horizon","twinEdge","oppositeFace","addAdjoiningFace","horizonEdge","addNewFaces","firstSideEdge","previousSideEdge","sideEdge","addVertexToHull","clear","cleanup","a","b","c","e0","e1","e2","Triangle","getNormal","getMidpoint","getArea","distanceTo","lengthSquared","last","insertAfter","ConvexGeometry","Geometry","call","fromBufferGeometry","ConvexBufferGeometry","mergeVertices","constructor","BufferGeometry","normals","setAttribute","Float32BufferAttribute","webglGeometryConvex","data","group","camera","scene","renderer","mounted","init","animate","methods","$THREE","Scene","WebGLRenderer","antialias","setPixelRatio","window","devicePixelRatio","setSize","$webglInnerWidth","innerHeight","document","getElementsByClassName","appendChild","domElement","PerspectiveCamera","add","controls","OrbitControls","minDistance","maxPolarAngle","PI","AmbientLight","light","PointLight","AxesHelper","texture","TextureLoader","load","Group","DodecahedronGeometry","pointsMaterial","PointsMaterial","color","map","size","alphaTest","pointsGeometry","Points","meshMaterial","MeshLambertMaterial","opacity","transparent","meshGeometry","ConvexGeometry_ConvexBufferGeometry","mesh1","Mesh","material","side","BackSide","renderOrder","mesh2","FrontSide","addEventListener","onWindowResize","$onWindowResize","requestAnimationFrame","rotation","render","geometries_webglGeometryConvex","$createElement","_self","_c","_m","staticRenderFns","_h","staticClass","attrs","id","href","rel","_v","Component","__webpack_require__","normalizeComponent","ssrContext","__webpack_exports__"],"mappings":"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","file":"static/js/134.2901f32b3118a07cca7e.js","sourcesContent":["import {\r\n\tLine3,\r\n\tPlane,\r\n\tTriangle,\r\n\tVector3\r\n} from \"@/components/build/three.module.js\";\r\n\r\n/**\r\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\r\n */\r\n\r\nvar ConvexHull = ( function () {\r\n\r\n\tvar Visible = 0;\r\n\tvar Deleted = 1;\r\n\r\n\tvar v1 = new Vector3();\r\n\r\n\tfunction ConvexHull() {\r\n\r\n\t\tthis.tolerance = - 1;\r\n\r\n\t\tthis.faces = []; // the generated faces of the convex hull\r\n\t\tthis.newFaces = []; // this array holds the faces that are generated within a single iteration\r\n\r\n\t\t// the vertex lists work as follows:\r\n\t\t//\r\n\t\t// let 'a' and 'b' be 'Face' instances\r\n\t\t// let 'v' be points wrapped as instance of 'Vertex'\r\n\t\t//\r\n\t\t//     [v, v, ..., v, v, v, ...]\r\n\t\t//      ^             ^\r\n\t\t//      |             |\r\n\t\t//  a.outside     b.outside\r\n\t\t//\r\n\t\tthis.assigned = new VertexList();\r\n\t\tthis.unassigned = new VertexList();\r\n\r\n\t\tthis.vertices = []; \t// vertices of the hull (internal representation of given geometry data)\r\n\r\n\t}\r\n\r\n\tObject.assign( ConvexHull.prototype, {\r\n\r\n\t\tsetFromPoints: function ( points ) {\r\n\r\n\t\t\tif ( Array.isArray( points ) !== true ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.ConvexHull: Points parameter is not an array.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( points.length < 4 ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.ConvexHull: The algorithm needs at least four points.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tthis.vertices.push( new VertexNode( points[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.compute();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromObject: function ( object ) {\r\n\r\n\t\t\tvar points = [];\r\n\r\n\t\t\tobject.updateMatrixWorld( true );\r\n\r\n\t\t\tobject.traverse( function ( node ) {\r\n\r\n\t\t\t\tvar i, l, point;\r\n\r\n\t\t\t\tvar geometry = node.geometry;\r\n\r\n\t\t\t\tif ( geometry !== undefined ) {\r\n\r\n\t\t\t\t\tif ( geometry.isGeometry ) {\r\n\r\n\t\t\t\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint = vertices[ i ].clone();\r\n\t\t\t\t\t\t\tpoint.applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\tpoints.push( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\t\t\t\tvar attribute = geometry.attributes.position;\r\n\r\n\t\t\t\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tpoint = new Vector3();\r\n\r\n\t\t\t\t\t\t\t\tpoint.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\t\tpoints.push( point );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn this.setFromPoints( points );\r\n\r\n\t\t},\r\n\r\n\t\tcontainsPoint: function ( point ) {\r\n\r\n\t\t\tvar faces = this.faces;\r\n\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\t\t// compute signed distance and check on what half space the point lies\r\n\r\n\t\t\t\tif ( face.distanceToPoint( point ) > this.tolerance ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t},\r\n\r\n\t\tintersectRay: function ( ray, target ) {\r\n\r\n\t\t\t// based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\r\n\r\n\t\t\tvar faces = this.faces;\r\n\r\n\t\t\tvar tNear = - Infinity;\r\n\t\t\tvar tFar = Infinity;\r\n\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\t\t// interpret faces as planes for the further computation\r\n\r\n\t\t\t\tvar vN = face.distanceToPoint( ray.origin );\r\n\t\t\t\tvar vD = face.normal.dot( ray.direction );\r\n\r\n\t\t\t\t// if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\r\n\t\t\t\t// the ray is turned away or parallel to the plane, there is no intersection\r\n\r\n\t\t\t\tif ( vN > 0 && vD >= 0 ) return null;\r\n\r\n\t\t\t\t// compute the distance from the rayâ€™s origin to the intersection with the plane\r\n\r\n\t\t\t\tvar t = ( vD !== 0 ) ? ( - vN / vD ) : 0;\r\n\r\n\t\t\t\t// only proceed if the distance is positive. a negative distance means the intersection point\r\n\t\t\t\t// lies \"behind\" the origin\r\n\r\n\t\t\t\tif ( t <= 0 ) continue;\r\n\r\n\t\t\t\t// now categorized plane as front-facing or back-facing\r\n\r\n\t\t\t\tif ( vD > 0 ) {\r\n\r\n\t\t\t\t\t//  plane faces away from the ray, so this plane is a back-face\r\n\r\n\t\t\t\t\ttFar = Math.min( t, tFar );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// front-face\r\n\r\n\t\t\t\t\ttNear = Math.max( t, tNear );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( tNear > tFar ) {\r\n\r\n\t\t\t\t\t// if tNear ever is greater than tFar, the ray must miss the convex hull\r\n\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// evaluate intersection point\r\n\r\n\t\t\t// always try tNear first since its the closer intersection point\r\n\r\n\t\t\tif ( tNear !== - Infinity ) {\r\n\r\n\t\t\t\tray.at( tNear, target );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tray.at( tFar, target );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t},\r\n\r\n\t\tintersectsRay: function ( ray ) {\r\n\r\n\t\t\treturn this.intersectRay( ray, v1 ) !== null;\r\n\r\n\t\t},\r\n\r\n\t\tmakeEmpty: function () {\r\n\r\n\t\t\tthis.faces = [];\r\n\t\t\tthis.vertices = [];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\r\n\r\n\t\taddVertexToFace: function ( vertex, face ) {\r\n\r\n\t\t\tvertex.face = face;\r\n\r\n\t\t\tif ( face.outside === null ) {\r\n\r\n\t\t\t\tthis.assigned.append( vertex );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.assigned.insertBefore( face.outside, vertex );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tface.outside = vertex;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Removes a vertex from the 'assigned' list of vertices and from the given face\r\n\r\n\t\tremoveVertexFromFace: function ( vertex, face ) {\r\n\r\n\t\t\tif ( vertex === face.outside ) {\r\n\r\n\t\t\t\t// fix face.outside link\r\n\r\n\t\t\t\tif ( vertex.next !== null && vertex.next.face === face ) {\r\n\r\n\t\t\t\t\t// face has at least 2 outside vertices, move the 'outside' reference\r\n\r\n\t\t\t\t\tface.outside = vertex.next;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// vertex was the only outside vertex that face had\r\n\r\n\t\t\t\t\tface.outside = null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.assigned.remove( vertex );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\r\n\r\n\t\tremoveAllVerticesFromFace: function ( face ) {\r\n\r\n\t\t\tif ( face.outside !== null ) {\r\n\r\n\t\t\t\t// reference to the first and last vertex of this face\r\n\r\n\t\t\t\tvar start = face.outside;\r\n\t\t\t\tvar end = face.outside;\r\n\r\n\t\t\t\twhile ( end.next !== null && end.next.face === face ) {\r\n\r\n\t\t\t\t\tend = end.next;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.assigned.removeSubList( start, end );\r\n\r\n\t\t\t\t// fix references\r\n\r\n\t\t\t\tstart.prev = end.next = null;\r\n\t\t\t\tface.outside = null;\r\n\r\n\t\t\t\treturn start;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t// Removes all the visible vertices that 'face' is able to see\r\n\r\n\t\tdeleteFaceVertices: function ( face, absorbingFace ) {\r\n\r\n\t\t\tvar faceVertices = this.removeAllVerticesFromFace( face );\r\n\r\n\t\t\tif ( faceVertices !== undefined ) {\r\n\r\n\t\t\t\tif ( absorbingFace === undefined ) {\r\n\r\n\t\t\t\t\t// mark the vertices to be reassigned to some other face\r\n\r\n\t\t\t\t\tthis.unassigned.appendChain( faceVertices );\r\n\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// if there's an absorbing face try to assign as many vertices as possible to it\r\n\r\n\t\t\t\t\tvar vertex = faceVertices;\r\n\r\n\t\t\t\t\tdo {\r\n\r\n\t\t\t\t\t\t// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\r\n\t\t\t\t\t\t// will be changed by upcoming method calls\r\n\r\n\t\t\t\t\t\tvar nextVertex = vertex.next;\r\n\r\n\t\t\t\t\t\tvar distance = absorbingFace.distanceToPoint( vertex.point );\r\n\r\n\t\t\t\t\t\t// check if 'vertex' is able to see 'absorbingFace'\r\n\r\n\t\t\t\t\t\tif ( distance > this.tolerance ) {\r\n\r\n\t\t\t\t\t\t\tthis.addVertexToFace( vertex, absorbingFace );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tthis.unassigned.append( vertex );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// now assign next vertex\r\n\r\n\t\t\t\t\t\tvertex = nextVertex;\r\n\r\n\t\t\t\t\t} while ( vertex !== null );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Reassigns as many vertices as possible from the unassigned list to the new faces\r\n\r\n\t\tresolveUnassignedPoints: function ( newFaces ) {\r\n\r\n\t\t\tif ( this.unassigned.isEmpty() === false ) {\r\n\r\n\t\t\t\tvar vertex = this.unassigned.first();\r\n\r\n\t\t\t\tdo {\r\n\r\n\t\t\t\t\t// buffer 'next' reference, see .deleteFaceVertices()\r\n\r\n\t\t\t\t\tvar nextVertex = vertex.next;\r\n\r\n\t\t\t\t\tvar maxDistance = this.tolerance;\r\n\r\n\t\t\t\t\tvar maxFace = null;\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < newFaces.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar face = newFaces[ i ];\r\n\r\n\t\t\t\t\t\tif ( face.mark === Visible ) {\r\n\r\n\t\t\t\t\t\t\tvar distance = face.distanceToPoint( vertex.point );\r\n\r\n\t\t\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\t\t\tmaxFace = face;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( maxDistance > 1000 * this.tolerance ) break;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// 'maxFace' can be null e.g. if there are identical vertices\r\n\r\n\t\t\t\t\tif ( maxFace !== null ) {\r\n\r\n\t\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvertex = nextVertex;\r\n\r\n\t\t\t\t} while ( vertex !== null );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Computes the extremes of a simplex which will be the initial hull\r\n\r\n\t\tcomputeExtremes: function () {\r\n\r\n\t\t\tvar min = new Vector3();\r\n\t\t\tvar max = new Vector3();\r\n\r\n\t\t\tvar minVertices = [];\r\n\t\t\tvar maxVertices = [];\r\n\r\n\t\t\tvar i, l, j;\r\n\r\n\t\t\t// initially assume that the first vertex is the min/max\r\n\r\n\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tminVertices[ i ] = maxVertices[ i ] = this.vertices[ 0 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.copy( this.vertices[ 0 ].point );\r\n\t\t\tmax.copy( this.vertices[ 0 ].point );\r\n\r\n\t\t\t// compute the min/max vertex on all six directions\r\n\r\n\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\t\tvar point = vertex.point;\r\n\r\n\t\t\t\t// update the min coordinates\r\n\r\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\tif ( point.getComponent( j ) < min.getComponent( j ) ) {\r\n\r\n\t\t\t\t\t\tmin.setComponent( j, point.getComponent( j ) );\r\n\t\t\t\t\t\tminVertices[ j ] = vertex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// update the max coordinates\r\n\r\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\tif ( point.getComponent( j ) > max.getComponent( j ) ) {\r\n\r\n\t\t\t\t\t\tmax.setComponent( j, point.getComponent( j ) );\r\n\t\t\t\t\t\tmaxVertices[ j ] = vertex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// use min/max vectors to compute an optimal epsilon\r\n\r\n\t\t\tthis.tolerance = 3 * Number.EPSILON * (\r\n\t\t\t\tMath.max( Math.abs( min.x ), Math.abs( max.x ) ) +\r\n\t\t\t\tMath.max( Math.abs( min.y ), Math.abs( max.y ) ) +\r\n\t\t\t\tMath.max( Math.abs( min.z ), Math.abs( max.z ) )\r\n\t\t\t);\r\n\r\n\t\t\treturn { min: minVertices, max: maxVertices };\r\n\r\n\t\t},\r\n\r\n\t\t// Computes the initial simplex assigning to its faces all the points\r\n\t\t// that are candidates to form part of the hull\r\n\r\n\t\tcomputeInitialHull: function () {\r\n\r\n\t\t\tvar line3, plane, closestPoint;\r\n\r\n\t\t\treturn function computeInitialHull() {\r\n\r\n\t\t\t\tif ( line3 === undefined ) {\r\n\r\n\t\t\t\t\tline3 = new Line3();\r\n\t\t\t\t\tplane = new Plane();\r\n\t\t\t\t\tclosestPoint = new Vector3();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar vertex, vertices = this.vertices;\r\n\t\t\t\tvar extremes = this.computeExtremes();\r\n\t\t\t\tvar min = extremes.min;\r\n\t\t\t\tvar max = extremes.max;\r\n\r\n\t\t\t\tvar v0, v1, v2, v3;\r\n\t\t\t\tvar i, l, j;\r\n\r\n\t\t\t\t// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\r\n\t\t\t\t// (max.x - min.x)\r\n\t\t\t\t// (max.y - min.y)\r\n\t\t\t\t// (max.z - min.z)\r\n\r\n\t\t\t\tvar distance, maxDistance = 0;\r\n\t\t\t\tvar index = 0;\r\n\r\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tdistance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );\r\n\r\n\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\tindex = i;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tv0 = min[ index ];\r\n\t\t\t\tv1 = max[ index ];\r\n\r\n\t\t\t\t// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\r\n\r\n\t\t\t\tmaxDistance = 0;\r\n\t\t\t\tline3.set( v0.point, v1.point );\r\n\r\n\t\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvertex = vertices[ i ];\r\n\r\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 ) {\r\n\r\n\t\t\t\t\t\tline3.closestPointToPoint( vertex.point, true, closestPoint );\r\n\r\n\t\t\t\t\t\tdistance = closestPoint.distanceToSquared( vertex.point );\r\n\r\n\t\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\t\tv2 = vertex;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\r\n\r\n\t\t\t\tmaxDistance = - 1;\r\n\t\t\t\tplane.setFromCoplanarPoints( v0.point, v1.point, v2.point );\r\n\r\n\t\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvertex = vertices[ i ];\r\n\r\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {\r\n\r\n\t\t\t\t\t\tdistance = Math.abs( plane.distanceToPoint( vertex.point ) );\r\n\r\n\t\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\t\tv3 = vertex;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar faces = [];\r\n\r\n\t\t\t\tif ( plane.distanceToPoint( v3.point ) < 0 ) {\r\n\r\n\t\t\t\t\t// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\r\n\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tFace.create( v0, v1, v2 ),\r\n\t\t\t\t\t\tFace.create( v3, v1, v0 ),\r\n\t\t\t\t\t\tFace.create( v3, v2, v1 ),\r\n\t\t\t\t\t\tFace.create( v3, v0, v2 )\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// set the twin edge\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tj = ( i + 1 ) % 3;\r\n\r\n\t\t\t\t\t\t// join face[ i ] i > 0, with the first face\r\n\r\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );\r\n\r\n\t\t\t\t\t\t// join face[ i ] with face[ i + 1 ], 1 <= i <= 3\r\n\r\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\r\n\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tFace.create( v0, v2, v1 ),\r\n\t\t\t\t\t\tFace.create( v3, v0, v1 ),\r\n\t\t\t\t\t\tFace.create( v3, v1, v2 ),\r\n\t\t\t\t\t\tFace.create( v3, v2, v0 )\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// set the twin edge\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tj = ( i + 1 ) % 3;\r\n\r\n\t\t\t\t\t\t// join face[ i ] i > 0, with the first face\r\n\r\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );\r\n\r\n\t\t\t\t\t\t// join face[ i ] with face[ i + 1 ]\r\n\r\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// the initial hull is the tetrahedron\r\n\r\n\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\tthis.faces.push( faces[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// initial assignment of vertices to the faces of the tetrahedron\r\n\r\n\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvertex = vertices[ i ];\r\n\r\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {\r\n\r\n\t\t\t\t\t\tmaxDistance = this.tolerance;\r\n\t\t\t\t\t\tvar maxFace = null;\r\n\r\n\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tdistance = this.faces[ j ].distanceToPoint( vertex.point );\r\n\r\n\t\t\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\t\t\tmaxFace = this.faces[ j ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( maxFace !== null ) {\r\n\r\n\t\t\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t};\r\n\r\n\t\t}(),\r\n\r\n\t\t// Removes inactive faces\r\n\r\n\t\treindexFaces: function () {\r\n\r\n\t\t\tvar activeFaces = [];\r\n\r\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\r\n\r\n\t\t\t\tvar face = this.faces[ i ];\r\n\r\n\t\t\t\tif ( face.mark === Visible ) {\r\n\r\n\t\t\t\t\tactiveFaces.push( face );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.faces = activeFaces;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Finds the next vertex to create faces with the current hull\r\n\r\n\t\tnextVertexToAdd: function () {\r\n\r\n\t\t\t// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\r\n\r\n\t\t\tif ( this.assigned.isEmpty() === false ) {\r\n\r\n\t\t\t\tvar eyeVertex, maxDistance = 0;\r\n\r\n\t\t\t\t// grap the first available face and start with the first visible vertex of that face\r\n\r\n\t\t\t\tvar eyeFace = this.assigned.first().face;\r\n\t\t\t\tvar vertex = eyeFace.outside;\r\n\r\n\t\t\t\t// now calculate the farthest vertex that face can see\r\n\r\n\t\t\t\tdo {\r\n\r\n\t\t\t\t\tvar distance = eyeFace.distanceToPoint( vertex.point );\r\n\r\n\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\teyeVertex = vertex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvertex = vertex.next;\r\n\r\n\t\t\t\t} while ( vertex !== null && vertex.face === eyeFace );\r\n\r\n\t\t\t\treturn eyeVertex;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t// Computes a chain of half edges in CCW order called the 'horizon'.\r\n\t\t// For an edge to be part of the horizon it must join a face that can see\r\n\t\t// 'eyePoint' and a face that cannot see 'eyePoint'.\r\n\r\n\t\tcomputeHorizon: function ( eyePoint, crossEdge, face, horizon ) {\r\n\r\n\t\t\t// moves face's vertices to the 'unassigned' vertex list\r\n\r\n\t\t\tthis.deleteFaceVertices( face );\r\n\r\n\t\t\tface.mark = Deleted;\r\n\r\n\t\t\tvar edge;\r\n\r\n\t\t\tif ( crossEdge === null ) {\r\n\r\n\t\t\t\tedge = crossEdge = face.getEdge( 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// start from the next edge since 'crossEdge' was already analyzed\r\n\t\t\t\t// (actually 'crossEdge.twin' was the edge who called this method recursively)\r\n\r\n\t\t\t\tedge = crossEdge.next;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvar twinEdge = edge.twin;\r\n\t\t\t\tvar oppositeFace = twinEdge.face;\r\n\r\n\t\t\t\tif ( oppositeFace.mark === Visible ) {\r\n\r\n\t\t\t\t\tif ( oppositeFace.distanceToPoint( eyePoint ) > this.tolerance ) {\r\n\r\n\t\t\t\t\t\t// the opposite face can see the vertex, so proceed with next edge\r\n\r\n\t\t\t\t\t\tthis.computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// the opposite face can't see the vertex, so this edge is part of the horizon\r\n\r\n\t\t\t\t\t\thorizon.push( edge );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tedge = edge.next;\r\n\r\n\t\t\t} while ( edge !== crossEdge );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\r\n\r\n\t\taddAdjoiningFace: function ( eyeVertex, horizonEdge ) {\r\n\r\n\t\t\t// all the half edges are created in ccw order thus the face is always pointing outside the hull\r\n\r\n\t\t\tvar face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );\r\n\r\n\t\t\tthis.faces.push( face );\r\n\r\n\t\t\t// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\r\n\r\n\t\t\tface.getEdge( - 1 ).setTwin( horizonEdge.twin );\r\n\r\n\t\t\treturn face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex\r\n\r\n\r\n\t\t},\r\n\r\n\t\t//  Adds 'horizon.length' faces to the hull, each face will be linked with the\r\n\t\t//  horizon opposite face and the face on the left/right\r\n\r\n\t\taddNewFaces: function ( eyeVertex, horizon ) {\r\n\r\n\t\t\tthis.newFaces = [];\r\n\r\n\t\t\tvar firstSideEdge = null;\r\n\t\t\tvar previousSideEdge = null;\r\n\r\n\t\t\tfor ( var i = 0; i < horizon.length; i ++ ) {\r\n\r\n\t\t\t\tvar horizonEdge = horizon[ i ];\r\n\r\n\t\t\t\t// returns the right side edge\r\n\r\n\t\t\t\tvar sideEdge = this.addAdjoiningFace( eyeVertex, horizonEdge );\r\n\r\n\t\t\t\tif ( firstSideEdge === null ) {\r\n\r\n\t\t\t\t\tfirstSideEdge = sideEdge;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\r\n\r\n\t\t\t\t\tsideEdge.next.setTwin( previousSideEdge );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.newFaces.push( sideEdge.face );\r\n\t\t\t\tpreviousSideEdge = sideEdge;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// perform final join of new faces\r\n\r\n\t\t\tfirstSideEdge.next.setTwin( previousSideEdge );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Adds a vertex to the hull\r\n\r\n\t\taddVertexToHull: function ( eyeVertex ) {\r\n\r\n\t\t\tvar horizon = [];\r\n\r\n\t\t\tthis.unassigned.clear();\r\n\r\n\t\t\t// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\r\n\r\n\t\t\tthis.removeVertexFromFace( eyeVertex, eyeVertex.face );\r\n\r\n\t\t\tthis.computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );\r\n\r\n\t\t\tthis.addNewFaces( eyeVertex, horizon );\r\n\r\n\t\t\t// reassign 'unassigned' vertices to the new faces\r\n\r\n\t\t\tthis.resolveUnassignedPoints( this.newFaces );\r\n\r\n\t\t\treturn\tthis;\r\n\r\n\t\t},\r\n\r\n\t\tcleanup: function () {\r\n\r\n\t\t\tthis.assigned.clear();\r\n\t\t\tthis.unassigned.clear();\r\n\t\t\tthis.newFaces = [];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tcompute: function () {\r\n\r\n\t\t\tvar vertex;\r\n\r\n\t\t\tthis.computeInitialHull();\r\n\r\n\t\t\t// add all available vertices gradually to the hull\r\n\r\n\t\t\twhile ( ( vertex = this.nextVertexToAdd() ) !== undefined ) {\r\n\r\n\t\t\t\tthis.addVertexToHull( vertex );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.reindexFaces();\r\n\r\n\t\t\tthis.cleanup();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\t//\r\n\r\n\tfunction Face() {\r\n\r\n\t\tthis.normal = new Vector3();\r\n\t\tthis.midpoint = new Vector3();\r\n\t\tthis.area = 0;\r\n\r\n\t\tthis.constant = 0; // signed distance from face to the origin\r\n\t\tthis.outside = null; // reference to a vertex in a vertex list this face can see\r\n\t\tthis.mark = Visible;\r\n\t\tthis.edge = null;\r\n\r\n\t}\r\n\r\n\tObject.assign( Face, {\r\n\r\n\t\tcreate: function ( a, b, c ) {\r\n\r\n\t\t\tvar face = new Face();\r\n\r\n\t\t\tvar e0 = new HalfEdge( a, face );\r\n\t\t\tvar e1 = new HalfEdge( b, face );\r\n\t\t\tvar e2 = new HalfEdge( c, face );\r\n\r\n\t\t\t// join edges\r\n\r\n\t\t\te0.next = e2.prev = e1;\r\n\t\t\te1.next = e0.prev = e2;\r\n\t\t\te2.next = e1.prev = e0;\r\n\r\n\t\t\t// main half edge reference\r\n\r\n\t\t\tface.edge = e0;\r\n\r\n\t\t\treturn face.compute();\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\tObject.assign( Face.prototype, {\r\n\r\n\t\tgetEdge: function ( i ) {\r\n\r\n\t\t\tvar edge = this.edge;\r\n\r\n\t\t\twhile ( i > 0 ) {\r\n\r\n\t\t\t\tedge = edge.next;\r\n\t\t\t\ti --;\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhile ( i < 0 ) {\r\n\r\n\t\t\t\tedge = edge.prev;\r\n\t\t\t\ti ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn edge;\r\n\r\n\t\t},\r\n\r\n\t\tcompute: function () {\r\n\r\n\t\t\tvar triangle;\r\n\r\n\t\t\treturn function compute() {\r\n\r\n\t\t\t\tif ( triangle === undefined ) triangle = new Triangle();\r\n\r\n\t\t\t\tvar a = this.edge.tail();\r\n\t\t\t\tvar b = this.edge.head();\r\n\t\t\t\tvar c = this.edge.next.head();\r\n\r\n\t\t\t\ttriangle.set( a.point, b.point, c.point );\r\n\r\n\t\t\t\ttriangle.getNormal( this.normal );\r\n\t\t\t\ttriangle.getMidpoint( this.midpoint );\r\n\t\t\t\tthis.area = triangle.getArea();\r\n\r\n\t\t\t\tthis.constant = this.normal.dot( this.midpoint );\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t};\r\n\r\n\t\t}(),\r\n\r\n\t\tdistanceToPoint: function ( point ) {\r\n\r\n\t\t\treturn this.normal.dot( point ) - this.constant;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\t// Entity for a Doubly-Connected Edge List (DCEL).\r\n\r\n\tfunction HalfEdge( vertex, face ) {\r\n\r\n\t\tthis.vertex = vertex;\r\n\t\tthis.prev = null;\r\n\t\tthis.next = null;\r\n\t\tthis.twin = null;\r\n\t\tthis.face = face;\r\n\r\n\t}\r\n\r\n\tObject.assign( HalfEdge.prototype, {\r\n\r\n\t\thead: function () {\r\n\r\n\t\t\treturn this.vertex;\r\n\r\n\t\t},\r\n\r\n\t\ttail: function () {\r\n\r\n\t\t\treturn this.prev ? this.prev.vertex : null;\r\n\r\n\t\t},\r\n\r\n\t\tlength: function () {\r\n\r\n\t\t\tvar head = this.head();\r\n\t\t\tvar tail = this.tail();\r\n\r\n\t\t\tif ( tail !== null ) {\r\n\r\n\t\t\t\treturn tail.point.distanceTo( head.point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn - 1;\r\n\r\n\t\t},\r\n\r\n\t\tlengthSquared: function () {\r\n\r\n\t\t\tvar head = this.head();\r\n\t\t\tvar tail = this.tail();\r\n\r\n\t\t\tif ( tail !== null ) {\r\n\r\n\t\t\t\treturn tail.point.distanceToSquared( head.point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn - 1;\r\n\r\n\t\t},\r\n\r\n\t\tsetTwin: function ( edge ) {\r\n\r\n\t\t\tthis.twin = edge;\r\n\t\t\tedge.twin = this;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\t// A vertex as a double linked list node.\r\n\r\n\tfunction VertexNode( point ) {\r\n\r\n\t\tthis.point = point;\r\n\t\tthis.prev = null;\r\n\t\tthis.next = null;\r\n\t\tthis.face = null; // the face that is able to see this vertex\r\n\r\n\t}\r\n\r\n\t// A double linked list that contains vertex nodes.\r\n\r\n\tfunction VertexList() {\r\n\r\n\t\tthis.head = null;\r\n\t\tthis.tail = null;\r\n\r\n\t}\r\n\r\n\tObject.assign( VertexList.prototype, {\r\n\r\n\t\tfirst: function () {\r\n\r\n\t\t\treturn this.head;\r\n\r\n\t\t},\r\n\r\n\t\tlast: function () {\r\n\r\n\t\t\treturn this.tail;\r\n\r\n\t\t},\r\n\r\n\t\tclear: function () {\r\n\r\n\t\t\tthis.head = this.tail = null;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Inserts a vertex before the target vertex\r\n\r\n\t\tinsertBefore: function ( target, vertex ) {\r\n\r\n\t\t\tvertex.prev = target.prev;\r\n\t\t\tvertex.next = target;\r\n\r\n\t\t\tif ( vertex.prev === null ) {\r\n\r\n\t\t\t\tthis.head = vertex;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertex.prev.next = vertex;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.prev = vertex;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Inserts a vertex after the target vertex\r\n\r\n\t\tinsertAfter: function ( target, vertex ) {\r\n\r\n\t\t\tvertex.prev = target;\r\n\t\t\tvertex.next = target.next;\r\n\r\n\t\t\tif ( vertex.next === null ) {\r\n\r\n\t\t\t\tthis.tail = vertex;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertex.next.prev = vertex;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.next = vertex;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Appends a vertex to the end of the linked list\r\n\r\n\t\tappend: function ( vertex ) {\r\n\r\n\t\t\tif ( this.head === null ) {\r\n\r\n\t\t\t\tthis.head = vertex;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.tail.next = vertex;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvertex.prev = this.tail;\r\n\t\t\tvertex.next = null; // the tail has no subsequent vertex\r\n\r\n\t\t\tthis.tail = vertex;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Appends a chain of vertices where 'vertex' is the head.\r\n\r\n\t\tappendChain: function ( vertex ) {\r\n\r\n\t\t\tif ( this.head === null ) {\r\n\r\n\t\t\t\tthis.head = vertex;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.tail.next = vertex;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvertex.prev = this.tail;\r\n\r\n\t\t\t// ensure that the 'tail' reference points to the last vertex of the chain\r\n\r\n\t\t\twhile ( vertex.next !== null ) {\r\n\r\n\t\t\t\tvertex = vertex.next;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.tail = vertex;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Removes a vertex from the linked list\r\n\r\n\t\tremove: function ( vertex ) {\r\n\r\n\t\t\tif ( vertex.prev === null ) {\r\n\r\n\t\t\t\tthis.head = vertex.next;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertex.prev.next = vertex.next;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( vertex.next === null ) {\r\n\r\n\t\t\t\tthis.tail = vertex.prev;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertex.next.prev = vertex.prev;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\r\n\r\n\t\tremoveSubList: function ( a, b ) {\r\n\r\n\t\t\tif ( a.prev === null ) {\r\n\r\n\t\t\t\tthis.head = b.next;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ta.prev.next = b.next;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( b.next === null ) {\r\n\r\n\t\t\t\tthis.tail = a.prev;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tb.next.prev = a.prev;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tisEmpty: function () {\r\n\r\n\t\t\treturn this.head === null;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn ConvexHull;\r\n\r\n} )();\r\n\r\nexport { ConvexHull };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/jsm/math/ConvexHull.js","import {\r\n\tBufferGeometry,\r\n\tFloat32BufferAttribute,\r\n\tGeometry\r\n} from \"@/components/build/three.module.js\";\r\nimport { ConvexHull } from \"../math/ConvexHull.js\";\r\n\r\n// ConvexGeometry\r\n\r\nvar ConvexGeometry = function ( points ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.fromBufferGeometry( new ConvexBufferGeometry( points ) );\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nConvexGeometry.prototype = Object.create( Geometry.prototype );\r\nConvexGeometry.prototype.constructor = ConvexGeometry;\r\n\r\n// ConvexBufferGeometry\r\n\r\nvar ConvexBufferGeometry = function ( points ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\t// buffers\r\n\r\n\tvar vertices = [];\r\n\tvar normals = [];\r\n\r\n\tif ( ConvexHull === undefined ) {\r\n\r\n\t\tconsole.error( 'THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull' );\r\n\r\n\t}\r\n\r\n\tvar convexHull = new ConvexHull().setFromPoints( points );\r\n\r\n\t// generate vertices and normals\r\n\r\n\tvar faces = convexHull.faces;\r\n\r\n\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\tvar face = faces[ i ];\r\n\t\tvar edge = face.edge;\r\n\r\n\t\t// we move along a doubly-connected edge list to access all face points (see HalfEdge docs)\r\n\r\n\t\tdo {\r\n\r\n\t\t\tvar point = edge.head().point;\r\n\r\n\t\t\tvertices.push( point.x, point.y, point.z );\r\n\t\t\tnormals.push( face.normal.x, face.normal.y, face.normal.z );\r\n\r\n\t\t\tedge = edge.next;\r\n\r\n\t\t} while ( edge !== face.edge );\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\r\n};\r\n\r\nConvexBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nConvexBufferGeometry.prototype.constructor = ConvexBufferGeometry;\r\n\r\nexport { ConvexGeometry, ConvexBufferGeometry };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/jsm/geometries/ConvexGeometry.js","<template>\r\n    <div class=\"webglGeometryConvex-container\">\r\n        <div id=\"info\"><a href=\"https://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a> - convex geometry</div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport { OrbitControls } from '@/components/jsm/controls/OrbitControls.js'\r\nimport { ConvexBufferGeometry } from '@/components/jsm/geometries/ConvexGeometry.js'\r\nexport default {\r\n    data() {\r\n        return {\r\n            group: null,\r\n            camera: null,\r\n            scene: null,\r\n            renderer: null\r\n        }\r\n    },\r\n    mounted() {\r\n        this.init()\r\n        this.animate()\r\n    },\r\n    methods: {\r\n        init() {\r\n            this.scene = new this.$THREE.Scene()\r\n            this.renderer = new this.$THREE.WebGLRenderer({ antialias: true })\r\n            this.renderer.setPixelRatio(window.devicePixelRatio)\r\n            this.renderer.setSize(this.$webglInnerWidth, window.innerHeight)\r\n            document.getElementsByClassName('webglGeometryConvex-container')[0].appendChild(this.renderer.domElement)\r\n            // camera\r\n            this.camera = new this.$THREE.PerspectiveCamera(40, this.$webglInnerWidth / window.innerHeight, 1, 1000)\r\n            this.camera.position.set(15, 20, 30)\r\n            this.scene.add(this.camera)\r\n            // controls\r\n            var controls = new OrbitControls(this.camera, this.renderer.domElement)\r\n            controls.minDistance = 20\r\n            controls.maxDistance = 50\r\n            controls.maxPolarAngle = Math.PI / 2\r\n            this.scene.add(new this.$THREE.AmbientLight(0x222222))\r\n            // light\r\n            var light = new this.$THREE.PointLight(0xffffff, 1)\r\n            this.camera.add(light)\r\n            // helper\r\n            this.scene.add(new this.$THREE.AxesHelper(20))\r\n            // textures\r\n            var loader = new this.$THREE.TextureLoader()\r\n            var texture = loader.load('static/textures/sprites/disc.png')\r\n            this.group = new this.$THREE.Group()\r\n            this.scene.add(this.group)\r\n            // points\r\n            var vertices = new this.$THREE.DodecahedronGeometry(10).vertices\r\n            for (let i = 0; i < vertices.length; i ++) {\r\n                //vertices[ i ].add(randomPoint().multiplyScalar(2)); // wiggle the points\r\n            }\r\n            var pointsMaterial = new this.$THREE.PointsMaterial({\r\n                color: 0x0080ff,\r\n                map: texture,\r\n                size: 1,\r\n                alphaTest: 0.5\r\n            })\r\n            var pointsGeometry = new this.$THREE.BufferGeometry().setFromPoints(vertices)\r\n            var points = new this.$THREE.Points(pointsGeometry, pointsMaterial)\r\n            this.group.add(points)\r\n            // convex hull\r\n            var meshMaterial = new this.$THREE.MeshLambertMaterial({\r\n                color: 0xffffff,\r\n                opacity: 0.5,\r\n                transparent: true\r\n            })\r\n            var meshGeometry = new ConvexBufferGeometry(vertices)\r\n            var mesh1 = new this.$THREE.Mesh(meshGeometry, meshMaterial)\r\n            mesh1.material.side = this.$THREE.BackSide // back faces\r\n            mesh1.renderOrder = 0\r\n            this.group.add(mesh1)\r\n            var mesh2 = new this.$THREE.Mesh(meshGeometry, meshMaterial.clone())\r\n            mesh2.material.side = this.$THREE.FrontSide // front faces\r\n            mesh2.renderOrder = 1\r\n            this.group.add(mesh2)\r\n            //\r\n            window.addEventListener('resize', this.onWindowResize, false)\r\n        },\r\n        onWindowResize() {\r\n            this.$onWindowResize(this.camera, this.renderer)\r\n        },\r\n        animate() {\r\n            requestAnimationFrame(this.animate)\r\n            this.group.rotation.y += 0.005\r\n            this.render()\r\n        },\r\n        render() {\r\n            this.renderer.render(this.scene, this.camera)\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n.webglGeometryConvex-container {\r\n    width: 100%;\r\n}\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// src/views/geometries/webglGeometryConvex.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"webglGeometryConvex-container\"},[_c('div',{attrs:{\"id\":\"info\"}},[_c('a',{attrs:{\"href\":\"https://threejs.org\",\"target\":\"_blank\",\"rel\":\"noopener\"}},[_vm._v(\"three.js\")]),_vm._v(\" - convex geometry\")])])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-0e7966c4\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/views/geometries/webglGeometryConvex.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true,\\\"publicPath\\\":\\\"../../\\\"}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-0e7966c4\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./webglGeometryConvex.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./webglGeometryConvex.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./webglGeometryConvex.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-0e7966c4\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./webglGeometryConvex.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-0e7966c4\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/geometries/webglGeometryConvex.vue\n// module id = null\n// module chunks = "],"sourceRoot":""}