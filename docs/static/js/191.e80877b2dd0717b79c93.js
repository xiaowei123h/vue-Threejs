webpackJsonp([191],{DINT:function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var a=i("wIBv"),n=i("QEtz"),r=i("6+nK"),s=function(){function t(t,e){for(var i=0;i<e.length;i++){var a=e[i];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(t,a.key,a)}}return function(e,i,a){return i&&t(e.prototype,i),a&&t(e,a),e}}();var o=new r._28,h=function(){function t(e){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),e=e||{},this.vertices={near:[new r._105,new r._105,new r._105,new r._105],far:[new r._105,new r._105,new r._105,new r._105]},void 0!==e.projectionMatrix&&this.setFromProjectionMatrix(e.projectionMatrix,e.maxFar||1e4)}return s(t,[{key:"setFromProjectionMatrix",value:function(t,e){var i=0===t.elements[11];return o.copy(t).invert(),this.vertices.near[0].set(1,1,-1),this.vertices.near[1].set(1,-1,-1),this.vertices.near[2].set(-1,-1,-1),this.vertices.near[3].set(-1,1,-1),this.vertices.near.forEach(function(t){t.applyMatrix4(o)}),this.vertices.far[0].set(1,1,1),this.vertices.far[1].set(1,-1,1),this.vertices.far[2].set(-1,-1,1),this.vertices.far[3].set(-1,1,1),this.vertices.far.forEach(function(t){t.applyMatrix4(o);var a=Math.abs(t.z);i?t.z*=Math.min(e/a,1):t.multiplyScalar(Math.min(e/a,1))}),this.vertices}},{key:"split",value:function(e,i){for(;e.length>i.length;)i.push(new t);i.length=e.length;for(var a=0;a<e.length;a++){var n=i[a];if(0===a)for(var r=0;r<4;r++)n.vertices.near[r].copy(this.vertices.near[r]);else for(var s=0;s<4;s++)n.vertices.near[s].lerpVectors(this.vertices.near[s],this.vertices.far[s],e[a-1]);if(a===e-1)for(var o=0;o<4;o++)n.vertices.far[o].copy(this.vertices.far[o]);else for(var h=0;h<4;h++)n.vertices.far[h].lerpVectors(this.vertices.near[h],this.vertices.far[h],e[a])}}},{key:"toSpace",value:function(t,e){for(var i=0;i<4;i++)e.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(t),e.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(t)}}]),t}(),c={lights_fragment_begin:"\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef CLEARCOAT\n\n\tgeometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\n\tvec2 cascade;\n\tfloat cascadeCenter;\n\tfloat closestEdge;\n\tfloat margin;\n\tfloat csmx;\n\tfloat csmy;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n\t\t// NOTE: Depth gets larger away from the camera.\n\t\t// cascade.x is closer, cascade.y is further\n\t\tcascade = CSM_cascades[ i ];\n\t\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\n\t\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\n\t\tmargin = 0.25 * pow( closestEdge, 2.0 );\n\t\tcsmx = cascade.x - margin / 2.0;\n\t\tcsmy = cascade.y + margin / 2.0;\n\t\tif( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS && linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\n\n\t\t\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\n\t\t\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\n\t\t\tif( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS ) {\n\n\t\t\t\tvec3 prevColor = directLight.color;\n\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\n\t\t\t\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\n\n\t\t\t}\n\n\t\t\tReflectedLight prevLight = reflectedLight;\n\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t\t\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\n\t\t\tfloat blendRatio = shouldBlend ? ratio : 1.0;\n\n\t\t\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\n\t\t\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\n\t\t\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\n\t\t\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\n\n\t\t}\n\n\t}\n\t#pragma unroll_loop_end\n\t#else\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t#endif\n\n\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n",lights_pars_begin:"\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\nuniform vec2 CSM_cascades[CSM_CASCADES];\nuniform float cameraNear;\nuniform float shadowFar;\n#endif\n\t"+r._77.lights_pars_begin},d=function(){function t(t,e){for(var i=0;i<e.length;i++){var a=e[i];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(t,a.key,a)}}return function(e,i,a){return i&&t(e.prototype,i),a&&t(e,a),e}}();var l=new r._28,p=new h,m=new r._105,u=new r.i,g=[],f=[],_=function(){function t(e){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),e=e||{},this.camera=e.camera,this.parent=e.parent,this.cascades=e.cascades||3,this.maxFar=e.maxFar||1e5,this.mode=e.mode||"practical",this.shadowMapSize=e.shadowMapSize||2048,this.shadowBias=e.shadowBias||1e-6,this.lightDirection=e.lightDirection||new r._105(1,-1,1).normalize(),this.lightIntensity=e.lightIntensity||1,this.lightNear=e.lightNear||1,this.lightFar=e.lightFar||2e3,this.lightMargin=e.lightMargin||200,this.customSplitsCallback=e.customSplitsCallback,this.fade=!1,this.mainFrustum=new h,this.frustums=[],this.breaks=[],this.lights=[],this.shaders=new Map,this.createLights(),this.updateFrustums(),this.injectInclude()}return d(t,[{key:"createLights",value:function(){for(var t=0;t<this.cascades;t++){var e=new r.I(16777215,this.lightIntensity);e.castShadow=!0,e.shadow.mapSize.width=this.shadowMapSize,e.shadow.mapSize.height=this.shadowMapSize,e.shadow.camera.near=this.lightNear,e.shadow.camera.far=this.lightFar,e.shadow.bias=this.shadowBias,this.parent.add(e),this.parent.add(e.target),this.lights.push(e)}}},{key:"initCascades",value:function(){var t=this.camera;t.updateProjectionMatrix(),this.mainFrustum.setFromProjectionMatrix(t.projectionMatrix,this.maxFar),this.mainFrustum.split(this.breaks,this.frustums)}},{key:"updateShadowBounds",value:function(){for(var t=this.frustums,e=0;e<t.length;e++){var i=this.lights[e].shadow.camera,a=this.frustums[e],n=a.vertices.near,r=a.vertices.far,s=r[0],o=void 0;o=s.distanceTo(r[2])>s.distanceTo(n[2])?r[2]:n[2];var h=s.distanceTo(o);if(this.fade){var c=this.camera,d=Math.max(c.far,this.maxFar),l=a.vertices.far[0].z/(d-c.near);h+=.25*Math.pow(l,2)*(d-c.near)}i.left=-h/2,i.right=h/2,i.top=h/2,i.bottom=-h/2,i.updateProjectionMatrix()}}},{key:"getBreaks",value:function(){var t=this.camera,e=Math.min(t.far,this.maxFar);switch(this.breaks.length=0,this.mode){case"uniform":i(this.cascades,t.near,e,this.breaks);break;case"logarithmic":a(this.cascades,t.near,e,this.breaks);break;case"practical":!function(t,e,n,s,o){g.length=0,f.length=0,a(t,e,n,f),i(t,e,n,g);for(var h=1;h<t;h++)o.push(r._26.lerp(g[h-1],f[h-1],s));o.push(1)}(this.cascades,t.near,e,.5,this.breaks);break;case"custom":void 0===this.customSplitsCallback&&console.error("CSM: Custom split scheme callback not defined."),this.customSplitsCallback(this.cascades,t.near,e,this.breaks)}function i(t,e,i,a){for(var n=1;n<t;n++)a.push((e+(i-e)*n/t)/i);a.push(1)}function a(t,e,i,a){for(var n=1;n<t;n++)a.push(e*Math.pow(i/e,n/t)/i);a.push(1)}}},{key:"update",value:function(){for(var t=this.camera,e=this.frustums,i=0;i<e.length;i++){var a=this.lights[i],n=a.shadow.camera,r=(n.right-n.left)/this.shadowMapSize,s=(n.top-n.bottom)/this.shadowMapSize;a.shadow.camera.updateMatrixWorld(!0),l.multiplyMatrices(a.shadow.camera.matrixWorldInverse,t.matrixWorld),e[i].toSpace(l,p);var o=p.vertices.near,h=p.vertices.far;u.makeEmpty();for(var c=0;c<4;c++)u.expandByPoint(o[c]),u.expandByPoint(h[c]);u.getCenter(m),m.z=u.max.z+this.lightMargin,m.x=Math.floor(m.x/r)*r,m.y=Math.floor(m.y/s)*s,m.applyMatrix4(a.shadow.camera.matrixWorld),a.position.copy(m),a.target.position.copy(m),a.target.position.x+=this.lightDirection.x,a.target.position.y+=this.lightDirection.y,a.target.position.z+=this.lightDirection.z}}},{key:"injectInclude",value:function(){r._77.lights_fragment_begin=c.lights_fragment_begin,r._77.lights_pars_begin=c.lights_pars_begin}},{key:"setupMaterial",value:function(t){t.defines=t.defines||{},t.defines.USE_CSM=1,t.defines.CSM_CASCADES=this.cascades,this.fade&&(t.defines.CSM_FADE="");var e=[],i=this,a=this.shaders;t.onBeforeCompile=function(n){var r=Math.min(i.camera.far,i.maxFar);i.getExtendedBreaks(e),n.uniforms.CSM_cascades={value:e},n.uniforms.cameraNear={value:i.camera.near},n.uniforms.shadowFar={value:r},a.set(t,n)},a.set(t,null)}},{key:"updateUniforms",value:function(){var t=Math.min(this.camera.far,this.maxFar);this.shaders.forEach(function(e,i){if(null!==e){var a=e.uniforms;this.getExtendedBreaks(a.CSM_cascades.value),a.cameraNear.value=this.camera.near,a.shadowFar.value=t}!this.fade&&"CSM_FADE"in i.defines?(delete i.defines.CSM_FADE,i.needsUpdate=!0):!this.fade||"CSM_FADE"in i.defines||(i.defines.CSM_FADE="",i.needsUpdate=!0)},this)}},{key:"getExtendedBreaks",value:function(t){for(;t.length<this.breaks.length;)t.push(new r._104);t.length=this.breaks.length;for(var e=0;e<this.cascades;e++){var i=this.breaks[e],a=this.breaks[e-1]||0;t[e].x=a,t[e].y=i}}},{key:"updateFrustums",value:function(){this.getBreaks(),this.initCascades(),this.updateShadowBounds(),this.updateUniforms()}},{key:"remove",value:function(){for(var t=0;t<this.lights.length;t++)this.parent.remove(this.lights[t])}},{key:"dispose",value:function(){var t=this.shaders;t.forEach(function(t,e){delete e.onBeforeCompile,delete e.defines.USE_CSM,delete e.defines.CSM_CASCADES,delete e.defines.CSM_FADE,null!==t&&(delete t.uniforms.CSM_cascades,delete t.uniforms.cameraNear,delete t.uniforms.shadowFar),e.needsUpdate=!0}),t.clear()}}]),t}(),S=function(){function t(t,e){for(var i=0;i<e.length;i++){var a=e[i];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(t,a.key,a)}}return function(e,i,a){return i&&t(e.prototype,i),a&&t(e,a),e}}();var w=function(t){function e(t){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e);var i=function(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));i.csm=t,i.displayFrustum=!0,i.displayPlanes=!0,i.displayShadowBounds=!0;var a=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),n=new Float32Array(24),s=new r.m;s.setIndex(new r.l(a,1)),s.setAttribute("position",new r.l(n,3,!1));var o=new r._16(s,new r._14);return i.add(o),i.frustumLines=o,i.cascadeLines=[],i.cascadePlanes=[],i.shadowLines=[],i}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}(e,r["Y"]),S(e,[{key:"updateVisibility",value:function(){for(var t=this.displayFrustum,e=this.displayPlanes,i=this.displayShadowBounds,a=this.frustumLines,n=this.cascadeLines,r=this.cascadePlanes,s=this.shadowLines,o=0,h=n.length;o<h;o++){var c=n[o],d=r[o],l=s[o];c.visible=t,d.visible=t&&e,l.visible=i}a.visible=t}},{key:"update",value:function(){var t=this.csm,e=t.camera,i=t.cascades,a=t.mainFrustum,n=t.frustums,s=t.lights,o=this.frustumLines.geometry.getAttribute("position"),h=this.cascadeLines,c=this.cascadePlanes,d=this.shadowLines;for(this.position.copy(e.position),this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.updateMatrixWorld(!0);h.length>i;)this.remove(h.pop()),this.remove(c.pop()),this.remove(d.pop());for(;h.length<i;){var l=new r.j(new r.i,16777215),p=new r._30({transparent:!0,opacity:.1,depthWrite:!1,side:r.J}),m=new r._29(new r._53,p),u=new r.Y,g=new r.j(new r.i,16776960);u.add(g),this.add(l),this.add(m),this.add(u),h.push(l),c.push(m),d.push(u)}for(var f=0;f<i;f++){var _=n[f],S=s[f].shadow.camera,w=_.vertices.far,v=h[f],L=c[f],y=d[f],M=y.children[0];v.box.min.copy(w[2]),v.box.max.copy(w[0]),v.box.max.z+=1e-4,L.position.addVectors(w[0],w[2]),L.position.multiplyScalar(.5),L.scale.subVectors(w[0],w[2]),L.scale.z=1e-4,this.remove(y),y.position.copy(S.position),y.quaternion.copy(S.quaternion),y.scale.copy(S.scale),y.updateMatrixWorld(!0),this.attach(y),M.box.min.set(S.bottom,S.left,-S.far),M.box.max.set(S.top,S.right,-S.near)}var E=a.vertices.near,D=a.vertices.far;o.setXYZ(0,D[0].x,D[0].y,D[0].z),o.setXYZ(1,D[3].x,D[3].y,D[3].z),o.setXYZ(2,D[2].x,D[2].y,D[2].z),o.setXYZ(3,D[1].x,D[1].y,D[1].z),o.setXYZ(4,E[0].x,E[0].y,E[0].z),o.setXYZ(5,E[3].x,E[3].y,E[3].z),o.setXYZ(6,E[2].x,E[2].y,E[2].z),o.setXYZ(7,E[1].x,E[1].y,E[1].z),o.needsUpdate=!0}}]),e}(),v={data:function(){return{renderer:null,scene:null,camera:null,orthoCamera:null,controls:null,csm:null,csmHelper:null,params:null,gui:null}},mounted:function(){var t=this;this.params={orthographic:!1,fade:!1,far:1e3,mode:"practical",lightX:-1,lightY:-1,lightZ:-1,margin:100,lightFar:5e3,lightNear:1,autoUpdateHelper:!0,updateHelper:function(){t.csmHelper.update()}},this.init(),this.animate()},beforeDestroy:function(){this.gui.destroy()},methods:{updateOrthoCamera:function(){var t=this.controls.target.distanceTo(this.camera.position),e=this.camera.aspect;this.orthoCamera.left=t*e/-2,this.orthoCamera.right=t*e/2,this.orthoCamera.top=t/2,this.orthoCamera.bottom=t/-2,this.orthoCamera.position.copy(this.camera.position),this.orthoCamera.rotation.copy(this.camera.rotation),this.orthoCamera.updateProjectionMatrix()},init:function(){var t=this;this.scene=new this.$THREE.Scene,this.scene.background=new this.$THREE.Color("#454e61"),this.camera=new this.$THREE.PerspectiveCamera(70,this.$webglInnerWidth/window.innerHeight,.1,5e3),this.orthoCamera=new this.$THREE.OrthographicCamera,this.renderer=new this.$THREE.WebGLRenderer({antialias:!0}),this.renderer.setSize(this.$webglInnerWidth,window.innerHeight),document.getElementsByClassName("webglShadowmapCsm-container")[0].appendChild(this.renderer.domElement),this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=this.$THREE.PCFSoftShadowMap,this.controls=new a.a(this.camera,this.renderer.domElement),this.controls.maxPolarAngle=Math.PI/2,this.camera.position.set(60,60,0),this.controls.target=new this.$THREE.Vector3(-100,10,0),this.controls.update();var e=new this.$THREE.AmbientLight(16777215,.5);this.scene.add(e),this.csm=new _({maxFar:this.params.far,cascades:4,mode:this.params.mode,parent:this.scene,shadowMapSize:1024,lightDirection:new this.$THREE.Vector3(this.params.lightX,this.params.lightY,this.params.lightZ).normalize(),camera:this.camera}),this.csmHelper=new w(this.csm),this.csmHelper.visible=!1,this.scene.add(this.csmHelper);var i=new this.$THREE.MeshPhongMaterial({color:"#252a34"});this.csm.setupMaterial(i);var r=new this.$THREE.Mesh(new this.$THREE.PlaneBufferGeometry(1e4,1e4,8,8),i);r.rotation.x=-Math.PI/2,r.castShadow=!0,r.receiveShadow=!0,this.scene.add(r);var s=new this.$THREE.MeshPhongMaterial({color:"#08d9d6"});this.csm.setupMaterial(s);var o=new this.$THREE.MeshPhongMaterial({color:"#ff2e63"});this.csm.setupMaterial(o);for(var h=new this.$THREE.BoxBufferGeometry(10,10,10),c=0;c<40;c++){var d=new this.$THREE.Mesh(h,c%2==0?s:o);d.castShadow=!0,d.receiveShadow=!0,this.scene.add(d),d.position.set(25*-c,20,30),d.scale.y=2*Math.random()+6;var l=new this.$THREE.Mesh(h,c%2==0?o:s);l.castShadow=!0,l.receiveShadow=!0,this.scene.add(l),l.position.set(25*-c,20,-30),l.scale.y=2*Math.random()+6}this.gui=new n.a,this.gui.add(this.params,"orthographic").onChange(function(e){t.csm.camera=e?t.orthoCamera:t.camera,t.csm.updateFrustums()}),this.gui.add(this.params,"fade").onChange(function(e){t.csm.fade=e,t.csm.updateFrustums()}),this.gui.add(this.params,"far",1,5e3).step(1).name("shadow far").onChange(function(e){t.csm.maxFar=e,t.csm.updateFrustums()}),this.gui.add(this.params,"mode",["uniform","logarithmic","practical"]).name("frustum split mode").onChange(function(e){t.csm.mode=e,t.csm.updateFrustums()}),this.gui.add(this.params,"lightX",-1,1).name("light direction x").onChange(function(e){t.csm.lightDirection.x=e}),this.gui.add(this.params,"lightY",-1,1).name("light direction y").onChange(function(e){t.csm.lightDirection.y=e}),this.gui.add(this.params,"lightZ",-1,1).name("light direction z").onChange(function(e){t.csm.lightDirection.z=e}),this.gui.add(this.params,"margin",0,200).name("light margin").onChange(function(e){t.csm.lightMargin=e}),this.gui.add(this.params,"lightNear",1,1e4).name("light near").onChange(function(e){for(var i=0;i<t.csm.lights.length;i++)t.csm.lights[i].shadow.camera.near=e,t.csm.lights[i].shadow.camera.updateProjectionMatrix()}),this.gui.add(this.params,"lightFar",1,1e4).name("light far").onChange(function(e){for(var i=0;i<t.csm.lights.length;i++)t.csm.lights[i].shadow.camera.far=e,t.csm.lights[i].shadow.camera.updateProjectionMatrix()});var p=this.gui.addFolder("helper");p.add(this.csmHelper,"visible"),p.add(this.csmHelper,"displayFrustum").onChange(function(){t.csmHelper.updateVisibility()}),p.add(this.csmHelper,"displayPlanes").onChange(function(){t.csmHelper.updateVisibility()}),p.add(this.csmHelper,"displayShadowBounds").onChange(function(){t.csmHelper.updateVisibility()}),p.add(this.params,"autoUpdateHelper").name("auto update"),p.add(this.params,"updateHelper").name("update"),p.open(),window.addEventListener("resize",function(){t.$onWindowResize(t.camera,t.renderer),t.updateOrthoCamera(),t.csm.updateFrustums()},!1)},animate:function(){requestAnimationFrame(this.animate),this.camera.updateMatrixWorld(),this.csm.update(),this.controls.update(),this.params.orthographic?(this.updateOrthoCamera(),this.csm.updateFrustums(),this.params.autoUpdateHelper&&this.csmHelper.update(),this.renderer.render(this.scene,this.orthoCamera)):(this.params.autoUpdateHelper&&this.csmHelper.update(),this.renderer.render(this.scene,this.camera))}}},L={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("div",{staticClass:"webglShadowmapCsm-container"},[i("div",{attrs:{id:"container"}}),t._v(" "),i("div",{attrs:{id:"info"}},[i("a",{attrs:{href:"https://threejs.org",target:"_blank",rel:"noopener"}},[t._v("three.js")]),t._v(" webgl - cascaded shadow maps"),i("br"),t._v("\n\t\t\tby "),i("a",{attrs:{href:"https://github.com/vHawk",target:"_blank",rel:"noopener"}},[t._v("vHawk")]),t._v(" ("),i("a",{attrs:{href:"https://github.com/vHawk/three-csm",target:"_blank",rel:"noopener"}},[t._v("original repository")]),t._v(")\n\t\t")])])}]};var y=i("VU/8")(v,L,!1,function(t){i("ZpcC")},"data-v-17e65390",null);e.default=y.exports},ZpcC:function(t,e){}});
//# sourceMappingURL=191.e80877b2dd0717b79c93.js.map