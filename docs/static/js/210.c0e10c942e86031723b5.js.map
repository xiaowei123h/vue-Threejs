{"version":3,"sources":["webpack:///./src/components/jsm/csm/Frustum.js","webpack:///./src/components/jsm/csm/Shader.js","webpack:///./src/components/jsm/csm/CSM.js","webpack:///./src/components/jsm/csm/CSMHelper.js","webpack:///src/views/shadowmap/webglShadowmapCsm.vue","webpack:///./src/views/shadowmap/webglShadowmapCsm.vue?a7d7","webpack:///./src/views/shadowmap/webglShadowmapCsm.vue"],"names":["inverseProjectionMatrix","Matrix4","Frustum","data","_classCallCheck","this","vertices","near","Vector3","far","undefined","projectionMatrix","setFromProjectionMatrix","maxFar","isOrthographic","elements","copy","invert","set","forEach","v","applyMatrix4","absZ","Math","abs","z","min","multiplyScalar","breaks","target","length","push","i","cascade","j","lerpVectors","cameraMatrix","Shader","lights_fragment_begin","lights_pars_begin","ShaderChunk","_cameraToLightMatrix","_lightSpaceFrustum","_center","_bbox","Box3","_uniformArray","_logArray","CSM","CSM__classCallCheck","camera","parent","cascades","mode","shadowMapSize","shadowBias","lightDirection","normalize","lightIntensity","lightNear","lightFar","lightMargin","customSplitsCallback","fade","mainFrustum","frustums","lights","shaders","Map","createLights","updateFrustums","injectInclude","CSM__createClass","key","value","light","DirectionalLight","castShadow","shadow","mapSize","width","height","bias","add","updateProjectionMatrix","split","shadowCam","frustum","nearVerts","farVerts","point1","point2","distanceTo","squaredBBWidth","max","linearDepth","pow","left","right","top","bottom","uniformSplit","logarithmicSplit","amount","lambda","MathUtils","lerp","practicalSplit","console","error","texelWidth","texelHeight","updateMatrixWorld","multiplyMatrices","matrixWorldInverse","matrixWorld","toSpace","makeEmpty","expandByPoint","getCenter","x","floor","y","position","material","defines","USE_CSM","CSM_CASCADES","CSM_FADE","breaksVec2","scope","onBeforeCompile","shader","getExtendedBreaks","uniforms","CSM_cascades","cameraNear","shadowFar","needsUpdate","Vector2","prev","getBreaks","initCascades","updateShadowBounds","updateUniforms","remove","clear","CSMHelper","csm","CSMHelper__classCallCheck","_this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","call","displayFrustum","displayPlanes","displayShadowBounds","indices","Uint16Array","positions","Float32Array","frustumGeometry","BufferGeometry","setIndex","BufferAttribute","setAttribute","frustumLines","LineSegments","LineBasicMaterial","cascadeLines","cascadePlanes","shadowLines","Group","l","cascadeLine","cascadePlane","shadowLineGroup","visible","frustumLinePositions","geometry","getAttribute","quaternion","scale","pop","Box3Helper","planeMat","MeshBasicMaterial","transparent","opacity","depthWrite","side","DoubleSide","Mesh","PlaneBufferGeometry","shadowLine","children","box","addVectors","subVectors","attach","setXYZ","webglShadowmapCsm","renderer","scene","orthoCamera","controls","csmHelper","params","gui","mounted","orthographic","lightX","lightY","lightZ","margin","autoUpdateHelper","updateHelper","update","init","animate","beforeDestroy","destroy","methods","updateOrthoCamera","size","aspect","rotation","_this2","$THREE","Scene","background","Color","PerspectiveCamera","$webglInnerWidth","window","innerHeight","OrthographicCamera","WebGLRenderer","antialias","setSize","document","getElementsByClassName","appendChild","domElement","shadowMap","enabled","type","PCFSoftShadowMap","OrbitControls","maxPolarAngle","PI","ambientLight","AmbientLight","CSM_CSM","CSMHelper_CSMHelper","floorMaterial","MeshPhongMaterial","color","setupMaterial","receiveShadow","material1","material2","BoxBufferGeometry","cube1","random","cube2","dat_gui_module","onChange","step","name","helperFolder","addFolder","updateVisibility","open","addEventListener","$onWindowResize","requestAnimationFrame","render","shadowmap_webglShadowmapCsm","$createElement","_self","_c","_m","staticRenderFns","_vm","_h","staticClass","attrs","id","_v","href","rel","Component","__webpack_require__","normalizeComponent","ssrContext","__webpack_exports__"],"mappings":"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","file":"static/js/210.c0e10c942e86031723b5.js","sourcesContent":["import { Vector3, Matrix4 } from '@/components/build/three.module.js';\r\n\r\nconst inverseProjectionMatrix = new Matrix4();\r\n\r\nexport default class Frustum {\r\n\r\n\tconstructor( data ) {\r\n\r\n\t\tdata = data || {};\r\n\r\n\t\tthis.vertices = {\r\n\t\t\tnear: [\r\n\t\t\t\tnew Vector3(),\r\n\t\t\t\tnew Vector3(),\r\n\t\t\t\tnew Vector3(),\r\n\t\t\t\tnew Vector3()\r\n\t\t\t],\r\n\t\t\tfar: [\r\n\t\t\t\tnew Vector3(),\r\n\t\t\t\tnew Vector3(),\r\n\t\t\t\tnew Vector3(),\r\n\t\t\t\tnew Vector3()\r\n\t\t\t]\r\n\t\t};\r\n\r\n\t\tif ( data.projectionMatrix !== undefined ) {\r\n\r\n\t\t\tthis.setFromProjectionMatrix( data.projectionMatrix, data.maxFar || 10000 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsetFromProjectionMatrix( projectionMatrix, maxFar ) {\r\n\r\n\t\tconst isOrthographic = projectionMatrix.elements[ 2 * 4 + 3 ] === 0;\r\n\r\n\t\tinverseProjectionMatrix.copy( projectionMatrix ).invert();\r\n\r\n\t\t// 3 --- 0  vertices.near/far order\r\n\t\t// |     |\r\n\t\t// 2 --- 1\r\n\t\t// clip space spans from [-1, 1]\r\n\r\n\t\tthis.vertices.near[ 0 ].set( 1, 1, - 1 );\r\n\t\tthis.vertices.near[ 1 ].set( 1, - 1, - 1 );\r\n\t\tthis.vertices.near[ 2 ].set( - 1, - 1, - 1 );\r\n\t\tthis.vertices.near[ 3 ].set( - 1, 1, - 1 );\r\n\t\tthis.vertices.near.forEach( function ( v ) {\r\n\r\n\t\t\tv.applyMatrix4( inverseProjectionMatrix );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.vertices.far[ 0 ].set( 1, 1, 1 );\r\n\t\tthis.vertices.far[ 1 ].set( 1, - 1, 1 );\r\n\t\tthis.vertices.far[ 2 ].set( - 1, - 1, 1 );\r\n\t\tthis.vertices.far[ 3 ].set( - 1, 1, 1 );\r\n\t\tthis.vertices.far.forEach( function ( v ) {\r\n\r\n\t\t\tv.applyMatrix4( inverseProjectionMatrix );\r\n\r\n\t\t\tconst absZ = Math.abs( v.z );\r\n\t\t\tif ( isOrthographic ) {\r\n\r\n\t\t\t\tv.z *= Math.min( maxFar / absZ, 1.0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tv.multiplyScalar( Math.min( maxFar / absZ, 1.0 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn this.vertices;\r\n\r\n\t}\r\n\r\n\tsplit( breaks, target ) {\r\n\r\n\t\twhile ( breaks.length > target.length ) {\r\n\r\n\t\t\ttarget.push( new Frustum() );\r\n\r\n\t\t}\r\n\r\n\t\ttarget.length = breaks.length;\r\n\r\n\t\tfor ( let i = 0; i < breaks.length; i ++ ) {\r\n\r\n\t\t\tconst cascade = target[ i ];\r\n\r\n\t\t\tif ( i === 0 ) {\r\n\r\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\tcascade.vertices.near[ j ].copy( this.vertices.near[ j ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\tcascade.vertices.near[ j ].lerpVectors( this.vertices.near[ j ], this.vertices.far[ j ], breaks[ i - 1 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( i === breaks - 1 ) {\r\n\r\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\tcascade.vertices.far[ j ].copy( this.vertices.far[ j ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\tcascade.vertices.far[ j ].lerpVectors( this.vertices.near[ j ], this.vertices.far[ j ], breaks[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttoSpace( cameraMatrix, target ) {\r\n\r\n\t\tfor ( var i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\ttarget.vertices.near[ i ]\r\n\t\t\t\t.copy( this.vertices.near[ i ] )\r\n\t\t\t\t.applyMatrix4( cameraMatrix );\r\n\r\n\t\t\ttarget.vertices.far[ i ]\r\n\t\t\t\t.copy( this.vertices.far[ i ] )\r\n\t\t\t\t.applyMatrix4( cameraMatrix );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/jsm/csm/Frustum.js","import { ShaderChunk } from '@/components/build/three.module.js';\r\n\r\nexport default {\r\n\tlights_fragment_begin: /* glsl */`\r\nGeometricContext geometry;\r\n\r\ngeometry.position = - vViewPosition;\r\ngeometry.normal = normal;\r\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\r\n\r\n#ifdef CLEARCOAT\r\n\r\n\tgeometry.clearcoatNormal = clearcoatNormal;\r\n\r\n#endif\r\n\r\nIncidentLight directLight;\r\n\r\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n\tPointLight pointLight;\r\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\r\n\tPointLightShadow pointLightShadow;\r\n\t#endif\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\r\n\t\tpointLight = pointLights[ i ];\r\n\r\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\r\n\r\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\r\n\t\tpointLightShadow = pointLightShadows[ i ];\r\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n#endif\r\n\r\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n\tSpotLight spotLight;\r\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\r\n\tSpotLightShadow spotLightShadow;\r\n\t#endif\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n\r\n\t\tspotLight = spotLights[ i ];\r\n\r\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\r\n\r\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\r\n\t\tspotLightShadow = spotLightShadows[ i ];\r\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n#endif\r\n\r\n#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\r\n\r\n\tDirectionalLight directionalLight;\r\n\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\r\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\r\n\tDirectionalLightShadow directionalLightShadow;\r\n\t#endif\r\n\r\n\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\r\n\tvec2 cascade;\r\n\tfloat cascadeCenter;\r\n\tfloat closestEdge;\r\n\tfloat margin;\r\n\tfloat csmx;\r\n\tfloat csmy;\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tdirectionalLight = directionalLights[ i ];\r\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\r\n\r\n\t\t// NOTE: Depth gets larger away from the camera.\r\n\t\t// cascade.x is closer, cascade.y is further\r\n\t\tcascade = CSM_cascades[ i ];\r\n\t\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\r\n\t\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\r\n\t\tmargin = 0.25 * pow( closestEdge, 2.0 );\r\n\t\tcsmx = cascade.x - margin / 2.0;\r\n\t\tcsmy = cascade.y + margin / 2.0;\r\n\t\tif( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS && linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\r\n\r\n\t\t\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\r\n\t\t\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\r\n\t\t\tif( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS ) {\r\n\r\n\t\t\t\tvec3 prevColor = directLight.color;\r\n\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\r\n\t\t\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n\r\n\t\t\t\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\r\n\t\t\t\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tReflectedLight prevLight = reflectedLight;\r\n\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t\t\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\r\n\t\t\tfloat blendRatio = shouldBlend ? ratio : 1.0;\r\n\r\n\t\t\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\r\n\t\t\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\r\n\t\t\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\r\n\t\t\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\t#else\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tdirectionalLight = directionalLights[ i ];\r\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\r\n\r\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\r\n\r\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\r\n\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n\r\n\t\t#endif\r\n\r\n\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n\t#endif\r\n\r\n#endif\r\n\r\n\r\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\r\n\r\n\tDirectionalLight directionalLight;\r\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\r\n\tDirectionalLightShadow directionalLightShadow;\r\n\t#endif\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tdirectionalLight = directionalLights[ i ];\r\n\r\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\r\n\r\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\r\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\r\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n#endif\r\n\r\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\r\n\r\n\tRectAreaLight rectAreaLight;\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\r\n\r\n\t\trectAreaLight = rectAreaLights[ i ];\r\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n#endif\r\n\r\n#if defined( RE_IndirectDiffuse )\r\n\r\n\tvec3 iblIrradiance = vec3( 0.0 );\r\n\r\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\r\n\r\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\r\n\r\n\t#if ( NUM_HEMI_LIGHTS > 0 )\r\n\r\n\t\t#pragma unroll_loop_start\r\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\r\n\r\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\r\n\r\n\t\t}\r\n\t\t#pragma unroll_loop_end\r\n\r\n\t#endif\r\n\r\n#endif\r\n\r\n#if defined( RE_IndirectSpecular )\r\n\r\n\tvec3 radiance = vec3( 0.0 );\r\n\tvec3 clearcoatRadiance = vec3( 0.0 );\r\n\r\n#endif\r\n`,\r\n\tlights_pars_begin: /* glsl */`\r\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\r\nuniform vec2 CSM_cascades[CSM_CASCADES];\r\nuniform float cameraNear;\r\nuniform float shadowFar;\r\n#endif\r\n\t` + ShaderChunk.lights_pars_begin\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/jsm/csm/Shader.js","import {\r\n\tVector2,\r\n\tVector3,\r\n\tDirectionalLight,\r\n\tMathUtils,\r\n\tShaderChunk,\r\n\tMatrix4,\r\n\tBox3\r\n} from '@/components/build/three.module.js';\r\nimport Frustum from './Frustum.js';\r\nimport Shader from './Shader.js';\r\n\r\nconst _cameraToLightMatrix = new Matrix4();\r\nconst _lightSpaceFrustum = new Frustum();\r\nconst _center = new Vector3();\r\nconst _bbox = new Box3();\r\nconst _uniformArray = [];\r\nconst _logArray = [];\r\n\r\nexport class CSM {\r\n\r\n\tconstructor( data ) {\r\n\r\n\t\tdata = data || {};\r\n\r\n\t\tthis.camera = data.camera;\r\n\t\tthis.parent = data.parent;\r\n\t\tthis.cascades = data.cascades || 3;\r\n\t\tthis.maxFar = data.maxFar || 100000;\r\n\t\tthis.mode = data.mode || 'practical';\r\n\t\tthis.shadowMapSize = data.shadowMapSize || 2048;\r\n\t\tthis.shadowBias = data.shadowBias || 0.000001;\r\n\t\tthis.lightDirection = data.lightDirection || new Vector3( 1, - 1, 1 ).normalize();\r\n\t\tthis.lightIntensity = data.lightIntensity || 1;\r\n\t\tthis.lightNear = data.lightNear || 1;\r\n\t\tthis.lightFar = data.lightFar || 2000;\r\n\t\tthis.lightMargin = data.lightMargin || 200;\r\n\t\tthis.customSplitsCallback = data.customSplitsCallback;\r\n\t\tthis.fade = false;\r\n\t\tthis.mainFrustum = new Frustum();\r\n\t\tthis.frustums = [];\r\n\t\tthis.breaks = [];\r\n\r\n\t\tthis.lights = [];\r\n\t\tthis.shaders = new Map();\r\n\r\n\t\tthis.createLights();\r\n\t\tthis.updateFrustums();\r\n\t\tthis.injectInclude();\r\n\r\n\t}\r\n\r\n\tcreateLights() {\r\n\r\n\t\tfor ( let i = 0; i < this.cascades; i ++ ) {\r\n\r\n\t\t\tconst light = new DirectionalLight( 0xffffff, this.lightIntensity );\r\n\t\t\tlight.castShadow = true;\r\n\t\t\tlight.shadow.mapSize.width = this.shadowMapSize;\r\n\t\t\tlight.shadow.mapSize.height = this.shadowMapSize;\r\n\r\n\t\t\tlight.shadow.camera.near = this.lightNear;\r\n\t\t\tlight.shadow.camera.far = this.lightFar;\r\n\t\t\tlight.shadow.bias = this.shadowBias;\r\n\r\n\t\t\tthis.parent.add( light );\r\n\t\t\tthis.parent.add( light.target );\r\n\t\t\tthis.lights.push( light );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tinitCascades() {\r\n\r\n\t\tconst camera = this.camera;\r\n\t\tcamera.updateProjectionMatrix();\r\n\t\tthis.mainFrustum.setFromProjectionMatrix( camera.projectionMatrix, this.maxFar );\r\n\t\tthis.mainFrustum.split( this.breaks, this.frustums );\r\n\r\n\t}\r\n\r\n\tupdateShadowBounds() {\r\n\r\n\t\tconst frustums = this.frustums;\r\n\t\tfor ( let i = 0; i < frustums.length; i ++ ) {\r\n\r\n\t\t\tconst light = this.lights[ i ];\r\n\t\t\tconst shadowCam = light.shadow.camera;\r\n\t\t\tconst frustum = this.frustums[ i ];\r\n\r\n\t\t\t// Get the two points that represent that furthest points on the frustum assuming\r\n\t\t\t// that's either the diagonal across the far plane or the diagonal across the whole\r\n\t\t\t// frustum itself.\r\n\t\t\tconst nearVerts = frustum.vertices.near;\r\n\t\t\tconst farVerts = frustum.vertices.far;\r\n\t\t\tconst point1 = farVerts[ 0 ];\r\n\t\t\tlet point2;\r\n\t\t\tif ( point1.distanceTo( farVerts[ 2 ] ) > point1.distanceTo( nearVerts[ 2 ] ) ) {\r\n\r\n\t\t\t\tpoint2 = farVerts[ 2 ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tpoint2 = nearVerts[ 2 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet squaredBBWidth = point1.distanceTo( point2 );\r\n\t\t\tif ( this.fade ) {\r\n\r\n\t\t\t\t// expand the shadow extents by the fade margin if fade is enabled.\r\n\t\t\t\tconst camera = this.camera;\r\n\t\t\t\tconst far = Math.max( camera.far, this.maxFar );\r\n\t\t\t\tconst linearDepth = frustum.vertices.far[ 0 ].z / ( far - camera.near );\r\n\t\t\t\tconst margin = 0.25 * Math.pow( linearDepth, 2.0 ) * ( far - camera.near );\r\n\r\n\t\t\t\tsquaredBBWidth += margin;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tshadowCam.left = - squaredBBWidth / 2;\r\n\t\t\tshadowCam.right = squaredBBWidth / 2;\r\n\t\t\tshadowCam.top = squaredBBWidth / 2;\r\n\t\t\tshadowCam.bottom = - squaredBBWidth / 2;\r\n\t\t\tshadowCam.updateProjectionMatrix();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetBreaks() {\r\n\r\n\t\tconst camera = this.camera;\r\n\t\tconst far = Math.min( camera.far, this.maxFar );\r\n\t\tthis.breaks.length = 0;\r\n\r\n\t\tswitch ( this.mode ) {\r\n\r\n\t\t\tcase 'uniform':\r\n\t\t\t\tuniformSplit( this.cascades, camera.near, far, this.breaks );\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'logarithmic':\r\n\t\t\t\tlogarithmicSplit( this.cascades, camera.near, far, this.breaks );\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'practical':\r\n\t\t\t\tpracticalSplit( this.cascades, camera.near, far, 0.5, this.breaks );\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'custom':\r\n\t\t\t\tif ( this.customSplitsCallback === undefined ) console.error( 'CSM: Custom split scheme callback not defined.' );\r\n\t\t\t\tthis.customSplitsCallback( this.cascades, camera.near, far, this.breaks );\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tfunction uniformSplit( amount, near, far, target ) {\r\n\r\n\t\t\tfor ( let i = 1; i < amount; i ++ ) {\r\n\r\n\t\t\t\ttarget.push( ( near + ( far - near ) * i / amount ) / far );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.push( 1 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction logarithmicSplit( amount, near, far, target ) {\r\n\r\n\t\t\tfor ( let i = 1; i < amount; i ++ ) {\r\n\r\n\t\t\t\ttarget.push( ( near * ( far / near ) ** ( i / amount ) ) / far );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.push( 1 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction practicalSplit( amount, near, far, lambda, target ) {\r\n\r\n\t\t\t_uniformArray.length = 0;\r\n\t\t\t_logArray.length = 0;\r\n\t\t\tlogarithmicSplit( amount, near, far, _logArray );\r\n\t\t\tuniformSplit( amount, near, far, _uniformArray );\r\n\r\n\t\t\tfor ( let i = 1; i < amount; i ++ ) {\r\n\r\n\t\t\t\ttarget.push( MathUtils.lerp( _uniformArray[ i - 1 ], _logArray[ i - 1 ], lambda ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.push( 1 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst camera = this.camera;\r\n\t\tconst frustums = this.frustums;\r\n\t\tfor ( let i = 0; i < frustums.length; i ++ ) {\r\n\r\n\t\t\tconst light = this.lights[ i ];\r\n\t\t\tconst shadowCam = light.shadow.camera;\r\n\t\t\tconst texelWidth = ( shadowCam.right - shadowCam.left ) / this.shadowMapSize;\r\n\t\t\tconst texelHeight = ( shadowCam.top - shadowCam.bottom ) / this.shadowMapSize;\r\n\t\t\tlight.shadow.camera.updateMatrixWorld( true );\r\n\t\t\t_cameraToLightMatrix.multiplyMatrices( light.shadow.camera.matrixWorldInverse, camera.matrixWorld );\r\n\t\t\tfrustums[ i ].toSpace( _cameraToLightMatrix, _lightSpaceFrustum );\r\n\r\n\t\t\tconst nearVerts = _lightSpaceFrustum.vertices.near;\r\n\t\t\tconst farVerts = _lightSpaceFrustum.vertices.far;\r\n\t\t\t_bbox.makeEmpty();\r\n\t\t\tfor ( let j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t_bbox.expandByPoint( nearVerts[ j ] );\r\n\t\t\t\t_bbox.expandByPoint( farVerts[ j ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_bbox.getCenter( _center );\r\n\t\t\t_center.z = _bbox.max.z + this.lightMargin;\r\n\t\t\t_center.x = Math.floor( _center.x / texelWidth ) * texelWidth;\r\n\t\t\t_center.y = Math.floor( _center.y / texelHeight ) * texelHeight;\r\n\t\t\t_center.applyMatrix4( light.shadow.camera.matrixWorld );\r\n\r\n\t\t\tlight.position.copy( _center );\r\n\t\t\tlight.target.position.copy( _center );\r\n\r\n\t\t\tlight.target.position.x += this.lightDirection.x;\r\n\t\t\tlight.target.position.y += this.lightDirection.y;\r\n\t\t\tlight.target.position.z += this.lightDirection.z;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tinjectInclude() {\r\n\r\n\t\tShaderChunk.lights_fragment_begin = Shader.lights_fragment_begin;\r\n\t\tShaderChunk.lights_pars_begin = Shader.lights_pars_begin;\r\n\r\n\t}\r\n\r\n\tsetupMaterial( material ) {\r\n\r\n\t\tmaterial.defines = material.defines || {};\r\n\t\tmaterial.defines.USE_CSM = 1;\r\n\t\tmaterial.defines.CSM_CASCADES = this.cascades;\r\n\r\n\t\tif ( this.fade ) {\r\n\r\n\t\t\tmaterial.defines.CSM_FADE = '';\r\n\r\n\t\t}\r\n\r\n\t\tconst breaksVec2 = [];\r\n\t\tconst scope = this;\r\n\t\tconst shaders = this.shaders;\r\n\r\n\t\tmaterial.onBeforeCompile = function ( shader ) {\r\n\r\n\t\t\tconst far = Math.min( scope.camera.far, scope.maxFar );\r\n\t\t\tscope.getExtendedBreaks( breaksVec2 );\r\n\r\n\t\t\tshader.uniforms.CSM_cascades = { value: breaksVec2 };\r\n\t\t\tshader.uniforms.cameraNear = { value: scope.camera.near };\r\n\t\t\tshader.uniforms.shadowFar = { value: far };\r\n\r\n\t\t\tshaders.set( material, shader );\r\n\r\n\t\t};\r\n\r\n\t\tshaders.set( material, null );\r\n\r\n\t}\r\n\r\n\tupdateUniforms() {\r\n\r\n\t\tconst far = Math.min( this.camera.far, this.maxFar );\r\n\t\tconst shaders = this.shaders;\r\n\r\n\t\tshaders.forEach( function ( shader, material ) {\r\n\r\n\t\t\tif ( shader !== null ) {\r\n\r\n\t\t\t\tconst uniforms = shader.uniforms;\r\n\t\t\t\tthis.getExtendedBreaks( uniforms.CSM_cascades.value );\r\n\t\t\t\tuniforms.cameraNear.value = this.camera.near;\r\n\t\t\t\tuniforms.shadowFar.value = far;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! this.fade && 'CSM_FADE' in material.defines ) {\r\n\r\n\t\t\t\tdelete material.defines.CSM_FADE;\r\n\t\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t\t} else if ( this.fade && ! ( 'CSM_FADE' in material.defines ) ) {\r\n\r\n\t\t\t\tmaterial.defines.CSM_FADE = '';\r\n\t\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}, this );\r\n\r\n\t}\r\n\r\n\tgetExtendedBreaks( target ) {\r\n\r\n\t\twhile ( target.length < this.breaks.length ) {\r\n\r\n\t\t\ttarget.push( new Vector2() );\r\n\r\n\t\t}\r\n\r\n\t\ttarget.length = this.breaks.length;\r\n\r\n\t\tfor ( let i = 0; i < this.cascades; i ++ ) {\r\n\r\n\t\t\tconst amount = this.breaks[ i ];\r\n\t\t\tconst prev = this.breaks[ i - 1 ] || 0;\r\n\t\t\ttarget[ i ].x = prev;\r\n\t\t\ttarget[ i ].y = amount;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateFrustums() {\r\n\r\n\t\tthis.getBreaks();\r\n\t\tthis.initCascades();\r\n\t\tthis.updateShadowBounds();\r\n\t\tthis.updateUniforms();\r\n\r\n\t}\r\n\r\n\tremove() {\r\n\r\n\t\tfor ( let i = 0; i < this.lights.length; i ++ ) {\r\n\r\n\t\t\tthis.parent.remove( this.lights[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tconst shaders = this.shaders;\r\n\t\tshaders.forEach( function ( shader, material ) {\r\n\r\n\t\t\tdelete material.onBeforeCompile;\r\n\t\t\tdelete material.defines.USE_CSM;\r\n\t\t\tdelete material.defines.CSM_CASCADES;\r\n\t\t\tdelete material.defines.CSM_FADE;\r\n\r\n\t\t\tif ( shader !== null ) {\r\n\r\n\t\t\t\tdelete shader.uniforms.CSM_cascades;\r\n\t\t\t\tdelete shader.uniforms.cameraNear;\r\n\t\t\t\tdelete shader.uniforms.shadowFar;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t} );\r\n\t\tshaders.clear();\r\n\r\n\t}\r\n\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/jsm/csm/CSM.js","import {\r\n\tGroup,\r\n\tMesh,\r\n\tLineSegments,\r\n\tBufferGeometry,\r\n\tLineBasicMaterial,\r\n\tBox3Helper,\r\n\tBox3,\r\n\tPlaneBufferGeometry,\r\n\tMeshBasicMaterial,\r\n\tBufferAttribute,\r\n\tDoubleSide\r\n} from '@/components/build/three.module.js';\r\n\r\nclass CSMHelper extends Group {\r\n\r\n\tconstructor( csm ) {\r\n\r\n\t\tsuper();\r\n\t\tthis.csm = csm;\r\n\t\tthis.displayFrustum = true;\r\n\t\tthis.displayPlanes = true;\r\n\t\tthis.displayShadowBounds = true;\r\n\r\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\r\n\t\tconst positions = new Float32Array( 24 );\r\n\t\tconst frustumGeometry = new BufferGeometry();\r\n\t\tfrustumGeometry.setIndex( new BufferAttribute( indices, 1 ) );\r\n\t\tfrustumGeometry.setAttribute( 'position', new BufferAttribute( positions, 3, false ) );\r\n\t\tconst frustumLines = new LineSegments( frustumGeometry, new LineBasicMaterial() );\r\n\t\tthis.add( frustumLines );\r\n\r\n\t\tthis.frustumLines = frustumLines;\r\n\t\tthis.cascadeLines = [];\r\n\t\tthis.cascadePlanes = [];\r\n\t\tthis.shadowLines = [];\r\n\r\n\t}\r\n\r\n\tupdateVisibility() {\r\n\r\n\t\tconst displayFrustum = this.displayFrustum;\r\n\t\tconst displayPlanes = this.displayPlanes;\r\n\t\tconst displayShadowBounds = this.displayShadowBounds;\r\n\r\n\t\tconst frustumLines = this.frustumLines;\r\n\t\tconst cascadeLines = this.cascadeLines;\r\n\t\tconst cascadePlanes = this.cascadePlanes;\r\n\t\tconst shadowLines = this.shadowLines;\r\n\t\tfor ( let i = 0, l = cascadeLines.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst cascadeLine = cascadeLines[ i ];\r\n\t\t\tconst cascadePlane = cascadePlanes[ i ];\r\n\t\t\tconst shadowLineGroup = shadowLines[ i ];\r\n\r\n\t\t\tcascadeLine.visible = displayFrustum;\r\n\t\t\tcascadePlane.visible = displayFrustum && displayPlanes;\r\n\t\t\tshadowLineGroup.visible = displayShadowBounds;\r\n\r\n\t\t}\r\n\r\n\t\tfrustumLines.visible = displayFrustum;\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst csm = this.csm;\r\n\t\tconst camera = csm.camera;\r\n\t\tconst cascades = csm.cascades;\r\n\t\tconst mainFrustum = csm.mainFrustum;\r\n\t\tconst frustums = csm.frustums;\r\n\t\tconst lights = csm.lights;\r\n\r\n\t\tconst frustumLines = this.frustumLines;\r\n\t\tconst frustumLinePositions = frustumLines.geometry.getAttribute( 'position' );\r\n\t\tconst cascadeLines = this.cascadeLines;\r\n\t\tconst cascadePlanes = this.cascadePlanes;\r\n\t\tconst shadowLines = this.shadowLines;\r\n\r\n\t\tthis.position.copy( camera.position );\r\n\t\tthis.quaternion.copy( camera.quaternion );\r\n\t\tthis.scale.copy( camera.scale );\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\twhile ( cascadeLines.length > cascades ) {\r\n\r\n\t\t\tthis.remove( cascadeLines.pop() );\r\n\t\t\tthis.remove( cascadePlanes.pop() );\r\n\t\t\tthis.remove( shadowLines.pop() );\r\n\r\n\t\t}\r\n\r\n\t\twhile ( cascadeLines.length < cascades ) {\r\n\r\n\t\t\tconst cascadeLine = new Box3Helper( new Box3(), 0xffffff );\r\n\t\t\tconst planeMat = new MeshBasicMaterial( { transparent: true, opacity: 0.1, depthWrite: false, side: DoubleSide } );\r\n\t\t\tconst cascadePlane = new Mesh( new PlaneBufferGeometry(), planeMat );\r\n\t\t\tconst shadowLineGroup = new Group();\r\n\t\t\tconst shadowLine = new Box3Helper( new Box3(), 0xffff00 );\r\n\t\t\tshadowLineGroup.add( shadowLine );\r\n\r\n\t\t\tthis.add( cascadeLine );\r\n\t\t\tthis.add( cascadePlane );\r\n\t\t\tthis.add( shadowLineGroup );\r\n\r\n\t\t\tcascadeLines.push( cascadeLine );\r\n\t\t\tcascadePlanes.push( cascadePlane );\r\n\t\t\tshadowLines.push( shadowLineGroup );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < cascades; i ++ ) {\r\n\r\n\t\t\tconst frustum = frustums[ i ];\r\n\t\t\tconst light = lights[ i ];\r\n\t\t\tconst shadowCam = light.shadow.camera;\r\n\t\t\tconst farVerts = frustum.vertices.far;\r\n\r\n\t\t\tconst cascadeLine = cascadeLines[ i ];\r\n\t\t\tconst cascadePlane = cascadePlanes[ i ];\r\n\t\t\tconst shadowLineGroup = shadowLines[ i ];\r\n\t\t\tconst shadowLine = shadowLineGroup.children[ 0 ];\r\n\r\n\t\t\tcascadeLine.box.min.copy( farVerts[ 2 ] );\r\n\t\t\tcascadeLine.box.max.copy( farVerts[ 0 ] );\r\n\t\t\tcascadeLine.box.max.z += 1e-4;\r\n\r\n\t\t\tcascadePlane.position.addVectors( farVerts[ 0 ], farVerts[ 2 ] );\r\n\t\t\tcascadePlane.position.multiplyScalar( 0.5 );\r\n\t\t\tcascadePlane.scale.subVectors( farVerts[ 0 ], farVerts[ 2 ] );\r\n\t\t\tcascadePlane.scale.z = 1e-4;\r\n\r\n\t\t\tthis.remove( shadowLineGroup );\r\n\t\t\tshadowLineGroup.position.copy( shadowCam.position );\r\n\t\t\tshadowLineGroup.quaternion.copy( shadowCam.quaternion );\r\n\t\t\tshadowLineGroup.scale.copy( shadowCam.scale );\r\n\t\t\tshadowLineGroup.updateMatrixWorld( true );\r\n\t\t\tthis.attach( shadowLineGroup );\r\n\r\n\t\t\tshadowLine.box.min.set( shadowCam.bottom, shadowCam.left, - shadowCam.far );\r\n\t\t\tshadowLine.box.max.set( shadowCam.top, shadowCam.right, - shadowCam.near );\r\n\r\n\t\t}\r\n\r\n\t\tconst nearVerts = mainFrustum.vertices.near;\r\n\t\tconst farVerts = mainFrustum.vertices.far;\r\n\t\tfrustumLinePositions.setXYZ( 0, farVerts[ 0 ].x, farVerts[ 0 ].y, farVerts[ 0 ].z );\r\n\t\tfrustumLinePositions.setXYZ( 1, farVerts[ 3 ].x, farVerts[ 3 ].y, farVerts[ 3 ].z );\r\n\t\tfrustumLinePositions.setXYZ( 2, farVerts[ 2 ].x, farVerts[ 2 ].y, farVerts[ 2 ].z );\r\n\t\tfrustumLinePositions.setXYZ( 3, farVerts[ 1 ].x, farVerts[ 1 ].y, farVerts[ 1 ].z );\r\n\r\n\t\tfrustumLinePositions.setXYZ( 4, nearVerts[ 0 ].x, nearVerts[ 0 ].y, nearVerts[ 0 ].z );\r\n\t\tfrustumLinePositions.setXYZ( 5, nearVerts[ 3 ].x, nearVerts[ 3 ].y, nearVerts[ 3 ].z );\r\n\t\tfrustumLinePositions.setXYZ( 6, nearVerts[ 2 ].x, nearVerts[ 2 ].y, nearVerts[ 2 ].z );\r\n\t\tfrustumLinePositions.setXYZ( 7, nearVerts[ 1 ].x, nearVerts[ 1 ].y, nearVerts[ 1 ].z );\r\n\t\tfrustumLinePositions.needsUpdate = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { CSMHelper };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/jsm/csm/CSMHelper.js","<template>\r\n    <div class=\"webglShadowmapCsm-container\">\r\n        <div id=\"container\"></div>\r\n\t\t<div id=\"info\">\r\n\t\t\t<a href=\"https://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a> webgl - cascaded shadow maps<br>\r\n\t\t\tby <a href=\"https://github.com/vHawk\" target=\"_blank\" rel=\"noopener\">vHawk</a> (<a href=\"https://github.com/vHawk/three-csm\" target=\"_blank\" rel=\"noopener\">original repository</a>)\r\n\t\t</div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport { OrbitControls } from '@/components/jsm/controls/OrbitControls.js'\r\nimport { GUI } from '@/components/jsm/libs/dat.gui.module.js'\r\nimport { CSM } from '@/components/jsm/csm/CSM.js'\r\nimport { CSMHelper } from '@/components/jsm/csm/CSMHelper.js'\r\nexport default {\r\n    data() {\r\n        return {\r\n            renderer: null,\r\n            scene: null,\r\n            camera: null,\r\n            orthoCamera: null,\r\n            controls: null,\r\n            csm: null,\r\n            csmHelper: null,\r\n            params: null,\r\n            gui: null,\r\n        }\r\n    },\r\n    mounted() {\r\n        this.params = {\r\n            orthographic: false,\r\n            fade: false,\r\n            far: 1000,\r\n            mode: 'practical',\r\n            lightX: - 1,\r\n            lightY: - 1,\r\n            lightZ: - 1,\r\n            margin: 100,\r\n            lightFar: 5000,\r\n            lightNear: 1,\r\n            autoUpdateHelper: true,\r\n            updateHelper: () => {\r\n                this.csmHelper.update()\r\n            }\r\n        }\r\n        this.init()\r\n        this.animate()\r\n    },\r\n    beforeDestroy() {\r\n        this.gui.destroy()\r\n    },\r\n    methods: {\r\n        updateOrthoCamera() {\r\n            var size = this.controls.target.distanceTo(this.camera.position)\r\n            var aspect = this.camera.aspect\r\n            this.orthoCamera.left = size * aspect / - 2\r\n            this.orthoCamera.right = size * aspect / 2\r\n            this.orthoCamera.top = size / 2\r\n            this.orthoCamera.bottom = size / - 2\r\n            this.orthoCamera.position.copy(this.camera.position)\r\n            this.orthoCamera.rotation.copy(this.camera.rotation)\r\n            this.orthoCamera.updateProjectionMatrix()\r\n        },\r\n        init() {\r\n            this.scene = new this.$THREE.Scene()\r\n            this.scene.background = new this.$THREE.Color('#454e61')\r\n            this.camera = new this.$THREE.PerspectiveCamera(70, this.$webglInnerWidth / window.innerHeight, 0.1, 5000)\r\n            this.orthoCamera = new this.$THREE.OrthographicCamera()\r\n            this.renderer = new this.$THREE.WebGLRenderer({ antialias: true })\r\n            this.renderer.setSize(this.$webglInnerWidth, window.innerHeight)\r\n            document.getElementsByClassName('webglShadowmapCsm-container')[0].appendChild(this.renderer.domElement)\r\n            this.renderer.shadowMap.enabled = true\r\n            this.renderer.shadowMap.type = this.$THREE.PCFSoftShadowMap\r\n            this.controls = new OrbitControls(this.camera, this.renderer.domElement)\r\n            this.controls.maxPolarAngle = Math.PI / 2\r\n            this.camera.position.set(60, 60, 0)\r\n            this.controls.target = new this.$THREE.Vector3(- 100, 10, 0)\r\n            this.controls.update()\r\n            var ambientLight = new this.$THREE.AmbientLight(0xffffff, 0.5)\r\n            this.scene.add(ambientLight)\r\n            this.csm = new CSM({\r\n                maxFar: this.params.far,\r\n                cascades: 4,\r\n                mode: this.params.mode,\r\n                parent: this.scene,\r\n                shadowMapSize: 1024,\r\n                lightDirection: new this.$THREE.Vector3(this.params.lightX, this.params.lightY, this.params.lightZ).normalize(),\r\n                camera: this.camera\r\n            })\r\n            this.csmHelper = new CSMHelper(this.csm)\r\n            this.csmHelper.visible = false\r\n            this.scene.add(this.csmHelper)\r\n            var floorMaterial = new this.$THREE.MeshPhongMaterial({ color: '#252a34' })\r\n            this.csm.setupMaterial(floorMaterial)\r\n            var floor = new this.$THREE.Mesh(new this.$THREE.PlaneBufferGeometry(10000, 10000, 8, 8), floorMaterial)\r\n            floor.rotation.x = - Math.PI / 2\r\n            floor.castShadow = true\r\n            floor.receiveShadow = true\r\n            this.scene.add(floor)\r\n            var material1 = new this.$THREE.MeshPhongMaterial({ color: '#08d9d6' })\r\n            this.csm.setupMaterial(material1)\r\n            var material2 = new this.$THREE.MeshPhongMaterial({ color: '#ff2e63' })\r\n            this.csm.setupMaterial(material2)\r\n            var geometry = new this.$THREE.BoxBufferGeometry(10, 10, 10)\r\n            for (var i = 0; i < 40; i ++) {\r\n                var cube1 = new this.$THREE.Mesh(geometry, i % 2 === 0 ? material1 : material2)\r\n                cube1.castShadow = true\r\n                cube1.receiveShadow = true\r\n                this.scene.add(cube1)\r\n                cube1.position.set(- i * 25, 20, 30)\r\n                cube1.scale.y = Math.random() * 2 + 6\r\n                var cube2 = new this.$THREE.Mesh(geometry, i % 2 === 0 ? material2 : material1)\r\n                cube2.castShadow = true\r\n                cube2.receiveShadow = true\r\n                this.scene.add(cube2)\r\n                cube2.position.set(- i * 25, 20, - 30)\r\n                cube2.scale.y = Math.random() * 2 + 6\r\n            }\r\n            this.gui = new GUI()\r\n            this.gui.add(this.params, 'orthographic').onChange((value) => {\r\n                this.csm.camera = value ? this.orthoCamera : this.camera\r\n                this.csm.updateFrustums()\r\n            })\r\n            this.gui.add(this.params, 'fade').onChange((value) => {\r\n                this.csm.fade = value\r\n                this.csm.updateFrustums()\r\n            })\r\n            this.gui.add(this.params, 'far', 1, 5000).step(1).name('shadow far').onChange((value) => {\r\n                this.csm.maxFar = value\r\n                this.csm.updateFrustums()\r\n            })\r\n            this.gui.add(this.params, 'mode', [ 'uniform', 'logarithmic', 'practical' ]).name('frustum split mode').onChange((value) => {\r\n                this.csm.mode = value\r\n                this.csm.updateFrustums()\r\n            })\r\n            this.gui.add(this.params, 'lightX', - 1, 1).name('light direction x').onChange((value) => {\r\n                this.csm.lightDirection.x = value\r\n            })\r\n            this.gui.add(this.params, 'lightY', - 1, 1).name('light direction y').onChange((value) => {\r\n                this.csm.lightDirection.y = value\r\n            })\r\n            this.gui.add(this.params, 'lightZ', - 1, 1).name('light direction z').onChange((value) => {\r\n                this.csm.lightDirection.z = value\r\n            })\r\n            this.gui.add(this.params, 'margin', 0, 200).name('light margin').onChange((value) => {\r\n                this.csm.lightMargin = value\r\n            })\r\n            this.gui.add(this.params, 'lightNear', 1, 10000).name('light near').onChange((value) => {\r\n                for (var i = 0; i < this.csm.lights.length; i ++) {\r\n                    this.csm.lights[ i ].shadow.camera.near = value\r\n                    this.csm.lights[ i ].shadow.camera.updateProjectionMatrix()\r\n                }\r\n            })\r\n            this.gui.add(this.params, 'lightFar', 1, 10000).name('light far').onChange((value) => {\r\n                for (var i = 0; i < this.csm.lights.length; i ++) {\r\n                    this.csm.lights[ i ].shadow.camera.far = value\r\n                    this.csm.lights[ i ].shadow.camera.updateProjectionMatrix()\r\n                }\r\n            })\r\n            var helperFolder = this.gui.addFolder('helper')\r\n            helperFolder.add(this.csmHelper, 'visible')\r\n            helperFolder.add(this.csmHelper, 'displayFrustum').onChange(() => {\r\n                this.csmHelper.updateVisibility()\r\n            })\r\n            helperFolder.add(this.csmHelper, 'displayPlanes').onChange(() => {\r\n                this.csmHelper.updateVisibility()\r\n            })\r\n            helperFolder.add(this.csmHelper, 'displayShadowBounds').onChange(() => {\r\n                this.csmHelper.updateVisibility()\r\n            })\r\n            helperFolder.add(this.params, 'autoUpdateHelper').name('auto update')\r\n            helperFolder.add(this.params, 'updateHelper').name('update')\r\n            helperFolder.open()\r\n            window.addEventListener('resize', () => {\r\n                this.$onWindowResize(this.camera, this.renderer)\r\n                this.updateOrthoCamera()\r\n                this.csm.updateFrustums()\r\n            }, false)\r\n        },\r\n        animate() {\r\n            requestAnimationFrame(this.animate)\r\n            this.camera.updateMatrixWorld()\r\n            this.csm.update()\r\n            this.controls.update()\r\n            if (this.params.orthographic) {\r\n                this.updateOrthoCamera()\r\n                this.csm.updateFrustums()\r\n                if (this.params.autoUpdateHelper) {\r\n                    this.csmHelper.update()\r\n                }\r\n                this.renderer.render(this.scene, this.orthoCamera)\r\n            } else {\r\n                if (this.params.autoUpdateHelper) {\r\n                    this.csmHelper.update()\r\n                }\r\n                this.renderer.render(this.scene, this.camera)\r\n            }\r\n        }\r\n    },\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n.webglShadowmapCsm-container {\r\n    width: 100%;\r\n}\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// src/views/shadowmap/webglShadowmapCsm.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"webglShadowmapCsm-container\"},[_c('div',{attrs:{\"id\":\"container\"}}),_vm._v(\" \"),_c('div',{attrs:{\"id\":\"info\"}},[_c('a',{attrs:{\"href\":\"https://threejs.org\",\"target\":\"_blank\",\"rel\":\"noopener\"}},[_vm._v(\"three.js\")]),_vm._v(\" webgl - cascaded shadow maps\"),_c('br'),_vm._v(\"\\n\\t\\t\\tby \"),_c('a',{attrs:{\"href\":\"https://github.com/vHawk\",\"target\":\"_blank\",\"rel\":\"noopener\"}},[_vm._v(\"vHawk\")]),_vm._v(\" (\"),_c('a',{attrs:{\"href\":\"https://github.com/vHawk/three-csm\",\"target\":\"_blank\",\"rel\":\"noopener\"}},[_vm._v(\"original repository\")]),_vm._v(\")\\n\\t\\t\")])])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-17e65390\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/views/shadowmap/webglShadowmapCsm.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true,\\\"publicPath\\\":\\\"../../\\\"}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-17e65390\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./webglShadowmapCsm.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./webglShadowmapCsm.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./webglShadowmapCsm.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-17e65390\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./webglShadowmapCsm.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-17e65390\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/shadowmap/webglShadowmapCsm.vue\n// module id = null\n// module chunks = "],"sourceRoot":""}