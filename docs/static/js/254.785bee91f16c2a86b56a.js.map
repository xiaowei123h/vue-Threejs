{"version":3,"sources":["webpack:///./src/components/jsm/utils/SkeletonUtils.js","webpack:///src/views/animation/webglAnimationMultiple.vue","webpack:///./src/views/animation/webglAnimationMultiple.vue?242b","webpack:///./src/views/animation/webglAnimationMultiple.vue"],"names":["targetParentPos","targetPos","sourceParentPos","sourcePos","targetDir","sourceDir","pos","quat","scale","bindBoneMatrix","relativeMatrix","globalMatrix","SkeletonUtils","Vector3","Quaternion","Matrix4","Vector2","source","sourceLookup","Map","cloneLookup","clone","parallelTraverse","a","b","callback","i","children","length","sourceNode","clonedNode","set","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","sourceBones","skeleton","bones","bindMatrix","copy","map","bone","bind","webglAnimationMultiple","data","worldScene","renderer","camera","clock","mixers","MODELS","name","UNITS","modelName","meshName","position","x","y","z","animationName","rotation","Math","PI","numLoadedModels","mounted","this","initScene","initRenderer","loadModels","animate","methods","$moduleTHREE","PerspectiveCamera","$webglInnerWidth","window","innerHeight","lookAt","Clock","Scene","background","Color","fog","Fog","hemiLight","HemisphereLight","add","dirLight","DirectionalLight","castShadow","shadow","top","bottom","left","right","near","far","groundMesh","Mesh","PlaneBufferGeometry","MeshPhongMaterial","color","depthWrite","receiveShadow","addEventListener","onWindowResize","$onWindowResize","container","document","getElementById","WebGLRenderer","antialias","setPixelRatio","devicePixelRatio","setSize","outputEncoding","sRGBEncoding","shadowMap","enabled","type","PCFSoftShadowMap","appendChild","domElement","_this","m","loadGltfModel","console","log","instantiateUnits","model","onLoaded","loader","GLTFLoader","load","gltf","scene","animations","object","isMesh","requestAnimationFrame","mixerUpdateDelta","getDelta","update","render","numSuccess","u","getModelByName","clonedScene","getObjectByName","mixer","startAnimation","push","error","skinnedMesh","AnimationMixer","clip","AnimationClip","findByName","clipAction","play","animation_webglAnimationMultiple","$createElement","_self","_c","_m","staticRenderFns","_h","staticClass","attrs","id","_v","href","target","rel","Component","__webpack_require__","normalizeComponent","ssrContext","__webpack_exports__"],"mappings":"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","file":"static/js/254.785bee91f16c2a86b56a.js","sourcesContent":["import {\r\n\tAnimationClip,\r\n\tAnimationMixer,\r\n\tEuler,\r\n\tMatrix4,\r\n\tQuaternion,\r\n\tQuaternionKeyframeTrack,\r\n\tSkeletonHelper,\r\n\tVector2,\r\n\tVector3,\r\n\tVectorKeyframeTrack\r\n} from \"@/components/build/three.module.js\";\r\n\r\nvar SkeletonUtils = {\r\n\r\n\tretarget: function () {\r\n\r\n\t\tvar pos = new Vector3(),\r\n\t\t\tquat = new Quaternion(),\r\n\t\t\tscale = new Vector3(),\r\n\t\t\tbindBoneMatrix = new Matrix4(),\r\n\t\t\trelativeMatrix = new Matrix4(),\r\n\t\t\tglobalMatrix = new Matrix4();\r\n\r\n\t\treturn function ( target, source, options ) {\r\n\r\n\t\t\toptions = options || {};\r\n\t\t\toptions.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\r\n\t\t\toptions.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\r\n\t\t\toptions.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\r\n\t\t\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\r\n\t\t\toptions.hip = options.hip !== undefined ? options.hip : \"hip\";\r\n\t\t\toptions.names = options.names || {};\r\n\r\n\t\t\tvar sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones( source ),\r\n\t\t\t\tbones = target.isObject3D ? target.skeleton.bones : this.getBones( target ),\r\n\t\t\t\tbindBones,\r\n\t\t\t\tbone, name, boneTo,\r\n\t\t\t\tbonesPosition, i;\r\n\r\n\t\t\t// reset bones\r\n\r\n\t\t\tif ( target.isObject3D ) {\r\n\r\n\t\t\t\ttarget.skeleton.pose();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\toptions.useTargetMatrix = true;\r\n\t\t\t\toptions.preserveMatrix = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( options.preservePosition ) {\r\n\r\n\t\t\t\tbonesPosition = [];\r\n\r\n\t\t\t\tfor ( i = 0; i < bones.length; i ++ ) {\r\n\r\n\t\t\t\t\tbonesPosition.push( bones[ i ].position.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( options.preserveMatrix ) {\r\n\r\n\t\t\t\t// reset matrix\r\n\r\n\t\t\t\ttarget.updateMatrixWorld();\r\n\r\n\t\t\t\ttarget.matrixWorld.identity();\r\n\r\n\t\t\t\t// reset children matrix\r\n\r\n\t\t\t\tfor ( i = 0; i < target.children.length; ++ i ) {\r\n\r\n\t\t\t\t\ttarget.children[ i ].updateMatrixWorld( true );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( options.offsets ) {\r\n\r\n\t\t\t\tbindBones = [];\r\n\r\n\t\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\r\n\r\n\t\t\t\t\tbone = bones[ i ];\r\n\t\t\t\t\tname = options.names[ bone.name ] || bone.name;\r\n\r\n\t\t\t\t\tif ( options.offsets && options.offsets[ name ] ) {\r\n\r\n\t\t\t\t\t\tbone.matrix.multiply( options.offsets[ name ] );\r\n\r\n\t\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n\t\t\t\t\t\tbone.updateMatrixWorld();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbindBones.push( bone.matrixWorld.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\r\n\r\n\t\t\t\tbone = bones[ i ];\r\n\t\t\t\tname = options.names[ bone.name ] || bone.name;\r\n\r\n\t\t\t\tboneTo = this.getBoneByName( name, sourceBones );\r\n\r\n\t\t\t\tglobalMatrix.copy( bone.matrixWorld );\r\n\r\n\t\t\t\tif ( boneTo ) {\r\n\r\n\t\t\t\t\tboneTo.updateMatrixWorld();\r\n\r\n\t\t\t\t\tif ( options.useTargetMatrix ) {\r\n\r\n\t\t\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\r\n\t\t\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// ignore scale to extract rotation\r\n\r\n\t\t\t\t\tscale.setFromMatrixScale( relativeMatrix );\r\n\t\t\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\r\n\r\n\t\t\t\t\t// apply to global matrix\r\n\r\n\t\t\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\r\n\r\n\t\t\t\t\tif ( target.isObject3D ) {\r\n\r\n\t\t\t\t\t\tvar boneIndex = bones.indexOf( bone ),\r\n\t\t\t\t\t\t\twBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.copy( target.skeleton.boneInverses[ boneIndex ] ).invert();\r\n\r\n\t\t\t\t\t\tglobalMatrix.multiply( wBindMatrix );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tglobalMatrix.copyPosition( relativeMatrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\r\n\r\n\t\t\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\r\n\t\t\t\t\tbone.matrix.multiply( globalMatrix );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tbone.matrix.copy( globalMatrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( options.preserveHipPosition && name === options.hip ) {\r\n\r\n\t\t\t\t\tbone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n\t\t\t\tbone.updateMatrixWorld();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( options.preservePosition ) {\r\n\r\n\t\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\r\n\r\n\t\t\t\t\tbone = bones[ i ];\r\n\t\t\t\t\tname = options.names[ bone.name ] || bone.name;\r\n\r\n\t\t\t\t\tif ( name !== options.hip ) {\r\n\r\n\t\t\t\t\t\tbone.position.copy( bonesPosition[ i ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( options.preserveMatrix ) {\r\n\r\n\t\t\t\t// restore matrix\r\n\r\n\t\t\t\ttarget.updateMatrixWorld( true );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tretargetClip: function ( target, source, clip, options ) {\r\n\r\n\t\toptions = options || {};\r\n\t\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\r\n\t\toptions.fps = options.fps !== undefined ? options.fps : 30;\r\n\t\toptions.names = options.names || [];\r\n\r\n\t\tif ( ! source.isObject3D ) {\r\n\r\n\t\t\tsource = this.getHelperFromSkeleton( source );\r\n\r\n\t\t}\r\n\r\n\t\tvar numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\r\n\t\t\tdelta = 1 / options.fps,\r\n\t\t\tconvertedTracks = [],\r\n\t\t\tmixer = new AnimationMixer( source ),\r\n\t\t\tbones = this.getBones( target.skeleton ),\r\n\t\t\tboneDatas = [],\r\n\t\t\tpositionOffset,\r\n\t\t\tbone, boneTo, boneData,\r\n\t\t\tname, i, j;\r\n\r\n\t\tmixer.clipAction( clip ).play();\r\n\t\tmixer.update( 0 );\r\n\r\n\t\tsource.updateMatrixWorld();\r\n\r\n\t\tfor ( i = 0; i < numFrames; ++ i ) {\r\n\r\n\t\t\tvar time = i * delta;\r\n\r\n\t\t\tthis.retarget( target, source, options );\r\n\r\n\t\t\tfor ( j = 0; j < bones.length; ++ j ) {\r\n\r\n\t\t\t\tname = options.names[ bones[ j ].name ] || bones[ j ].name;\r\n\r\n\t\t\t\tboneTo = this.getBoneByName( name, source.skeleton );\r\n\r\n\t\t\t\tif ( boneTo ) {\r\n\r\n\t\t\t\t\tbone = bones[ j ];\r\n\t\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\r\n\r\n\t\t\t\t\tif ( options.hip === name ) {\r\n\r\n\t\t\t\t\t\tif ( ! boneData.pos ) {\r\n\r\n\t\t\t\t\t\t\tboneData.pos = {\r\n\t\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\r\n\t\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 3 )\r\n\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( options.useFirstFramePosition ) {\r\n\r\n\t\t\t\t\t\t\tif ( i === 0 ) {\r\n\r\n\t\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbone.position.sub( positionOffset );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tboneData.pos.times[ i ] = time;\r\n\r\n\t\t\t\t\t\tbone.position.toArray( boneData.pos.values, i * 3 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( ! boneData.quat ) {\r\n\r\n\t\t\t\t\t\tboneData.quat = {\r\n\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\r\n\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 4 )\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tboneData.quat.times[ i ] = time;\r\n\r\n\t\t\t\t\tbone.quaternion.toArray( boneData.quat.values, i * 4 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmixer.update( delta );\r\n\r\n\t\t\tsource.updateMatrixWorld();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 0; i < boneDatas.length; ++ i ) {\r\n\r\n\t\t\tboneData = boneDatas[ i ];\r\n\r\n\t\t\tif ( boneData ) {\r\n\r\n\t\t\t\tif ( boneData.pos ) {\r\n\r\n\t\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\r\n\t\t\t\t\t\t\".bones[\" + boneData.bone.name + \"].position\",\r\n\t\t\t\t\t\tboneData.pos.times,\r\n\t\t\t\t\t\tboneData.pos.values\r\n\t\t\t\t\t) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\r\n\t\t\t\t\t\".bones[\" + boneData.bone.name + \"].quaternion\",\r\n\t\t\t\t\tboneData.quat.times,\r\n\t\t\t\t\tboneData.quat.values\r\n\t\t\t\t) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tmixer.uncacheAction( clip );\r\n\r\n\t\treturn new AnimationClip( clip.name, - 1, convertedTracks );\r\n\r\n\t},\r\n\r\n\tgetHelperFromSkeleton: function ( skeleton ) {\r\n\r\n\t\tvar source = new SkeletonHelper( skeleton.bones[ 0 ] );\r\n\t\tsource.skeleton = skeleton;\r\n\r\n\t\treturn source;\r\n\r\n\t},\r\n\r\n\tgetSkeletonOffsets: function () {\r\n\r\n\t\tvar targetParentPos = new Vector3(),\r\n\t\t\ttargetPos = new Vector3(),\r\n\t\t\tsourceParentPos = new Vector3(),\r\n\t\t\tsourcePos = new Vector3(),\r\n\t\t\ttargetDir = new Vector2(),\r\n\t\t\tsourceDir = new Vector2();\r\n\r\n\t\treturn function ( target, source, options ) {\r\n\r\n\t\t\toptions = options || {};\r\n\t\t\toptions.hip = options.hip !== undefined ? options.hip : \"hip\";\r\n\t\t\toptions.names = options.names || {};\r\n\r\n\t\t\tif ( ! source.isObject3D ) {\r\n\r\n\t\t\t\tsource = this.getHelperFromSkeleton( source );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar nameKeys = Object.keys( options.names ),\r\n\t\t\t\tnameValues = Object.values( options.names ),\r\n\t\t\t\tsourceBones = source.isObject3D ? source.skeleton.bones : this.getBones( source ),\r\n\t\t\t\tbones = target.isObject3D ? target.skeleton.bones : this.getBones( target ),\r\n\t\t\t\toffsets = [],\r\n\t\t\t\tbone, boneTo,\r\n\t\t\t\tname, i;\r\n\r\n\t\t\ttarget.skeleton.pose();\r\n\r\n\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\r\n\r\n\t\t\t\tbone = bones[ i ];\r\n\t\t\t\tname = options.names[ bone.name ] || bone.name;\r\n\r\n\t\t\t\tboneTo = this.getBoneByName( name, sourceBones );\r\n\r\n\t\t\t\tif ( boneTo && name !== options.hip ) {\r\n\r\n\t\t\t\t\tvar boneParent = this.getNearestBone( bone.parent, nameKeys ),\r\n\t\t\t\t\t\tboneToParent = this.getNearestBone( boneTo.parent, nameValues );\r\n\r\n\t\t\t\t\tboneParent.updateMatrixWorld();\r\n\t\t\t\t\tboneToParent.updateMatrixWorld();\r\n\r\n\t\t\t\t\ttargetParentPos.setFromMatrixPosition( boneParent.matrixWorld );\r\n\t\t\t\t\ttargetPos.setFromMatrixPosition( bone.matrixWorld );\r\n\r\n\t\t\t\t\tsourceParentPos.setFromMatrixPosition( boneToParent.matrixWorld );\r\n\t\t\t\t\tsourcePos.setFromMatrixPosition( boneTo.matrixWorld );\r\n\r\n\t\t\t\t\ttargetDir.subVectors(\r\n\t\t\t\t\t\tnew Vector2( targetPos.x, targetPos.y ),\r\n\t\t\t\t\t\tnew Vector2( targetParentPos.x, targetParentPos.y )\r\n\t\t\t\t\t).normalize();\r\n\r\n\t\t\t\t\tsourceDir.subVectors(\r\n\t\t\t\t\t\tnew Vector2( sourcePos.x, sourcePos.y ),\r\n\t\t\t\t\t\tnew Vector2( sourceParentPos.x, sourceParentPos.y )\r\n\t\t\t\t\t).normalize();\r\n\r\n\t\t\t\t\tvar laterialAngle = targetDir.angle() - sourceDir.angle();\r\n\r\n\t\t\t\t\tvar offset = new Matrix4().makeRotationFromEuler(\r\n\t\t\t\t\t\tnew Euler(\r\n\t\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\tlaterialAngle\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tbone.matrix.multiply( offset );\r\n\r\n\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n\t\t\t\t\tbone.updateMatrixWorld();\r\n\r\n\t\t\t\t\toffsets[ name ] = offset;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn offsets;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trenameBones: function ( skeleton, names ) {\r\n\r\n\t\tvar bones = this.getBones( skeleton );\r\n\r\n\t\tfor ( var i = 0; i < bones.length; ++ i ) {\r\n\r\n\t\t\tvar bone = bones[ i ];\r\n\r\n\t\t\tif ( names[ bone.name ] ) {\r\n\r\n\t\t\t\tbone.name = names[ bone.name ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetBones: function ( skeleton ) {\r\n\r\n\t\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\r\n\r\n\t},\r\n\r\n\tgetBoneByName: function ( name, skeleton ) {\r\n\r\n\t\tfor ( var i = 0, bones = this.getBones( skeleton ); i < bones.length; i ++ ) {\r\n\r\n\t\t\tif ( name === bones[ i ].name )\r\n\r\n\t\t\t\treturn bones[ i ];\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetNearestBone: function ( bone, names ) {\r\n\r\n\t\twhile ( bone.isBone ) {\r\n\r\n\t\t\tif ( names.indexOf( bone.name ) !== - 1 ) {\r\n\r\n\t\t\t\treturn bone;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbone = bone.parent;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tfindBoneTrackData: function ( name, tracks ) {\r\n\r\n\t\tvar regexp = /\\[(.*)\\]\\.(.*)/,\r\n\t\t\tresult = { name: name };\r\n\r\n\t\tfor ( var i = 0; i < tracks.length; ++ i ) {\r\n\r\n\t\t\t// 1 is track name\r\n\t\t\t// 2 is track type\r\n\t\t\tvar trackData = regexp.exec( tracks[ i ].name );\r\n\r\n\t\t\tif ( trackData && name === trackData[ 1 ] ) {\r\n\r\n\t\t\t\tresult[ trackData[ 2 ] ] = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\tgetEqualsBonesNames: function ( skeleton, targetSkeleton ) {\r\n\r\n\t\tvar sourceBones = this.getBones( skeleton ),\r\n\t\t\ttargetBones = this.getBones( targetSkeleton ),\r\n\t\t\tbones = [];\r\n\r\n\t\tsearch : for ( var i = 0; i < sourceBones.length; i ++ ) {\r\n\r\n\t\t\tvar boneName = sourceBones[ i ].name;\r\n\r\n\t\t\tfor ( var j = 0; j < targetBones.length; j ++ ) {\r\n\r\n\t\t\t\tif ( boneName === targetBones[ j ].name ) {\r\n\r\n\t\t\t\t\tbones.push( boneName );\r\n\r\n\t\t\t\t\tcontinue search;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn bones;\r\n\r\n\t},\r\n\r\n\tclone: function ( source ) {\r\n\r\n\t\tvar sourceLookup = new Map();\r\n\t\tvar cloneLookup = new Map();\r\n\r\n\t\tvar clone = source.clone();\r\n\r\n\t\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\r\n\r\n\t\t\tsourceLookup.set( clonedNode, sourceNode );\r\n\t\t\tcloneLookup.set( sourceNode, clonedNode );\r\n\r\n\t\t} );\r\n\r\n\t\tclone.traverse( function ( node ) {\r\n\r\n\t\t\tif ( ! node.isSkinnedMesh ) return;\r\n\r\n\t\t\tvar clonedMesh = node;\r\n\t\t\tvar sourceMesh = sourceLookup.get( node );\r\n\t\t\tvar sourceBones = sourceMesh.skeleton.bones;\r\n\r\n\t\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\r\n\t\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\r\n\r\n\t\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\r\n\r\n\t\t\t\treturn cloneLookup.get( bone );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\r\n\r\n\t\t} );\r\n\r\n\t\treturn clone;\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\nfunction parallelTraverse( a, b, callback ) {\r\n\r\n\tcallback( a, b );\r\n\r\n\tfor ( var i = 0; i < a.children.length; i ++ ) {\r\n\r\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { SkeletonUtils };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/jsm/utils/SkeletonUtils.js","<template>\r\n    <div class=\"webglAnimationMultiple-container\">\r\n        <div id=\"container\"></div>\r\n\t\t<div id=\"info\">\r\n\t\t\tThis demo shows how clone a skinned 3d model using <strong>SkeletonUtils.clone()</strong><br/>\r\n\t\t\tSoldier model from <a href=\"https://www.mixamo.com\" target=\"_blank\" rel=\"noopener\">https://www.mixamo.com</a>.\r\n\t\t</div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport { GLTFLoader } from '@/components/jsm/loaders/GLTFLoader.js'\r\nimport { SkeletonUtils } from '@/components/jsm/utils/SkeletonUtils.js'\r\nexport default {\r\n    data() {\r\n        return {\r\n            worldScene: null, // THREE.Scene where it all will be rendered\r\n\t\t\trenderer: null,\r\n\t\t\tcamera: null,\r\n\t\t\tclock: null,\r\n            mixers: [], // All the THREE.AnimationMixer objects for all the animations in the scene\r\n            MODELS: [\r\n\t\t\t\t{\r\n                    name: \"Soldier\"\r\n                },\r\n\t\t\t\t{\r\n                    name: \"Parrot\"\r\n                },\r\n\t\t\t\t// { name: \"RiflePunch\" },\r\n            ],\r\n            UNITS: [\r\n\t\t\t\t{\r\n\t\t\t\t\tmodelName: \"Soldier\", // Will use the 3D model from file models/gltf/Soldier.glb\r\n\t\t\t\t\tmeshName: \"vanguard_Mesh\", // Name of the main mesh to animate\r\n\t\t\t\t\tposition: { x: 0, y: 0, z: 0 }, // Where to put the unit in the scene\r\n\t\t\t\t\tscale: 1, // Scaling of the unit. 1.0 means: use original size, 0.1 means \"10 times smaller\", etc.\r\n\t\t\t\t\tanimationName: \"Idle\" // Name of animation to run\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tmodelName: \"Soldier\",\r\n\t\t\t\t\tmeshName: \"vanguard_Mesh\",\r\n\t\t\t\t\tposition: { x: 3, y: 0, z: 0 },\r\n\t\t\t\t\tscale: 2,\r\n\t\t\t\t\tanimationName: \"Walk\"\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tmodelName: \"Soldier\",\r\n\t\t\t\t\tmeshName: \"vanguard_Mesh\",\r\n\t\t\t\t\tposition: { x: 1, y: 0, z: 0 },\r\n\t\t\t\t\tscale: 1,\r\n\t\t\t\t\tanimationName: \"Run\"\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tmodelName: \"Parrot\",\r\n\t\t\t\t\tmeshName: \"mesh_0\",\r\n\t\t\t\t\tposition: { x: - 4, y: 0, z: 0 },\r\n\t\t\t\t\trotation: { x: 0, y: Math.PI, z: 0 },\r\n\t\t\t\t\tscale: 0.01,\r\n\t\t\t\t\tanimationName: \"parrot_A_\"\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tmodelName: \"Parrot\",\r\n\t\t\t\t\tmeshName: \"mesh_0\",\r\n\t\t\t\t\tposition: { x: - 2, y: 0, z: 0 },\r\n\t\t\t\t\trotation: { x: 0, y: Math.PI / 2, z: 0 },\r\n\t\t\t\t\tscale: 0.02,\r\n\t\t\t\t\tanimationName: null\r\n\t\t\t\t},\r\n            ],\r\n            numLoadedModels: 0\r\n        }\r\n    },\r\n    mounted() {\r\n        this.initScene()\r\n        this.initRenderer()\r\n        this.loadModels()\r\n        this.animate()\r\n    },\r\n    methods: {\r\n        /**\r\n\t\t\t * Initialize ThreeJS THREE.Scene\r\n        */\r\n        initScene() {\r\n            this.camera = new this.$moduleTHREE.PerspectiveCamera(45, this.$webglInnerWidth / window.innerHeight, 1, 10000)\r\n            this.camera.position.set( 3, 6, - 10 )\r\n            this.camera.lookAt( 0, 1, 0 )\r\n            this.clock = new this.$moduleTHREE.Clock()\r\n            this.worldScene = new this.$moduleTHREE.Scene()\r\n            this.worldScene.background = new this.$moduleTHREE.Color(0xa0a0a0)\r\n            this.worldScene.fog = new this.$moduleTHREE.Fog(0xa0a0a0, 10, 22)\r\n            const hemiLight = new this.$moduleTHREE.HemisphereLight(0xffffff, 0x444444)\r\n            hemiLight.position.set(0, 20, 0)\r\n            this.worldScene.add(hemiLight)\r\n            const dirLight = new this.$moduleTHREE.DirectionalLight(0xffffff)\r\n            dirLight.position.set(-3, 10, -10)\r\n            dirLight.castShadow = true\r\n            dirLight.shadow.camera.top = 10\r\n            dirLight.shadow.camera.bottom = -10\r\n            dirLight.shadow.camera.left = - 10\r\n            dirLight.shadow.camera.right = 10\r\n            dirLight.shadow.camera.near = 0.1\r\n            dirLight.shadow.camera.far = 40\r\n            this.worldScene.add(dirLight)\r\n            // ground\r\n            const groundMesh = new this.$moduleTHREE.Mesh(\r\n                new this.$moduleTHREE.PlaneBufferGeometry( 40, 40 ),\r\n                new this.$moduleTHREE.MeshPhongMaterial({\r\n                    color: 0x999999,\r\n                    depthWrite: false\r\n                })\r\n            )\r\n            groundMesh.rotation.x = - Math.PI / 2\r\n            groundMesh.receiveShadow = true\r\n            this.worldScene.add(groundMesh)\r\n            window.addEventListener('resize', this.onWindowResize, false)\r\n        },\r\n        onWindowResize() {\r\n            this.$onWindowResize(this.camera, this.renderer)\r\n        },\r\n        //////////////////////////////\r\n        // General Three.JS stuff\r\n        //////////////////////////////\r\n        // This part is not anyhow related to the cloning of models, it's just setting up the scene.\r\n        /**\r\n         * Initialize ThreeJS scene renderer\r\n         */\r\n        initRenderer() {\r\n            const container = document.getElementById('container')\r\n            this.renderer = new this.$moduleTHREE.WebGLRenderer({antialias: true})\r\n            this.renderer.setPixelRatio(window.devicePixelRatio)\r\n            this.renderer.setSize(this.$webglInnerWidth, window.innerHeight)\r\n            this.renderer.outputEncoding = this.$moduleTHREE.sRGBEncoding\r\n            this.renderer.shadowMap.enabled = true\r\n            this.renderer.shadowMap.type = this.$moduleTHREE.PCFSoftShadowMap\r\n            container.appendChild(this.renderer.domElement)\r\n        },\r\n        //////////////////////////////\r\n        // Function implementations\r\n        //////////////////////////////\r\n        /**\r\n         * Function that starts loading process for the next model in the queue. The loading process is\r\n         * asynchronous: it happens \"in the background\". Therefore we don't load all the models at once. We load one,\r\n         * wait until it is done, then load the next one. When all models are loaded, we call loadUnits().\r\n         */\r\n        loadModels() {\r\n            for(var i = 0; i < this.MODELS.length; ++ i) {\r\n                var m = this.MODELS[i]\r\n                this.loadGltfModel( m, () => {\r\n                    ++this.numLoadedModels\r\n                    if(this.numLoadedModels === this.MODELS.length) {\r\n                        console.log(\"All models loaded, time to instantiate units...\")\r\n                        this.instantiateUnits()\r\n                    }\r\n                })\r\n            }\r\n        },\r\n        /**\r\n\t\t\t * Load a 3D model from a GLTF file. Use the GLTFLoader.\r\n\t\t\t * @param model {object} Model config, one item from the MODELS array. It will be updated inside the function!\r\n\t\t\t * @param onLoaded {function} A callback function that will be called when the model is loaded\r\n        */\r\n        loadGltfModel(model, onLoaded) {\r\n            var loader = new GLTFLoader()\r\n            var modelName = \"static/models/gltf/\" + model.name + \".glb\"\r\n            loader.load(modelName, (gltf) => {\r\n                var scene = gltf.scene\r\n                model.animations = gltf.animations\r\n                model.scene = scene\r\n                // Enable Shadows\r\n                gltf.scene.traverse((object) => {\r\n                    if(object.isMesh) {\r\n                        object.castShadow = true\r\n                    }\r\n                })\r\n                console.log(\"Done loading model\", model.name)\r\n                onLoaded()\r\n            })\r\n\r\n        },\r\n        animate() {\r\n            requestAnimationFrame(this.animate)\r\n            // Get the time elapsed since the last frame\r\n            var mixerUpdateDelta = this.clock.getDelta()\r\n            // Update all the animation frames\r\n            for (var i = 0; i < this.mixers.length; ++i) {\r\n                this.mixers[i].update(mixerUpdateDelta)\r\n            }\r\n            this.renderer.render(this.worldScene, this.camera)\r\n        },\r\n        /**\r\n         * Look at UNITS configuration, clone necessary 3D model scenes, place the armatures and meshes in the scene and\r\n         * launch necessary animations\r\n         */\r\n        instantiateUnits() {\r\n            var numSuccess = 0\r\n            for (var i = 0; i < this.UNITS.length; ++ i) {\r\n                var u = this.UNITS[i]\r\n                var model = this.getModelByName(u.modelName)\r\n                if (model) {\r\n                    var clonedScene = SkeletonUtils.clone(model.scene)\r\n                    if (clonedScene) {\r\n                        // THREE.Scene is cloned properly, let's find one mesh and launch animation for it\r\n                        var clonedMesh = clonedScene.getObjectByName(u.meshName)\r\n                        if (clonedMesh) {\r\n                            var mixer = this.startAnimation(clonedMesh, model.animations, u.animationName)\r\n                            // Save the animation mixer in the list, will need it in the animation loop\r\n                            this.mixers.push(mixer)\r\n                            numSuccess++\r\n                        }\r\n                        // Different models can have different configurations of armatures and meshes. Therefore,\r\n                        // We can't set position, scale or rotation to individual mesh objects. Instead we set\r\n                        // it to the whole cloned scene and then add the whole scene to the game world\r\n                        // Note: this may have weird effects if you have lights or other items in the GLTF file's scene!\r\n                        this.worldScene.add(clonedScene)\r\n                        if (u.position) {\r\n                            clonedScene.position.set(u.position.x, u.position.y, u.position.z)\r\n                        }\r\n                        if (u.scale) {\r\n                            clonedScene.scale.set(u.scale, u.scale, u.scale)\r\n                        }\r\n                        if (u.rotation) {\r\n                            clonedScene.rotation.x = u.rotation.x\r\n                            clonedScene.rotation.y = u.rotation.y\r\n                            clonedScene.rotation.z = u.rotation.z\r\n                        }\r\n                        }\r\n                } else {\r\n                    console.error(\"Can not find model\", u.modelName)\r\n                }\r\n            }\r\n            console.log(`Successfully instantiated ${numSuccess} units`)\r\n        },\r\n        /**\r\n             * Find a model object by name\r\n             * @param name\r\n             * @returns {object|null}\r\n        */\r\n\t\tgetModelByName(name) {\r\n            for(var i = 0; i < this.MODELS.length; ++ i) {\r\n                if(this.MODELS[ i ].name === name) {\r\n                    return this.MODELS[i]\r\n                }\r\n            }\r\n            return null\r\n        },\r\n        /**\r\n\t\t\t * Start animation for a specific mesh object. Find the animation by name in the 3D model's animation array\r\n\t\t\t * @param skinnedMesh {THREE.SkinnedMesh} The mesh to animate\r\n\t\t\t * @param animations {Array} Array containing all the animations for this model\r\n\t\t\t * @param animationName {string} Name of the animation to launch\r\n\t\t\t * @return {THREE.AnimationMixer} Mixer to be used in the render loop\r\n        */\r\n        startAnimation(skinnedMesh, animations, animationName) {\r\n            var mixer = new this.$moduleTHREE.AnimationMixer(skinnedMesh)\r\n            var clip = this.$moduleTHREE.AnimationClip.findByName(animations, animationName)\r\n            if (clip) {\r\n                var action = mixer.clipAction(clip)\r\n                action.play()\r\n            }\r\n            return mixer\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n.webglAnimationMultiple-container {\r\n    width: 100%;\r\n}\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// src/views/animation/webglAnimationMultiple.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"webglAnimationMultiple-container\"},[_c('div',{attrs:{\"id\":\"container\"}}),_vm._v(\" \"),_c('div',{attrs:{\"id\":\"info\"}},[_vm._v(\"\\n\\t\\t\\tThis demo shows how clone a skinned 3d model using \"),_c('strong',[_vm._v(\"SkeletonUtils.clone()\")]),_c('br'),_vm._v(\"\\n\\t\\t\\tSoldier model from \"),_c('a',{attrs:{\"href\":\"https://www.mixamo.com\",\"target\":\"_blank\",\"rel\":\"noopener\"}},[_vm._v(\"https://www.mixamo.com\")]),_vm._v(\".\\n\\t\\t\")])])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-3e22982e\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/views/animation/webglAnimationMultiple.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true,\\\"publicPath\\\":\\\"../../\\\"}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-3e22982e\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./webglAnimationMultiple.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./webglAnimationMultiple.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./webglAnimationMultiple.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-3e22982e\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./webglAnimationMultiple.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-3e22982e\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/animation/webglAnimationMultiple.vue\n// module id = null\n// module chunks = "],"sourceRoot":""}