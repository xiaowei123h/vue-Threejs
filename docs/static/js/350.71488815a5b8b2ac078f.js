webpackJsonp([350],{aiS9:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var i=t("wIBv"),a=t("xTnh"),r=t("QEtz"),o=t("DqHV"),s={data:function(){return{renderer:null,scene:null,camera:null,mesh:null,gui:null}},mounted:function(){!1===o.a.isWebGL2Available()&&document.getElementsByClassName("webgl2VolumeCloud-container")[0].appendChild(o.a.getWebGL2ErrorMessage()),this.init(),this.animate()},beforeDestroy:function(){this.gui.destroy()},methods:{init:function(){this.renderer=new this.$THREE.WebGLRenderer,this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(this.$webglInnerWidth,window.innerHeight),document.getElementsByClassName("webgl2VolumeCloud-container")[0].appendChild(this.renderer.domElement),this.scene=new this.$THREE.Scene,this.camera=new this.$THREE.PerspectiveCamera(60,this.$webglInnerWidth/window.innerHeight,.1,100),this.camera.position.set(0,0,1.5),new i.b(this.camera,this.renderer.domElement);var e=document.createElement("canvas");e.width=1,e.height=32;var n=e.getContext("2d"),t=n.createLinearGradient(0,0,0,32);t.addColorStop(0,"#014a84"),t.addColorStop(.5,"#0561a0"),t.addColorStop(1,"#437ab6"),n.fillStyle=t,n.fillRect(0,0,1,32);var o=new this.$THREE.Mesh(new this.$THREE.SphereBufferGeometry(10),new this.$THREE.MeshBasicMaterial({map:new this.$THREE.CanvasTexture(e),side:this.$THREE.BackSide}));this.scene.add(o);for(var s=new Uint8Array(2097152),d=0,m=new a.a,c=new this.$THREE.Vector3,l=0;l<128;l++)for(var h=0;h<128;h++)for(var u=0;u<128;u++){var v=1-c.set(u,h,l).subScalar(64).divideScalar(128).length();s[d]=(128+128*m.noise(.05*u/1.5,.05*h,.05*l/1.5))*v*v,d++}var f=new this.$THREE.DataTexture3D(s,128,128,128);f.format=this.$THREE.RedFormat,f.minFilter=this.$THREE.LinearFilter,f.magFilter=this.$THREE.LinearFilter,f.unpackAlignment=1;var p=new this.$THREE.BoxBufferGeometry(1,1,1),g=new this.$THREE.RawShaderMaterial({glslVersion:this.$THREE.GLSL3,uniforms:{base:{value:new this.$THREE.Color(7965344)},map:{value:f},cameraPos:{value:new this.$THREE.Vector3},threshold:{value:.25},opacity:{value:.25},range:{value:.1},steps:{value:100},frame:{value:0}},vertexShader:"\n                in vec3 position;\n                uniform mat4 modelMatrix;\n                uniform mat4 modelViewMatrix;\n                uniform mat4 projectionMatrix;\n                uniform vec3 cameraPos;\n                out vec3 vOrigin;\n                out vec3 vDirection;\n                void main() {\n                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                    vOrigin = vec3(inverse(modelMatrix) * vec4(cameraPos, 1.0)).xyz;\n                    vDirection = position - vOrigin;\n                    gl_Position = projectionMatrix * mvPosition;\n                }\n            ",fragmentShader:"\n                precision highp float;\n                precision highp sampler3D;\n                uniform mat4 modelViewMatrix;\n                uniform mat4 projectionMatrix;\n                in vec3 vOrigin;\n                in vec3 vDirection;\n                out vec4 color;\n                uniform vec3 base;\n                uniform sampler3D map;\n                uniform float threshold;\n                uniform float range;\n                uniform float opacity;\n                uniform float steps;\n                uniform float frame;\n                uint wang_hash(uint seed)\n                {\n                        seed = (seed ^ 61u) ^ (seed >> 16u);\n                        seed *= 9u;\n                        seed = seed ^ (seed >> 4u);\n                        seed *= 0x27d4eb2du;\n                        seed = seed ^ (seed >> 15u);\n                        return seed;\n                }\n                float randomFloat(inout uint seed)\n                {\n                        return float(wang_hash(seed)) / 4294967296.;\n                }\n                vec2 hitBox(vec3 orig, vec3 dir) {\n                    const vec3 box_min = vec3(- 0.5);\n                    const vec3 box_max = vec3(0.5);\n                    vec3 inv_dir = 1.0 / dir;\n                    vec3 tmin_tmp = (box_min - orig) * inv_dir;\n                    vec3 tmax_tmp = (box_max - orig) * inv_dir;\n                    vec3 tmin = min(tmin_tmp, tmax_tmp);\n                    vec3 tmax = max(tmin_tmp, tmax_tmp);\n                    float t0 = max(tmin.x, max(tmin.y, tmin.z));\n                    float t1 = min(tmax.x, min(tmax.y, tmax.z));\n                    return vec2(t0, t1);\n                }\n                float sample1(vec3 p) {\n                    return texture(map, p).r;\n                }\n                float shading(vec3 coord) {\n                    float step = 0.01;\n                    return sample1(coord + vec3(- step)) - sample1(coord + vec3(step));\n                }\n                void main(){\n                    vec3 rayDir = normalize(vDirection);\n                    vec2 bounds = hitBox(vOrigin, rayDir);\n                    if (bounds.x > bounds.y) discard;\n                    bounds.x = max(bounds.x, 0.0);\n                    vec3 p = vOrigin + bounds.x * rayDir;\n                    vec3 inc = 1.0 / abs(rayDir);\n                    float delta = min(inc.x, min(inc.y, inc.z));\n                    delta /= steps;\n                    // Jitter\n                    // Nice little seed from\n                    // https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\n                    uint seed = uint(gl_FragCoord.x) * uint(1973) + uint(gl_FragCoord.y) * uint(9277) + uint(frame) * uint(26699);\n                    vec3 size = vec3(textureSize(map, 0));\n                    float randNum = randomFloat(seed) * 2.0 - 1.0;\n                    p += rayDir * randNum * (1.0 / size);\n                    //\n                    vec4 ac = vec4(base, 0.0);\n                    for (float t = bounds.x; t < bounds.y; t += delta) {\n                        float d = sample1(p + 0.5);\n                        d = smoothstep(threshold - range, threshold + range, d) * opacity;\n                        float col = shading(p + 0.5) * 3.0 + ((p.x + p.y) * 0.25) + 0.2;\n                        ac.rgb += (1.0 - ac.a) * d * col;\n                        ac.a += (1.0 - ac.a) * d;\n                        if (ac.a >= 0.95) break;\n                        p += rayDir * delta;\n                    }\n                    color = ac;\n                    if (color.a == 0.0) discard;\n                }\n            ",side:this.$THREE.BackSide,transparent:!0});this.mesh=new this.$THREE.Mesh(p,g),this.scene.add(this.mesh);var x={threshold:.25,opacity:.25,range:.1,steps:100};function E(){g.uniforms.threshold.value=x.threshold,g.uniforms.opacity.value=x.opacity,g.uniforms.range.value=x.range,g.uniforms.steps.value=x.steps}this.gui=new r.a,this.gui.add(x,"threshold",0,1,.01).onChange(E),this.gui.add(x,"opacity",0,1,.01).onChange(E),this.gui.add(x,"range",0,1,.01).onChange(E),this.gui.add(x,"steps",0,200,1).onChange(E),window.addEventListener("resize",this.onWindowResize,!1)},onWindowResize:function(){this.$onWindowResize(this.camera,this.renderer)},animate:function(){requestAnimationFrame(this.animate),this.mesh.material.uniforms.cameraPos.value.copy(this.camera.position),this.mesh.rotation.y=-performance.now()/7500,this.mesh.material.uniforms.frame.value++,this.renderer.render(this.scene,this.camera)}}},d={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this.$createElement,n=this._self._c||e;return n("div",{staticClass:"webgl2VolumeCloud-container"},[n("div",{attrs:{id:"info"}},[n("a",{attrs:{href:"https://threejs.org",target:"_blank",rel:"noopener"}},[this._v("three.js")]),this._v(" webgl2 - volume - cloud\n\t\t")])])}]};var m=t("VU/8")(s,d,!1,function(e){t("e69v")},"data-v-0664ecfe",null);n.default=m.exports},e69v:function(e,n){}});
//# sourceMappingURL=350.71488815a5b8b2ac078f.js.map