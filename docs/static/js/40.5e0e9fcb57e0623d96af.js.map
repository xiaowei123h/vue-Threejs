{"version":3,"sources":["webpack:///src/views/modifier/webglModifierCurve.vue","webpack:///./src/views/modifier/webglModifierCurve.vue?055d","webpack:///./src/views/modifier/webglModifierCurve.vue","webpack:///./src/components/jsm/modifiers/CurveModifier.js"],"names":["webglModifierCurve","data","ACTION_SELECT","ACTION_NONE","curveHandles","mouse","stats","scene","camera","renderer","rayCaster","control","flow","action","mounted","this","$THREE","Vector2","init","animate","methods","_this","Scene","PerspectiveCamera","$webglInnerWidth","window","innerHeight","position","set","lookAt","boxGeometry","BoxBufferGeometry","boxMaterial","MeshBasicMaterial","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","x","y","z","Symbol","iterator","next","done","handlePos","value","handle","Mesh","copy","push","add","err","return","curve","CatmullRomCurve3","map","curveType","closed","points","getPoints","line","LineLoop","BufferGeometry","setFromPoints","LineBasicMaterial","color","light","DirectionalLight","intensity","light2","AmbientLight","FontLoader","load","font","geometry","TextBufferGeometry","size","height","curveSegments","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","rotateX","Math","PI","material","MeshStandardMaterial","objectToCurve","CurveModifier","updateCurve","object3D","WebGLRenderer","antialias","setPixelRatio","devicePixelRatio","setSize","document","getElementsByClassName","appendChild","domElement","addEventListener","onPointerDown","Raycaster","TransformControls","event","$Stats","dom","style","left","onWindowResize","$onWindowResize","clientX","innerWidth","clientY","requestAnimationFrame","setFromCamera","intersects","intersectObjects","length","target","object","attach","moveAlongCurve","render","update","modifier_webglModifierCurve","$createElement","_self","_c","_m","staticRenderFns","_h","staticClass","attrs","id","href","rel","_v","Component","__webpack_require__","normalizeComponent","ssrContext","__webpack_exports__","BITS","TEXTURE_WIDTH","TEXTURE_HEIGHT","setTextureValue","texture","index","o","image","i","Flow","mesh","numberOfCurves","arguments","_classCallCheck","obj3D","clone","splineTexure","dataArray","Float32Array","dataTexture","DataTexture","RGBFormat","FloatType","wrapS","RepeatWrapping","wrapY","magFilter","NearestFilter","needsUpdate","initSplineTexture","uniforms","spineTexture","pathOffset","type","pathSegment","spineOffset","spineLength","traverse","child","InstancedMesh","__ok","onBeforeCompile","shader","__modified","Object","assign","vertexShader","replace","modifyShader","curveArray","Array","curveLengthArray","_createClass","key","Error","curveLength","getLength","splineCurve","offset","numberOfPoints","floor","arcLengthDivisions","updateArcLengths","getSpacedPoints","frenetFrames","computeFrenetFrames","rowOffset","rowIndex","pt","tangents","normals","binormals","updateSplineTexture","amount","matrix","Matrix4","InstancedFlow","_Flow","count","curveCount","instanceMatrix","setUsage","DynamicDrawUsage","_possibleConstructorReturn","__proto__","getPrototypeOf","call","offsets","fill","whichCurve","_inherits","makeTranslation","setMatrixAt","writeChanges","curveNo","isNaN"],"mappings":"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","file":"static/js/40.5e0e9fcb57e0623d96af.js","sourcesContent":["<template>\r\n    <div class=\"webglModifierCurve-container\">\r\n        <div id=\"info\">\r\n\t\t\t<a href=\"https://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a> webgl - curve modifier\r\n\t\t</div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport { TransformControls } from \"@/components/jsm/controls/TransformControls.js\"\r\nimport { Flow } from \"@/components/jsm/modifiers/CurveModifier.js\"\r\nexport default {\r\n    data() {\r\n        return {\r\n            ACTION_SELECT: 1,\r\n            ACTION_NONE: 0,\r\n\t\t\tcurveHandles: [],\r\n\t\t\tmouse: null,\r\n\t\t\tstats: null,\r\n\t\t\tscene: null,\r\n            camera: null,\r\n            renderer: null,\r\n            rayCaster: null,\r\n            control: null,\r\n            flow: null,\r\n            action: null,\r\n        }\r\n    },\r\n    mounted() {\r\n        this.mouse = new this.$THREE.Vector2()\r\n        this.action = this.ACTION_NONE\r\n        this.init()\r\n\t\tthis.animate()\r\n    },\r\n    methods: {\r\n        init() {\r\n            this.scene = new this.$THREE.Scene()\r\n            this.camera = new this.$THREE.PerspectiveCamera(\r\n                40,\r\n                this.$webglInnerWidth / window.innerHeight,\r\n                1,\r\n                1000\r\n            )\r\n            this.camera.position.set(2, 2, 4)\r\n            this.camera.lookAt(this.scene.position)\r\n            var initialPoints = [\r\n                { x: 1, y: 0, z: - 1 },\r\n                { x: 1, y: 0, z: 1 },\r\n                { x: - 1, y: 0, z: 1 },\r\n                { x: - 1, y: 0, z: - 1 },\r\n            ]\r\n            var boxGeometry = new this.$THREE.BoxBufferGeometry(0.1, 0.1, 0.1)\r\n            var boxMaterial = new this.$THREE.MeshBasicMaterial(0x99ff99)\r\n            for (var handlePos of initialPoints) {\r\n                var handle = new this.$THREE.Mesh(boxGeometry, boxMaterial)\r\n                handle.position.copy(handlePos)\r\n                this.curveHandles.push(handle)\r\n                this.scene.add(handle)\r\n            }\r\n            var curve = new this.$THREE.CatmullRomCurve3(\r\n                this.curveHandles.map((handle) => handle.position)\r\n            )\r\n            curve.curveType = \"centripetal\"\r\n            curve.closed = true\r\n            var points = curve.getPoints(50)\r\n            var line = new this.$THREE.LineLoop(\r\n                new this.$THREE.BufferGeometry().setFromPoints(points),\r\n                new this.$THREE.LineBasicMaterial({ color: 0x00ff00 })\r\n            )\r\n            this.scene.add(line)\r\n            //\r\n            var light = new this.$THREE.DirectionalLight(0xffaa33)\r\n            light.position.set(- 10, 10, 10)\r\n            light.intensity = 1.0\r\n            this.scene.add(light)\r\n            var light2 = new this.$THREE.AmbientLight(0x003973)\r\n            light2.intensity = 1.0\r\n            this.scene.add(light2)\r\n            //\r\n            var loader = new this.$THREE.FontLoader()\r\n            loader.load(\"static/fonts/helvetiker_regular.typeface.json\", (\r\n                font\r\n            ) => {\r\n                var geometry = new this.$THREE.TextBufferGeometry(\"Hello three.js!\", {\r\n                    font: font,\r\n                    size: 0.2,\r\n                    height: 0.05,\r\n                    curveSegments: 12,\r\n                    bevelEnabled: true,\r\n                    bevelThickness: 0.02,\r\n                    bevelSize: 0.01,\r\n                    bevelOffset: 0,\r\n                    bevelSegments: 5,\r\n                })\r\n                geometry.rotateX(Math.PI)\r\n                var material = new this.$THREE.MeshStandardMaterial({\r\n                    color: 0x99ffff\r\n                })\r\n                var objectToCurve = new this.$THREE.Mesh(geometry, material)\r\n                this.flow = new Flow(objectToCurve)\r\n                this.flow.updateCurve(0, curve)\r\n                this.scene.add(this.flow.object3D)\r\n            })\r\n            //\r\n            this.renderer = new this.$THREE.WebGLRenderer({ antialias: true })\r\n            this.renderer.setPixelRatio(window.devicePixelRatio)\r\n            this.renderer.setSize(this.$webglInnerWidth, window.innerHeight)\r\n            document.getElementsByClassName('webglModifierCurve-container')[0].appendChild(this.renderer.domElement)\r\n            this.renderer.domElement.addEventListener('pointerdown', this.onPointerDown, false)\r\n            this.rayCaster = new this.$THREE.Raycaster()\r\n            this.control = new TransformControls(this.camera, this.renderer.domElement)\r\n            this.control.addEventListener(\"dragging-changed\", (event) => {\r\n                if (! event.value) {\r\n                    var points = curve.getPoints(50)\r\n                    line.geometry.setFromPoints(points)\r\n                    this.flow.updateCurve(0, curve)\r\n                }\r\n            })\r\n            this.stats = new this.$Stats()\r\n            this.stats.dom.style.left = '280px'\r\n            document.getElementsByClassName('webglModifierCurve-container')[0].appendChild(this.stats.dom)\r\n            window.addEventListener(\"resize\", this.onWindowResize, false)\r\n        },\r\n        onWindowResize() {\r\n            this.$onWindowResize(this.camera, this.renderer)\r\n        },\r\n        onPointerDown(event) {\r\n            this.action = this.ACTION_SELECT\r\n            this.mouse.x = (event.clientX / (window.innerWidth - 281)) * 2 - 1\r\n            this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1\r\n        },\r\n        animate() {\r\n            requestAnimationFrame(this.animate)\r\n            if (this.action === this.ACTION_SELECT) {\r\n                this.rayCaster.setFromCamera(this.mouse, this.camera)\r\n                this.action = this.ACTION_NONE\r\n                var intersects = this.rayCaster.intersectObjects(this.curveHandles)\r\n                if (intersects.length) {\r\n                    var target = intersects[ 0 ].object\r\n                    this.control.attach(target)\r\n                    this.scene.add(this.control)\r\n                }\r\n            }\r\n            if (this.flow) {\r\n                this.flow.moveAlongCurve(0.001)\r\n            }\r\n            this.render()\r\n        },\r\n        render() {\r\n            this.renderer.render(this.scene, this.camera)\r\n            this.stats.update()\r\n        }\r\n    },\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n.webglModifierCurve-container {\r\n    width: 100%;\r\n}\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// src/views/modifier/webglModifierCurve.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"webglModifierCurve-container\"},[_c('div',{attrs:{\"id\":\"info\"}},[_c('a',{attrs:{\"href\":\"https://threejs.org\",\"target\":\"_blank\",\"rel\":\"noopener\"}},[_vm._v(\"three.js\")]),_vm._v(\" webgl - curve modifier\\n\\t\\t\")])])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-526e0f10\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/views/modifier/webglModifierCurve.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true,\\\"publicPath\\\":\\\"../../\\\"}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-526e0f10\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./webglModifierCurve.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./webglModifierCurve.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./webglModifierCurve.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-526e0f10\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./webglModifierCurve.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-526e0f10\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/modifier/webglModifierCurve.vue\n// module id = null\n// module chunks = ","// Original src: https://github.com/zz85/threejs-path-flow\r\nconst BITS = 3;\r\nconst TEXTURE_WIDTH = 1024;\r\nconst TEXTURE_HEIGHT = 4;\r\n\r\nimport {\r\n\tDataTexture,\r\n\tRGBFormat,\r\n\tFloatType,\r\n\tRepeatWrapping,\r\n\tMesh,\r\n\tInstancedMesh,\r\n\tNearestFilter,\r\n\tDynamicDrawUsage,\r\n\tMatrix4\r\n} from \"@/components/build/three.module.js\";\r\n\r\n/**\r\n * Make a new DataTexture to store the descriptions of the curves.\r\n *\r\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\r\n */\r\nexport function initSplineTexture( numberOfCurves = 1 ) {\r\n\r\n\tconst dataArray = new Float32Array( TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * BITS );\r\n\tconst dataTexture = new DataTexture(\r\n\t\tdataArray,\r\n\t\tTEXTURE_WIDTH,\r\n\t\tTEXTURE_HEIGHT * numberOfCurves,\r\n\t\tRGBFormat,\r\n\t\tFloatType\r\n\t);\r\n\r\n\tdataTexture.wrapS = RepeatWrapping;\r\n\tdataTexture.wrapY = RepeatWrapping;\r\n\tdataTexture.magFilter = NearestFilter;\r\n\tdataTexture.needsUpdate = true;\r\n\r\n\treturn dataTexture;\r\n\r\n}\r\n\r\n/**\r\n * Write the curve description to the data texture\r\n *\r\n * @param { DataTexture } texture The DataTexture to write to\r\n * @param { Curve } splineCurve The curve to describe\r\n * @param { number } offset Which curve slot to write to\r\n */\r\nexport function updateSplineTexture( texture, splineCurve, offset = 0 ) {\r\n\r\n\tconst numberOfPoints = Math.floor( TEXTURE_WIDTH * ( TEXTURE_HEIGHT / 4 ) );\r\n\tsplineCurve.arcLengthDivisions = numberOfPoints / 2;\r\n\tsplineCurve.updateArcLengths();\r\n\tconst points = splineCurve.getSpacedPoints( numberOfPoints );\r\n\tconst frenetFrames = splineCurve.computeFrenetFrames( numberOfPoints, true );\r\n\r\n\tfor ( let i = 0; i < numberOfPoints; i ++ ) {\r\n\r\n\t\tconst rowOffset = Math.floor( i / TEXTURE_WIDTH );\r\n\t\tconst rowIndex = i % TEXTURE_WIDTH;\r\n\r\n\t\tlet pt = points[ i ];\r\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\r\n\t\tpt = frenetFrames.tangents[ i ];\r\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\r\n\t\tpt = frenetFrames.normals[ i ];\r\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\r\n\t\tpt = frenetFrames.binormals[ i ];\r\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\r\n\r\n\t}\r\n\r\n\ttexture.needsUpdate = true;\r\n\r\n}\r\n\r\n\r\nfunction setTextureValue( texture, index, x, y, z, o ) {\r\n\r\n\tconst image = texture.image;\r\n\tconst { data } = image;\r\n\tconst i = BITS * TEXTURE_WIDTH * o; // Row Offset\r\n\tdata[ index * BITS + i + 0 ] = x;\r\n\tdata[ index * BITS + i + 1 ] = y;\r\n\tdata[ index * BITS + i + 2 ] = z;\r\n\r\n}\r\n\r\n/**\r\n * Create a new set of uniforms for describing the curve modifier\r\n *\r\n * @param { DataTexture } Texture which holds the curve description\r\n */\r\nexport function getUniforms( splineTexture ) {\r\n\r\n\tconst uniforms = {\r\n\t\tspineTexture: { value: splineTexture },\r\n\t\tpathOffset: { type: 'f', value: 0 }, // time of path curve\r\n\t\tpathSegment: { type: 'f', value: 1 }, // fractional length of path\r\n\t\tspineOffset: { type: 'f', value: 161 },\r\n\t\tspineLength: { type: 'f', value: 400 },\r\n\t\tflow: { type: 'i', value: 1 },\r\n\t};\r\n\treturn uniforms;\r\n\r\n}\r\n\r\nexport function modifyShader( material, uniforms, numberOfCurves = 1 ) {\r\n\r\n\tif ( material.__ok ) return;\r\n\tmaterial.__ok = true;\r\n\r\n\tmaterial.onBeforeCompile = ( shader ) => {\r\n\r\n\t\tif ( shader.__modified ) return;\r\n\t\tshader.__modified = true;\r\n\r\n\t\tObject.assign( shader.uniforms, uniforms );\r\n\r\n\t\tconst vertexShader = `\r\n\t\t#define USE_ENVMAP\r\n\t\tuniform sampler2D spineTexture;\r\n\t\tuniform float pathOffset;\r\n\t\tuniform float pathSegment;\r\n\t\tuniform float spineOffset;\r\n\t\tuniform float spineLength;\r\n\t\tuniform int flow;\r\n\r\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\r\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\r\n\r\n\t\t${shader.vertexShader}\r\n\t\t`.replace(\r\n\t\t'#include <defaultnormal_vertex>',\r\n\t\t`\r\n\t\tvec4 worldPos = modelMatrix * vec4(position, 1.);\r\n\r\n\t\tbool bend = flow > 0;\r\n\t\tfloat xWeight = bend ? 0. : 1.;\r\n\r\n\t\t#ifdef USE_INSTANCING\r\n\t\tfloat pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\r\n\t\tfloat spineLengthFromInstanceMatrix = instanceMatrix[3][0];\r\n\t\tfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\r\n\t\tfloat mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\r\n\t\t#else\r\n\t\tfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\r\n\t\tfloat mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\r\n\t\t#endif\r\n\r\n\t\tmt = mod(mt, textureStacks);\r\n\t\tfloat rowOffset = floor(mt);\r\n\r\n\t\t#ifdef USE_INSTANCING\r\n\t\trowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\r\n\t\t#endif\r\n\r\n\t\tvec3 spinePos = texture(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\r\n\t\tvec3 a =        texture(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\r\n\t\tvec3 b =        texture(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\r\n\t\tvec3 c =        texture(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\r\n\t\tmat3 basis = mat3(a, b, c);\r\n\r\n\t\tvec3 transformed = basis\r\n\t\t\t* vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\r\n\t\t\t+ spinePos;\r\n\r\n\t\tvec3 transformedNormal = normalMatrix * (basis * objectNormal);\r\n\t\t`\r\n\t).replace(\r\n\t\t'#include <begin_vertex>',\r\n\t\t''\r\n\t).replace(\r\n\t\t'#include <project_vertex>',\r\n\t\t`\r\n\t\t\tvec4 mvPosition = viewMatrix * vec4( transformed, 1.0 );\r\n\t\t\t// vec4 mvPosition = viewMatrix * worldPos;\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\t\t\t`\r\n\t);\r\n\r\n\t\tshader.vertexShader = vertexShader;\r\n\r\n\t};\r\n\r\n}\r\n\r\n/**\r\n * A helper class for making meshes bend aroudn curves\r\n */\r\nexport class Flow {\r\n\r\n\t/**\r\n\t * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\r\n\t * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\r\n\t */\r\n\tconstructor( mesh, numberOfCurves = 1 ) {\r\n\r\n\t\tconst obj3D = mesh.clone();\r\n\t\tconst splineTexure = initSplineTexture( numberOfCurves );\r\n\t\tconst uniforms = getUniforms( splineTexure );\r\n\t\tobj3D.traverse( function ( child ) {\r\n\r\n\t\t\tif (\r\n\t\t\t\tchild instanceof Mesh ||\r\n\t\t\t\tchild instanceof InstancedMesh\r\n\t\t\t) {\r\n\r\n\t\t\t\tchild.material = child.material.clone();\r\n\t\t\t\tmodifyShader( child.material, uniforms, numberOfCurves );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tthis.curveArray = new Array( numberOfCurves );\r\n\t\tthis.curveLengthArray = new Array( numberOfCurves );\r\n\r\n\t\tthis.object3D = obj3D;\r\n\t\tthis.splineTexure = splineTexure;\r\n\t\tthis.uniforms = uniforms;\r\n\r\n\t}\r\n\r\n\tupdateCurve( index, curve ) {\r\n\r\n\t\tif ( index >= this.curveArray.length ) throw Error( 'Index out of range for Flow' );\r\n\t\tconst curveLength = curve.getLength();\r\n\t\tthis.uniforms.spineLength.value = curveLength;\r\n\t\tthis.curveLengthArray[ index ] = curveLength;\r\n\t\tthis.curveArray[ index ] = curve;\r\n\t\tupdateSplineTexture( this.splineTexure, curve, index );\r\n\r\n\t}\r\n\r\n\tmoveAlongCurve( amount ) {\r\n\r\n\t\tthis.uniforms.pathOffset.value += amount;\r\n\r\n\t}\r\n\r\n}\r\nconst matrix = new Matrix4();\r\n\r\n/**\r\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\r\n */\r\nexport class InstancedFlow extends Flow {\r\n\r\n\t/**\r\n\t *\r\n\t * @param {number} count The number of instanced elements\r\n\t * @param {number} curveCount The number of curves to preallocate for\r\n\t * @param {Geometry} geometry The geometry to use for the instanced mesh\r\n\t * @param {Material} material The material to use for the instanced mesh\r\n\t */\r\n\tconstructor( count, curveCount, geometry, material ) {\r\n\r\n\t\tconst mesh = new InstancedMesh(\r\n\t\t\tgeometry,\r\n\t\t\tmaterial,\r\n\t\t\tcount\r\n\t\t);\r\n\t\tmesh.instanceMatrix.setUsage( DynamicDrawUsage );\r\n\t\tsuper( mesh, curveCount );\r\n\r\n\t\tthis.offsets = new Array( count ).fill( 0 );\r\n\t\tthis.whichCurve = new Array( count ).fill( 0 );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\r\n\t * This writes that information to the matrix and marks it as needing update.\r\n\t *\r\n\t * @param {number} index of the instanced element to update\r\n\t */\r\n\twriteChanges( index ) {\r\n\r\n\t\tmatrix.makeTranslation(\r\n\t\t\tthis.curveLengthArray[ this.whichCurve[ index ] ],\r\n\t\t\tthis.whichCurve[ index ],\r\n\t\t\tthis.offsets[ index ]\r\n\t\t);\r\n\t\tthis.object3D.setMatrixAt( index, matrix );\r\n\t\tthis.object3D.instanceMatrix.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Move an individual element along the curve by a specific amount\r\n\t *\r\n\t * @param {number} index Which element to update\r\n\t * @param {number} offset Move by how much\r\n\t */\r\n\tmoveIndividualAlongCurve( index, offset ) {\r\n\r\n\t\tthis.offsets[ index ] += offset;\r\n\t\tthis.writeChanges( index );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Select which curve to use for an element\r\n\t *\r\n\t * @param {number} index the index of the instanced element to update\r\n\t * @param {number} curveNo the index of the curve it should use\r\n\t */\r\n\tsetCurve( index, curveNo ) {\r\n\r\n\t\tif ( isNaN( curveNo ) ) throw Error( \"curve index being set is Not a Number (NaN)\" );\r\n\t\tthis.whichCurve[ index ] = curveNo;\r\n\t\tthis.writeChanges( index );\r\n\r\n\t}\r\n\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/jsm/modifiers/CurveModifier.js"],"sourceRoot":""}