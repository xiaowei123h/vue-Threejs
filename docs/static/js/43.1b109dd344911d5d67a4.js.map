{"version":3,"sources":["webpack:///./src/components/jsm/misc/GPUComputationRenderer.js","webpack:///src/views/gpgpu/webglGpgpuWater.vue","webpack:///./src/views/gpgpu/webglGpgpuWater.vue?7168","webpack:///./src/views/gpgpu/webglGpgpuWater.vue"],"names":["__webpack_require__","d","__webpack_exports__","GPUComputationRenderer","__WEBPACK_IMPORTED_MODULE_0__components_build_three_module_js__","sizeX","sizeY","renderer","this","variables","currentTextureIndex","dataType","FloatType","scene","Scene","camera","Camera","position","z","passThruUniforms","passThruTexture","value","passThruShader","createShaderMaterial","mesh","Mesh","PlaneBufferGeometry","addResolutionDefine","materialShader","defines","resolution","toFixed","computeFragmentShader","uniforms","material","ShaderMaterial","vertexShader","fragmentShader","add","setDataType","type","addVariable","variableName","initialValueTexture","variable","name","dependencies","renderTargets","wrapS","wrapT","minFilter","NearestFilter","magFilter","push","setVariableDependencies","init","capabilities","isWebGL2","extensions","has","maxVertexTextures","i","length","createRenderTarget","renderTexture","depVar","found","j","compute","nextTextureIndex","il","dl","texture","doRenderTarget","getCurrentRenderTarget","getAlternateRenderTarget","sizeXTexture","sizeYTexture","ClampToEdgeWrapping","WebGLRenderTarget","format","RGBAFormat","depthBuffer","createTexture","data","Float32Array","DataTexture","input","output","currentRenderTarget","getRenderTarget","setRenderTarget","render","webglGpgpuWater","heightmapFragmentShader","smoothFragmentShader","readWaterLevelFragmentShader","waterVertexShader","gui","WIDTH","BOUNDS","BOUNDS_HALF","container","stats","mouseMoved","mouseCoords","raycaster","waterMesh","meshRay","gpuCompute","heightmapVariable","waterUniforms","smoothShader","readWaterLevelShader","readWaterLevelRenderTarget","readWaterLevelImage","waterNormal","NUM_SPHERES","spheres","spheresEnabled","simplex","mounted","$THREE","Vector2","Raycaster","Vector3","SimplexNoise","animate","beforeDestroy","destroy","methods","_this","document","createElement","getElementsByClassName","appendChild","PerspectiveCamera","$webglInnerWidth","window","innerHeight","set","lookAt","sun","DirectionalLight","sun2","WebGLRenderer","setPixelRatio","devicePixelRatio","setSize","domElement","$Stats","dom","style","left","touchAction","addEventListener","onPointerMove","event","keyCode","wireframe","needsUpdate","onWindowResize","dat_gui_module","effectController","mouseSize","viscosity","valuesChanger","visible","onChange","buttonSmooth","smoothWater","initWater","createSpheres","geometry","UniformsUtils","merge","ShaderLib","heightmap","ShaderChunk","lights","color","Color","specular","shininess","Math","max","opacity","rotation","x","PI","matrixAutoUpdate","updateMatrix","geometryRay","MeshBasicMaterial","isSafari","HalfFloatType","heightmap0","fillTexture","error","console","smoothTexture","point1","levelTexture","Uint8Array","UnsignedByteType","navigator","userAgent","match","waterMaxHeight","that","noise","y","multR","mult","r","pixels","image","p","alternateRenderTarget","sphereTemplate","SphereBufferGeometry","MeshPhongMaterial","sphere","clone","random","userData","velocity","sphereDynamics","u","v","readRenderTargetPixels","buffer","pos","multiplyScalar","$onWindowResize","setMouseCoords","clientWidth","clientHeight","isPrimary","clientX","clientY","requestAnimationFrame","update","setFromCamera","intersects","intersectObject","point","gpgpu_webglGpgpuWater","$createElement","_self","_c","_m","staticRenderFns","_h","staticClass","attrs","id","href","target","rel","_v","Component","normalizeComponent","ssrContext"],"mappings":"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","file":"static/js/43.1b109dd344911d5d67a4.js","sourcesContent":["import {\r\n\tCamera,\r\n\tClampToEdgeWrapping,\r\n\tDataTexture,\r\n\tFloatType,\r\n\tMesh,\r\n\tNearestFilter,\r\n\tPlaneBufferGeometry,\r\n\tRGBAFormat,\r\n\tScene,\r\n\tShaderMaterial,\r\n\tWebGLRenderTarget\r\n} from \"@/components/build/three.module.js\";\r\n\r\n/**\r\n * GPUComputationRenderer, based on SimulationRenderer by zz85\r\n *\r\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\r\n * for each compute element (texel)\r\n *\r\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\r\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\r\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\r\n *\r\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\r\n * as inputs to render the textures of the next frame.\r\n *\r\n * The render targets of the variables can be used as input textures for your visualization shaders.\r\n *\r\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\r\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\r\n *\r\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\r\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\r\n *\r\n * -------------\r\n *\r\n * Basic use:\r\n *\r\n * // Initialization...\r\n *\r\n * // Create computation renderer\r\n * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\r\n *\r\n * // Create initial state float textures\r\n * var pos0 = gpuCompute.createTexture();\r\n * var vel0 = gpuCompute.createTexture();\r\n * // and fill in here the texture data...\r\n *\r\n * // Add texture variables\r\n * var velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\r\n * var posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\r\n *\r\n * // Add variable dependencies\r\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\r\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\r\n *\r\n * // Add custom uniforms\r\n * velVar.material.uniforms.time = { value: 0.0 };\r\n *\r\n * // Check for completeness\r\n * var error = gpuCompute.init();\r\n * if ( error !== null ) {\r\n *\t\tconsole.error( error );\r\n  * }\r\n *\r\n *\r\n * // In each frame...\r\n *\r\n * // Compute!\r\n * gpuCompute.compute();\r\n *\r\n * // Update texture uniforms in your visualization materials with the gpu renderer output\r\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\r\n *\r\n * // Do your rendering\r\n * renderer.render( myScene, myCamera );\r\n *\r\n * -------------\r\n *\r\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\r\n * Note that the shaders can have multiple input textures.\r\n *\r\n * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\r\n * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\r\n *\r\n * var inputTexture = gpuCompute.createTexture();\r\n *\r\n * // Fill in here inputTexture...\r\n *\r\n * myFilter1.uniforms.theTexture.value = inputTexture;\r\n *\r\n * var myRenderTarget = gpuCompute.createRenderTarget();\r\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\r\n *\r\n * var outputRenderTarget = gpuCompute.createRenderTarget();\r\n *\r\n * // Now use the output texture where you want:\r\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\r\n *\r\n * // And compute each frame, before rendering to screen:\r\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\r\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\r\n *\r\n *\r\n *\r\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\r\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\r\n * @param {WebGLRenderer} renderer The renderer\r\n  */\r\n\r\nvar GPUComputationRenderer = function ( sizeX, sizeY, renderer ) {\r\n\r\n\tthis.variables = [];\r\n\r\n\tthis.currentTextureIndex = 0;\r\n\r\n\tvar dataType = FloatType;\r\n\r\n\tvar scene = new Scene();\r\n\r\n\tvar camera = new Camera();\r\n\tcamera.position.z = 1;\r\n\r\n\tvar passThruUniforms = {\r\n\t\tpassThruTexture: { value: null }\r\n\t};\r\n\r\n\tvar passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\r\n\r\n\tvar mesh = new Mesh( new PlaneBufferGeometry( 2, 2 ), passThruShader );\r\n\tscene.add( mesh );\r\n\r\n\r\n\tthis.setDataType = function ( type ) {\r\n\r\n\t\tdataType = type;\r\n\t\treturn this;\r\n\r\n\t};\r\n\r\n\tthis.addVariable = function ( variableName, computeFragmentShader, initialValueTexture ) {\r\n\r\n\t\tvar material = this.createShaderMaterial( computeFragmentShader );\r\n\r\n\t\tvar variable = {\r\n\t\t\tname: variableName,\r\n\t\t\tinitialValueTexture: initialValueTexture,\r\n\t\t\tmaterial: material,\r\n\t\t\tdependencies: null,\r\n\t\t\trenderTargets: [],\r\n\t\t\twrapS: null,\r\n\t\t\twrapT: null,\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t\tmagFilter: NearestFilter\r\n\t\t};\r\n\r\n\t\tthis.variables.push( variable );\r\n\r\n\t\treturn variable;\r\n\r\n\t};\r\n\r\n\tthis.setVariableDependencies = function ( variable, dependencies ) {\r\n\r\n\t\tvariable.dependencies = dependencies;\r\n\r\n\t};\r\n\r\n\tthis.init = function () {\r\n\r\n\t\tif ( renderer.capabilities.isWebGL2 === false && renderer.extensions.has( 'OES_texture_float' ) === false ) {\r\n\r\n\t\t\treturn 'No OES_texture_float support for float textures.';\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\r\n\r\n\t\t\treturn 'No support for vertex shader textures.';\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < this.variables.length; i ++ ) {\r\n\r\n\t\t\tvar variable = this.variables[ i ];\r\n\r\n\t\t\t// Creates rendertargets and initialize them with input texture\r\n\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\r\n\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\r\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\r\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\r\n\r\n\t\t\t// Adds dependencies uniforms to the ShaderMaterial\r\n\t\t\tvar material = variable.material;\r\n\t\t\tvar uniforms = material.uniforms;\r\n\r\n\t\t\tif ( variable.dependencies !== null ) {\r\n\r\n\t\t\t\tfor ( var d = 0; d < variable.dependencies.length; d ++ ) {\r\n\r\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\r\n\r\n\t\t\t\t\tif ( depVar.name !== variable.name ) {\r\n\r\n\t\t\t\t\t\t// Checks if variable exists\r\n\t\t\t\t\t\tvar found = false;\r\n\t\t\t\t\t\tfor ( var j = 0; j < this.variables.length; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\r\n\r\n\t\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( ! found ) {\r\n\r\n\t\t\t\t\t\t\treturn \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\r\n\r\n\t\t\t\t\tmaterial.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.currentTextureIndex = 0;\r\n\r\n\t\treturn null;\r\n\r\n\t};\r\n\r\n\tthis.compute = function () {\r\n\r\n\t\tvar currentTextureIndex = this.currentTextureIndex;\r\n\t\tvar nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\r\n\r\n\t\tfor ( var i = 0, il = this.variables.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar variable = this.variables[ i ];\r\n\r\n\t\t\t// Sets texture dependencies uniforms\r\n\t\t\tif ( variable.dependencies !== null ) {\r\n\r\n\t\t\t\tvar uniforms = variable.material.uniforms;\r\n\t\t\t\tfor ( var d = 0, dl = variable.dependencies.length; d < dl; d ++ ) {\r\n\r\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\r\n\r\n\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Performs the computation for this variable\r\n\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\r\n\r\n\t\t}\r\n\r\n\t\tthis.currentTextureIndex = nextTextureIndex;\r\n\r\n\t};\r\n\r\n\tthis.getCurrentRenderTarget = function ( variable ) {\r\n\r\n\t\treturn variable.renderTargets[ this.currentTextureIndex ];\r\n\r\n\t};\r\n\r\n\tthis.getAlternateRenderTarget = function ( variable ) {\r\n\r\n\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\r\n\r\n\t};\r\n\r\n\tfunction addResolutionDefine( materialShader ) {\r\n\r\n\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + \" )\";\r\n\r\n\t}\r\n\r\n\tthis.addResolutionDefine = addResolutionDefine;\r\n\r\n\r\n\t// The following functions can be used to compute things manually\r\n\r\n\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\r\n\r\n\t\tuniforms = uniforms || {};\r\n\r\n\t\tvar material = new ShaderMaterial( {\r\n\t\t\tuniforms: uniforms,\r\n\t\t\tvertexShader: getPassThroughVertexShader(),\r\n\t\t\tfragmentShader: computeFragmentShader\r\n\t\t} );\r\n\r\n\t\taddResolutionDefine( material );\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n\tthis.createShaderMaterial = createShaderMaterial;\r\n\r\n\tthis.createRenderTarget = function ( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\r\n\r\n\t\tsizeXTexture = sizeXTexture || sizeX;\r\n\t\tsizeYTexture = sizeYTexture || sizeY;\r\n\r\n\t\twrapS = wrapS || ClampToEdgeWrapping;\r\n\t\twrapT = wrapT || ClampToEdgeWrapping;\r\n\r\n\t\tminFilter = minFilter || NearestFilter;\r\n\t\tmagFilter = magFilter || NearestFilter;\r\n\r\n\t\tvar renderTarget = new WebGLRenderTarget( sizeXTexture, sizeYTexture, {\r\n\t\t\twrapS: wrapS,\r\n\t\t\twrapT: wrapT,\r\n\t\t\tminFilter: minFilter,\r\n\t\t\tmagFilter: magFilter,\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\ttype: dataType,\r\n\t\t\tdepthBuffer: false\r\n\t\t} );\r\n\r\n\t\treturn renderTarget;\r\n\r\n\t};\r\n\r\n\tthis.createTexture = function () {\r\n\r\n\t\tvar data = new Float32Array( sizeX * sizeY * 4 );\r\n\t\treturn new DataTexture( data, sizeX, sizeY, RGBAFormat, FloatType );\r\n\r\n\t};\r\n\r\n\tthis.renderTexture = function ( input, output ) {\r\n\r\n\t\t// Takes a texture, and render out in rendertarget\r\n\t\t// input = Texture\r\n\t\t// output = RenderTarget\r\n\r\n\t\tpassThruUniforms.passThruTexture.value = input;\r\n\r\n\t\tthis.doRenderTarget( passThruShader, output );\r\n\r\n\t\tpassThruUniforms.passThruTexture.value = null;\r\n\r\n\t};\r\n\r\n\tthis.doRenderTarget = function ( material, output ) {\r\n\r\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\r\n\r\n\t\tmesh.material = material;\r\n\t\trenderer.setRenderTarget( output );\r\n\t\trenderer.render( scene, camera );\r\n\t\tmesh.material = passThruShader;\r\n\r\n\t\trenderer.setRenderTarget( currentRenderTarget );\r\n\r\n\t};\r\n\r\n\t// Shaders\r\n\r\n\tfunction getPassThroughVertexShader() {\r\n\r\n\t\treturn\t\"void main()\t{\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"\tgl_Position = vec4( position, 1.0 );\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"}\\n\";\r\n\r\n\t}\r\n\r\n\tfunction getPassThroughFragmentShader() {\r\n\r\n\t\treturn\t\"uniform sampler2D passThruTexture;\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"void main() {\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"\tgl_FragColor = texture2D( passThruTexture, uv );\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"}\\n\";\r\n\r\n\t}\r\n\r\n};\r\n\r\nexport { GPUComputationRenderer };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/jsm/misc/GPUComputationRenderer.js","<template>\r\n    <div class=\"webglGpgpuWater-container\">\r\n        <div id=\"info\">\r\n\t\t\t<a href=\"https://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a> - <span id=\"waterSize\"></span> webgl gpgpu water<br/>\r\n\t\t\tMove mouse to disturb water.<br>\r\n\t\t\tPress mouse button to orbit around. 'W' key toggles wireframe.\r\n\t\t</div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport { GUI } from '@/components/jsm/libs/dat.gui.module.js'\r\nimport { GPUComputationRenderer } from '@/components/jsm/misc/GPUComputationRenderer.js'\r\nimport { SimplexNoise } from '@/components/jsm/math/SimplexNoise.js'\r\nexport default {\r\n    data() {\r\n        return {\r\n            heightmapFragmentShader: null,\r\n            smoothFragmentShader: null,\r\n            readWaterLevelFragmentShader: null,\r\n            waterVertexShader: null,\r\n            gui: null,\r\n            WIDTH: 128,\r\n\t\t\t// Water size in system units\r\n\t\t\tBOUNDS: 512,\r\n\t\t\tBOUNDS_HALF: null,\r\n            container: null,\r\n            stats: null,\r\n            camera: null,\r\n            scene: null,\r\n            renderer: null,\r\n\t\t\tmouseMoved: false,\r\n\t\t\tmouseCoords: null,\r\n\t\t\traycaster: null,\r\n\t\t\twaterMesh: null,\r\n\t\t\tmeshRay: null,\r\n\t\t\tgpuCompute: null,\r\n\t\t\theightmapVariable: null,\r\n\t\t\twaterUniforms: null,\r\n\t\t\tsmoothShader: null,\r\n\t\t\treadWaterLevelShader: null,\r\n\t\t\treadWaterLevelRenderTarget: null,\r\n\t\t\treadWaterLevelImage: null,\r\n\t\t\twaterNormal: null,\r\n\t\t\tNUM_SPHERES: 5,\r\n\t\t\tspheres: [],\r\n\t\t\tspheresEnabled: true,\r\n\t\t\tsimplex: null,\r\n        }\r\n    },\r\n    mounted() {\r\n        this.heightmapFragmentShader = `\r\n            #include <common>\r\n\t\t\tuniform vec2 mousePos;\r\n\t\t\tuniform float mouseSize;\r\n\t\t\tuniform float viscosityConstant;\r\n\t\t\tuniform float heightCompensation;\r\n\t\t\tvoid main()\t{\r\n\t\t\t\tvec2 cellSize = 1.0 / resolution.xy;\r\n\t\t\t\tvec2 uv = gl_FragCoord.xy * cellSize;\r\n\t\t\t\t// heightmapValue.x == height from previous frame\r\n\t\t\t\t// heightmapValue.y == height from penultimate frame\r\n\t\t\t\t// heightmapValue.z, heightmapValue.w not used\r\n\t\t\t\tvec4 heightmapValue = texture2D(heightmap, uv);\r\n\t\t\t\t// Get neighbours\r\n\t\t\t\tvec4 north = texture2D(heightmap, uv + vec2(0.0, cellSize.y));\r\n\t\t\t\tvec4 south = texture2D(heightmap, uv + vec2(0.0, - cellSize.y));\r\n\t\t\t\tvec4 east = texture2D(heightmap, uv + vec2(cellSize.x, 0.0));\r\n\t\t\t\tvec4 west = texture2D(heightmap, uv + vec2(- cellSize.x, 0.0));\r\n\t\t\t\t// https://web.archive.org/web/20080618181901/http://freespace.virgin.net/hugo.elias/graphics/x_water.htm\r\n\t\t\t\tfloat newHeight = ((north.x + south.x + east.x + west.x) * 0.5 - heightmapValue.y) * viscosityConstant;\r\n\t\t\t\t// Mouse influence\r\n\t\t\t\tfloat mousePhase = clamp(length((uv - vec2(0.5)) * BOUNDS - vec2(mousePos.x, - mousePos.y)) * PI / mouseSize, 0.0, PI);\r\n\t\t\t\tnewHeight += (cos(mousePhase) + 1.0) * 0.28;\r\n\t\t\t\theightmapValue.y = heightmapValue.x;\r\n\t\t\t\theightmapValue.x = newHeight;\r\n\t\t\t\tgl_FragColor = heightmapValue;\r\n            }`\r\n        this.smoothFragmentShader = `\r\n            uniform sampler2D smoothTexture;\r\n\t\t\tvoid main()\t{\r\n\t\t\t\tvec2 cellSize = 1.0 / resolution.xy;\r\n\t\t\t\tvec2 uv = gl_FragCoord.xy * cellSize;\r\n\t\t\t\t// Computes the mean of texel and 4 neighbours\r\n\t\t\t\tvec4 textureValue = texture2D(smoothTexture, uv);\r\n\t\t\t\ttextureValue += texture2D(smoothTexture, uv + vec2(0.0, cellSize.y));\r\n\t\t\t\ttextureValue += texture2D(smoothTexture, uv + vec2(0.0, - cellSize.y));\r\n\t\t\t\ttextureValue += texture2D(smoothTexture, uv + vec2(cellSize.x, 0.0));\r\n\t\t\t\ttextureValue += texture2D(smoothTexture, uv + vec2(- cellSize.x, 0.0));\r\n\t\t\t\ttextureValue /= 5.0;\r\n\t\t\t\tgl_FragColor = textureValue;\r\n            }`\r\n        this.readWaterLevelFragmentShader = `\r\n            uniform vec2 point1;\r\n\t\t\tuniform sampler2D levelTexture;\r\n\t\t\t// Integer to float conversion from https://stackoverflow.com/questions/17981163/webgl-read-pixels-from-floating-point-render-target\r\n\t\t\tfloat shift_right(float v, float amt) {\r\n\t\t\t\tv = floor(v) + 0.5;\r\n\t\t\t\treturn floor(v / exp2(amt));\r\n\t\t\t}\r\n\t\t\tfloat shift_left(float v, float amt) {\r\n\t\t\t\treturn floor(v * exp2(amt) + 0.5);\r\n\t\t\t}\r\n\t\t\tfloat mask_last(float v, float bits) {\r\n\t\t\t\treturn mod(v, shift_left(1.0, bits));\r\n\t\t\t}\r\n\t\t\tfloat extract_bits(float num, float from, float to) {\r\n\t\t\t\tfrom = floor(from + 0.5); to = floor(to + 0.5);\r\n\t\t\t\treturn mask_last(shift_right(num, from), to - from);\r\n\t\t\t}\r\n\t\t\tvec4 encode_float(float val) {\r\n\t\t\t\tif (val == 0.0) return vec4(0, 0, 0, 0);\r\n\t\t\t\tfloat sign = val > 0.0 ? 0.0 : 1.0;\r\n\t\t\t\tval = abs(val);\r\n\t\t\t\tfloat exponent = floor(log2(val));\r\n\t\t\t\tfloat biased_exponent = exponent + 127.0;\r\n\t\t\t\tfloat fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0;\r\n\t\t\t\tfloat t = biased_exponent / 2.0;\r\n\t\t\t\tfloat last_bit_of_biased_exponent = fract(t) * 2.0;\r\n\t\t\t\tfloat remaining_bits_of_biased_exponent = floor(t);\r\n\t\t\t\tfloat byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0;\r\n\t\t\t\tfloat byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0;\r\n\t\t\t\tfloat byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0;\r\n\t\t\t\tfloat byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;\r\n\t\t\t\treturn vec4(byte4, byte3, byte2, byte1);\r\n\t\t\t}\r\n\t\t\tvoid main()\t{\r\n\t\t\t\tvec2 cellSize = 1.0 / resolution.xy;\r\n\t\t\t\tfloat waterLevel = texture2D(levelTexture, point1).x;\r\n\t\t\t\tvec2 normal = vec2(\r\n\t\t\t\t\t(texture2D(levelTexture, point1 + vec2(- cellSize.x, 0)).x - texture2D(levelTexture, point1 + vec2(cellSize.x, 0)).x) * WIDTH / BOUNDS,\r\n\t\t\t\t\t(texture2D(levelTexture, point1 + vec2(0, - cellSize.y)).x - texture2D(levelTexture, point1 + vec2(0, cellSize.y)).x) * WIDTH / BOUNDS);\r\n\t\t\t\tif (gl_FragCoord.x < 1.5) {\r\n\t\t\t\t\tgl_FragColor = encode_float(waterLevel);\r\n\t\t\t\t} else if (gl_FragCoord.x < 2.5) {\r\n\t\t\t\t\tgl_FragColor = encode_float(normal.x);\r\n\t\t\t\t} else if (gl_FragCoord.x < 3.5) {\r\n\t\t\t\t\tgl_FragColor = encode_float(normal.y);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tgl_FragColor = encode_float(0.0);\r\n\t\t\t\t}\r\n            }`\r\n        this.waterVertexShader = `\r\n            uniform sampler2D heightmap;\r\n\t\t\t#define PHONG\r\n\t\t\tvarying vec3 vViewPosition;\r\n\t\t\t#ifndef FLAT_SHADED\r\n\t\t\t\tvarying vec3 vNormal;\r\n\t\t\t#endif\r\n\t\t\t#include <common>\r\n\t\t\t#include <uv_pars_vertex>\r\n\t\t\t#include <uv2_pars_vertex>\r\n\t\t\t#include <displacementmap_pars_vertex>\r\n\t\t\t#include <envmap_pars_vertex>\r\n\t\t\t#include <color_pars_vertex>\r\n\t\t\t#include <morphtarget_pars_vertex>\r\n\t\t\t#include <skinning_pars_vertex>\r\n\t\t\t#include <shadowmap_pars_vertex>\r\n\t\t\t#include <logdepthbuf_pars_vertex>\r\n\t\t\t#include <clipping_planes_pars_vertex>\r\n\t\t\tvoid main() {\r\n\t\t\t\tvec2 cellSize = vec2(1.0 / WIDTH, 1.0 / WIDTH);\r\n\t\t\t\t#include <uv_vertex>\r\n\t\t\t\t#include <uv2_vertex>\r\n\t\t\t\t#include <color_vertex>\r\n\t\t\t\t// # include <beginnormal_vertex>\r\n\t\t\t\t// Compute normal from heightmap\r\n\t\t\t\tvec3 objectNormal = vec3(\r\n\t\t\t\t\t(texture2D(heightmap, uv + vec2(- cellSize.x, 0)).x - texture2D(heightmap, uv + vec2(cellSize.x, 0)).x) * WIDTH / BOUNDS,\r\n\t\t\t\t\t(texture2D(heightmap, uv + vec2(0, - cellSize.y)).x - texture2D(heightmap, uv + vec2(0, cellSize.y)).x) * WIDTH / BOUNDS,\r\n\t\t\t\t\t1.0);\r\n\t\t\t\t//<beginnormal_vertex>\r\n\t\t\t\t#include <morphnormal_vertex>\r\n\t\t\t\t#include <skinbase_vertex>\r\n\t\t\t\t#include <skinnormal_vertex>\r\n\t\t\t\t#include <defaultnormal_vertex>\r\n\t\t\t#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\t\t\t\tvNormal = normalize(transformedNormal);\r\n\t\t\t#endif\r\n\t\t\t\t//# include <begin_vertex>\r\n\t\t\t\tfloat heightValue = texture2D(heightmap, uv).x;\r\n\t\t\t\tvec3 transformed = vec3(position.x, position.y, heightValue);\r\n\t\t\t\t//<begin_vertex>\r\n\t\t\t\t#include <morphtarget_vertex>\r\n\t\t\t\t#include <skinning_vertex>\r\n\t\t\t\t#include <displacementmap_vertex>\r\n\t\t\t\t#include <project_vertex>\r\n\t\t\t\t#include <logdepthbuf_vertex>\r\n\t\t\t\t#include <clipping_planes_vertex>\r\n\t\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\t#include <worldpos_vertex>\r\n\t\t\t\t#include <envmap_vertex>\r\n\t\t\t\t#include <shadowmap_vertex>\r\n            }`\r\n        this.BOUNDS_HALF = this.BOUNDS * 0.5\r\n        this.mouseCoords = new this.$THREE.Vector2()\r\n        this.raycaster = new this.$THREE.Raycaster()\r\n        this.waterNormal = new this.$THREE.Vector3()\r\n        this.simplex = new SimplexNoise()\r\n        this.init()\r\n\t\tthis.animate()\r\n    },\r\n    beforeDestroy() {\r\n        this.gui.destroy()\r\n    },\r\n    methods: {\r\n        init() {\r\n            this.container = document.createElement('div')\r\n            document.getElementsByClassName('webglGpgpuWater-container')[0].appendChild(this.container)\r\n            this.camera = new this.$THREE.PerspectiveCamera(75, this.$webglInnerWidth / window.innerHeight, 1, 3000)\r\n            this.camera.position.set(0, 200, 350)\r\n            this.camera.lookAt(0, 0, 0)\r\n            this.scene = new this.$THREE.Scene()\r\n            var sun = new this.$THREE.DirectionalLight(0xFFFFFF, 1.0)\r\n            sun.position.set(300, 400, 175)\r\n            this.scene.add(sun)\r\n            var sun2 = new this.$THREE.DirectionalLight(0x40A040, 0.6)\r\n            sun2.position.set(- 100, 350, - 200)\r\n            this.scene.add(sun2)\r\n            this.renderer = new this.$THREE.WebGLRenderer()\r\n            this.renderer.setPixelRatio(window.devicePixelRatio)\r\n            this.renderer.setSize(this.$webglInnerWidth, window.innerHeight)\r\n            this.container.appendChild(this.renderer.domElement)\r\n            this.stats = new this.$Stats()\r\n            this.stats.dom.style.left = '280px'\r\n            this.container.appendChild(this.stats.dom)\r\n            this.container.style.touchAction = 'none'\r\n            this.container.addEventListener('pointermove', this.onPointerMove, false)\r\n            document.addEventListener('keydown', (event) => {\r\n                // W Pressed: Toggle wireframe\r\n                if (event.keyCode === 87) {\r\n                    this.waterMesh.material.wireframe = ! this.waterMesh.material.wireframe\r\n                    this.waterMesh.material.needsUpdate = true\r\n                }\r\n            }, false)\r\n            window.addEventListener('resize', this.onWindowResize, false)\r\n            this.gui = new GUI()\r\n            var effectController = {\r\n                mouseSize: 20.0,\r\n                viscosity: 0.98,\r\n                spheresEnabled: this.spheresEnabled\r\n            }\r\n            var valuesChanger = () => {\r\n                this.heightmapVariable.material.uniforms[\"mouseSize\"].value = effectController.mouseSize\r\n                this.heightmapVariable.material.uniforms[\"viscosityConstant\"].value = effectController.viscosity\r\n                this.spheresEnabled = effectController.spheresEnabled\r\n                for (var i = 0; i < this.NUM_SPHERES; i ++) {\r\n                    if (this.spheres[i]) {\r\n                        this.spheres[i].visible = this.spheresEnabled\r\n                    }\r\n                }\r\n            }\r\n            this.gui.add(effectController, \"mouseSize\", 1.0, 100.0, 1.0).onChange(valuesChanger)\r\n            this.gui.add(effectController, \"viscosity\", 0.9, 0.999, 0.001).onChange(valuesChanger)\r\n            this.gui.add(effectController, \"spheresEnabled\", 0, 1, 1).onChange(valuesChanger)\r\n            var buttonSmooth = {\r\n                smoothWater: () => {\r\n                    this.smoothWater()\r\n                }\r\n            }\r\n            this.gui.add(buttonSmooth, 'smoothWater')\r\n            this.initWater()\r\n            this.createSpheres()\r\n            valuesChanger()\r\n        },\r\n        initWater() {\r\n            var materialColor = 0x0040C0\r\n            var geometry = new this.$THREE.PlaneBufferGeometry(this.BOUNDS, this.BOUNDS, this.WIDTH - 1, this.WIDTH - 1)\r\n            // material: make a this.$THREE.ShaderMaterial clone of this.$THREE.MeshPhongMaterial, with customized vertex shader\r\n            var material = new this.$THREE.ShaderMaterial({\r\n                uniforms: this.$THREE.UniformsUtils.merge([\r\n                    this.$THREE.ShaderLib['phong'].uniforms,\r\n                    {\r\n                        \"heightmap\": { value: null }\r\n                    }\r\n            ]),\r\n                vertexShader: this.waterVertexShader,\r\n                fragmentShader: this.$THREE.ShaderChunk['meshphong_frag']\r\n            })\r\n            material.lights = true\r\n            // Material attributes from this.$THREE.MeshPhongMaterial\r\n            material.color = new this.$THREE.Color(materialColor)\r\n            material.specular = new this.$THREE.Color(0x111111)\r\n            material.shininess = 50\r\n            // Sets the uniforms with the material values\r\n            material.uniforms[\"diffuse\"].value = material.color\r\n            material.uniforms[\"specular\"].value = material.specular\r\n            material.uniforms[\"shininess\"].value = Math.max(material.shininess, 1e-4)\r\n            material.uniforms[\"opacity\"].value = material.opacity\r\n            // Defines\r\n            material.defines.WIDTH = this.WIDTH.toFixed(1)\r\n            material.defines.BOUNDS = this.BOUNDS.toFixed(1)\r\n            this.waterUniforms = material.uniforms\r\n            this.waterMesh = new this.$THREE.Mesh(geometry, material)\r\n            this.waterMesh.rotation.x = - Math.PI / 2\r\n            this.waterMesh.matrixAutoUpdate = false\r\n            this.waterMesh.updateMatrix()\r\n            this.scene.add(this.waterMesh)\r\n            // this.$THREE.Mesh just for mouse raycasting\r\n            var geometryRay = new this.$THREE.PlaneBufferGeometry(this.BOUNDS, this.BOUNDS, 1, 1)\r\n            this.meshRay = new this.$THREE.Mesh(geometryRay, new this.$THREE.MeshBasicMaterial({ color: 0xFFFFFF, visible: false }))\r\n            this.meshRay.rotation.x = - Math.PI / 2\r\n            this.meshRay.matrixAutoUpdate = false\r\n            this.meshRay.updateMatrix()\r\n            this.scene.add(this.meshRay)\r\n            // Creates the gpu computation class and sets it up\r\n            this.gpuCompute = new GPUComputationRenderer(this.WIDTH, this.WIDTH, this.renderer)\r\n            if (this.isSafari()) {\r\n                this.gpuCompute.setDataType(this.$THREE.HalfFloatType)\r\n            }\r\n            var heightmap0 = this.gpuCompute.createTexture()\r\n            this.fillTexture(heightmap0)\r\n            this.heightmapVariable = this.gpuCompute.addVariable(\"heightmap\", this.heightmapFragmentShader, heightmap0)\r\n            this.gpuCompute.setVariableDependencies(this.heightmapVariable, [this.heightmapVariable])\r\n            this.heightmapVariable.material.uniforms[\"mousePos\"] = { value: new this.$THREE.Vector2(10000, 10000) }\r\n            this.heightmapVariable.material.uniforms[\"mouseSize\"] = { value: 20.0 }\r\n            this.heightmapVariable.material.uniforms[\"viscosityConstant\"] = { value: 0.98 }\r\n            this.heightmapVariable.material.uniforms[\"heightCompensation\"] = { value: 0 }\r\n            this.heightmapVariable.material.defines.BOUNDS = this.BOUNDS.toFixed(1)\r\n            var error = this.gpuCompute.init()\r\n            if (error !== null) {\r\n                console.error(error)\r\n            }\r\n            // Create compute shader to smooth the water surface and velocity\r\n            this.smoothShader = this.gpuCompute.createShaderMaterial(this.smoothFragmentShader, { smoothTexture: { value: null } })\r\n            // Create compute shader to read water level\r\n            this.readWaterLevelShader = this.gpuCompute.createShaderMaterial(this.readWaterLevelFragmentShader, {\r\n                point1: { value: new this.$THREE.Vector2() },\r\n                levelTexture: { value: null }\r\n            })\r\n            this.readWaterLevelShader.defines.WIDTH = this.WIDTH.toFixed(1)\r\n            this.readWaterLevelShader.defines.BOUNDS = this.BOUNDS.toFixed(1)\r\n            // Create a 4x1 pixel image and a render target (Uint8, 4 channels, 1 byte per channel) to read water height and orientation\r\n            this.readWaterLevelImage = new Uint8Array(4 * 1 * 4)\r\n            this.readWaterLevelRenderTarget = new this.$THREE.WebGLRenderTarget(4, 1, {\r\n                wrapS: this.$THREE.ClampToEdgeWrapping,\r\n                wrapT: this.$THREE.ClampToEdgeWrapping,\r\n                minFilter: this.$THREE.NearestFilter,\r\n                magFilter: this.$THREE.NearestFilter,\r\n                format: this.$THREE.RGBAFormat,\r\n                type: this.$THREE.UnsignedByteType,\r\n                depthBuffer: false\r\n            })\r\n        },\r\n        isSafari() {\r\n            return !! navigator.userAgent.match(/Safari/i) && ! navigator.userAgent.match(/Chrome/i)\r\n        },\r\n        fillTexture(texture) {\r\n            var waterMaxHeight = 10\r\n            var that = this\r\n            function noise(x, y) {\r\n                var multR = waterMaxHeight\r\n                var mult = 0.025\r\n                var r = 0\r\n                for (var i = 0; i < 15; i ++) {\r\n                    r += multR * that.simplex.noise(x * mult, y * mult)\r\n                    multR *= 0.53 + 0.025 * i\r\n                    mult *= 1.25\r\n                }\r\n                return r\r\n            }\r\n            var pixels = texture.image.data\r\n            var p = 0\r\n            for (var j = 0; j < this.WIDTH; j ++) {\r\n                for (var i = 0; i < this.WIDTH; i ++) {\r\n                    var x = i * 128 / this.WIDTH\r\n                    var y = j * 128 / this.WIDTH\r\n                    pixels[p + 0] = noise(x, y)\r\n                    pixels[p + 1] = pixels[p + 0]\r\n                    pixels[p + 2] = 0\r\n                    pixels[p + 3] = 1\r\n                    p += 4\r\n                }\r\n            }\r\n        },\r\n        smoothWater() {\r\n            var currentRenderTarget = this.gpuCompute.getCurrentRenderTarget(this.heightmapVariable)\r\n            var alternateRenderTarget = this.gpuCompute.getAlternateRenderTarget(this.heightmapVariable)\r\n            for (var i = 0; i < 10; i ++) {\r\n                this.smoothShader.uniforms[\"smoothTexture\"].value = currentRenderTarget.texture\r\n                this.gpuCompute.doRenderTarget(this.smoothShader, alternateRenderTarget)\r\n                this.smoothShader.uniforms[\"smoothTexture\"].value = alternateRenderTarget.texture\r\n                this.gpuCompute.doRenderTarget(this.smoothShader, currentRenderTarget)\r\n            }\r\n        },\r\n        createSpheres() {\r\n            var sphereTemplate = new this.$THREE.Mesh(new this.$THREE.SphereBufferGeometry(4, 24, 12), new this.$THREE.MeshPhongMaterial({ color: 0xFFFF00 }))\r\n            for (var i = 0; i < this.NUM_SPHERES; i ++) {\r\n                var sphere = sphereTemplate\r\n                if (i < this.NUM_SPHERES - 1) {\r\n                    sphere = sphereTemplate.clone()\r\n                }\r\n                sphere.position.x = (Math.random() - 0.5) * this.BOUNDS * 0.7\r\n                sphere.position.z = (Math.random() - 0.5) * this.BOUNDS * 0.7\r\n                sphere.userData.velocity = new this.$THREE.Vector3()\r\n                this.scene.add(sphere)\r\n                this.spheres[i] = sphere\r\n            }\r\n\r\n        },\r\n        sphereDynamics() {\r\n            var currentRenderTarget = this.gpuCompute.getCurrentRenderTarget(this.heightmapVariable)\r\n            this.readWaterLevelShader.uniforms[\"levelTexture\"].value = currentRenderTarget.texture\r\n            for (var i = 0; i < this.NUM_SPHERES; i ++) {\r\n                var sphere = this.spheres[i]\r\n                if (sphere) {\r\n                    // Read water level and orientation\r\n                    var u = 0.5 * sphere.position.x / this.BOUNDS_HALF + 0.5\r\n                    var v = 1 - (0.5 * sphere.position.z / this.BOUNDS_HALF + 0.5)\r\n                    this.readWaterLevelShader.uniforms[\"point1\"].value.set(u, v)\r\n                    this.gpuCompute.doRenderTarget(this.readWaterLevelShader, this.readWaterLevelRenderTarget)\r\n                    this.renderer.readRenderTargetPixels(this.readWaterLevelRenderTarget, 0, 0, 4, 1, this.readWaterLevelImage)\r\n                    var pixels = new Float32Array(this.readWaterLevelImage.buffer)\r\n                    // Get orientation\r\n                    this.waterNormal.set(pixels[1], 0, - pixels[2])\r\n                    var pos = sphere.position\r\n                    // Set height\r\n                    pos.y = pixels[0]\r\n                    // Move sphere\r\n                    this.waterNormal.multiplyScalar(0.1)\r\n                    sphere.userData.velocity.add(this.waterNormal)\r\n                    sphere.userData.velocity.multiplyScalar(0.998)\r\n                    pos.add(sphere.userData.velocity)\r\n                    if (pos.x < - this.BOUNDS_HALF) {\r\n                        pos.x = - this.BOUNDS_HALF + 0.001\r\n                        sphere.userData.velocity.x *= - 0.3\r\n                    } else if (pos.x > this.BOUNDS_HALF) {\r\n                        pos.x = this.BOUNDS_HALF - 0.001\r\n                        sphere.userData.velocity.x *= - 0.3\r\n                    }\r\n                    if (pos.z < - this.BOUNDS_HALF) {\r\n                        pos.z = - this.BOUNDS_HALF + 0.001\r\n                        sphere.userData.velocity.z *= - 0.3\r\n                    } else if (pos.z > this.BOUNDS_HALF) {\r\n                        pos.z = this.BOUNDS_HALF - 0.001\r\n                        sphere.userData.velocity.z *= - 0.3\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        onWindowResize() {\r\n            this.$onWindowResize(this.camera, this.renderer)\r\n        },\r\n        setMouseCoords(x, y) {\r\n            this.mouseCoords.set((x / this.renderer.domElement.clientWidth) * 2 - 1, - (y / this.renderer.domElement.clientHeight) * 2 + 1)\r\n            this.mouseMoved = true\r\n        },\r\n        onPointerMove(event) {\r\n            if (event.isPrimary === false) return\r\n            this.setMouseCoords(event.clientX, event.clientY)\r\n        },\r\n        animate() {\r\n            requestAnimationFrame(this.animate)\r\n            this.render()\r\n            this.stats.update()\r\n        },\r\n        render() {\r\n            // Set uniforms: mouse interaction\r\n            var uniforms = this.heightmapVariable.material.uniforms\r\n            if (this.mouseMoved) {\r\n                this.raycaster.setFromCamera(this.mouseCoords, this.camera)\r\n                var intersects = this.raycaster.intersectObject(this.meshRay)\r\n                if (intersects.length > 0) {\r\n                    var point = intersects[ 0 ].point\r\n                    uniforms[ \"mousePos\" ].value.set(point.x, point.z)\r\n                } else {\r\n                    uniforms[ \"mousePos\" ].value.set(10000, 10000)\r\n                }\r\n                this.mouseMoved = false\r\n            } else {\r\n                uniforms[ \"mousePos\" ].value.set(10000, 10000)\r\n            }\r\n            // Do the gpu computation\r\n            this.gpuCompute.compute()\r\n            if (this.spheresEnabled) {\r\n                this.sphereDynamics()\r\n            }\r\n            // Get compute output in custom uniform\r\n            this.waterUniforms[\"heightmap\"].value = this.gpuCompute.getCurrentRenderTarget(this.heightmapVariable).texture\r\n            // Render\r\n            this.renderer.render(this.scene, this.camera)\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n.webglGpgpuWater-container {\r\n    width: 100%;\r\n}\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// src/views/gpgpu/webglGpgpuWater.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"webglGpgpuWater-container\"},[_c('div',{attrs:{\"id\":\"info\"}},[_c('a',{attrs:{\"href\":\"https://threejs.org\",\"target\":\"_blank\",\"rel\":\"noopener\"}},[_vm._v(\"three.js\")]),_vm._v(\" - \"),_c('span',{attrs:{\"id\":\"waterSize\"}}),_vm._v(\" webgl gpgpu water\"),_c('br'),_vm._v(\"\\n\\t\\t\\tMove mouse to disturb water.\"),_c('br'),_vm._v(\"\\n\\t\\t\\tPress mouse button to orbit around. 'W' key toggles wireframe.\\n\\t\\t\")])])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-29176310\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/views/gpgpu/webglGpgpuWater.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true,\\\"publicPath\\\":\\\"../../\\\"}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-29176310\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./webglGpgpuWater.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./webglGpgpuWater.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./webglGpgpuWater.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-29176310\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./webglGpgpuWater.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-29176310\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/gpgpu/webglGpgpuWater.vue\n// module id = null\n// module chunks = "],"sourceRoot":""}