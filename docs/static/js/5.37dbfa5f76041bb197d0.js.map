{"version":3,"sources":["webpack:///./src/components/jsm/misc/GPUComputationRenderer.js","webpack:///src/views/gpgpu/webglGpgpuWater.vue","webpack:///./src/views/gpgpu/webglGpgpuWater.vue?7168","webpack:///./src/views/gpgpu/webglGpgpuWater.vue","webpack:///./src/components/jsm/math/SimplexNoise.js"],"names":["__webpack_require__","d","__webpack_exports__","GPUComputationRenderer","__WEBPACK_IMPORTED_MODULE_0__components_build_three_module_js__","sizeX","sizeY","renderer","this","variables","currentTextureIndex","dataType","FloatType","scene","Scene","camera","Camera","position","z","passThruUniforms","passThruTexture","value","passThruShader","createShaderMaterial","mesh","Mesh","PlaneBufferGeometry","addResolutionDefine","materialShader","defines","resolution","toFixed","computeFragmentShader","uniforms","material","ShaderMaterial","vertexShader","fragmentShader","add","setDataType","type","addVariable","variableName","initialValueTexture","variable","name","dependencies","renderTargets","wrapS","wrapT","minFilter","NearestFilter","magFilter","push","setVariableDependencies","init","capabilities","isWebGL2","extensions","has","maxVertexTextures","i","length","createRenderTarget","renderTexture","depVar","found","j","compute","nextTextureIndex","il","dl","texture","doRenderTarget","getCurrentRenderTarget","getAlternateRenderTarget","sizeXTexture","sizeYTexture","ClampToEdgeWrapping","WebGLRenderTarget","format","RGBAFormat","depthBuffer","createTexture","data","Float32Array","DataTexture","input","output","currentRenderTarget","getRenderTarget","setRenderTarget","render","webglGpgpuWater","heightmapFragmentShader","smoothFragmentShader","readWaterLevelFragmentShader","waterVertexShader","gui","WIDTH","BOUNDS","BOUNDS_HALF","container","stats","mouseMoved","mouseCoords","raycaster","waterMesh","meshRay","gpuCompute","heightmapVariable","waterUniforms","smoothShader","readWaterLevelShader","readWaterLevelRenderTarget","readWaterLevelImage","waterNormal","NUM_SPHERES","spheres","spheresEnabled","simplex","mounted","$THREE","Vector2","Raycaster","Vector3","SimplexNoise","animate","beforeDestroy","destroy","methods","_this","document","createElement","getElementsByClassName","appendChild","PerspectiveCamera","$webglInnerWidth","window","innerHeight","set","lookAt","sun","DirectionalLight","sun2","WebGLRenderer","setPixelRatio","devicePixelRatio","setSize","domElement","$Stats","dom","style","left","touchAction","addEventListener","onPointerMove","event","keyCode","wireframe","needsUpdate","onWindowResize","dat_gui_module","effectController","mouseSize","viscosity","valuesChanger","visible","onChange","buttonSmooth","smoothWater","initWater","createSpheres","geometry","UniformsUtils","merge","ShaderLib","heightmap","ShaderChunk","lights","color","Color","specular","shininess","Math","max","opacity","rotation","x","PI","matrixAutoUpdate","updateMatrix","geometryRay","MeshBasicMaterial","isSafari","HalfFloatType","heightmap0","fillTexture","error","console","smoothTexture","point1","levelTexture","Uint8Array","UnsignedByteType","navigator","userAgent","match","waterMaxHeight","that","noise","y","multR","mult","r","pixels","image","p","alternateRenderTarget","sphereTemplate","SphereBufferGeometry","MeshPhongMaterial","sphere","clone","random","userData","velocity","sphereDynamics","u","v","readRenderTargetPixels","buffer","pos","multiplyScalar","$onWindowResize","setMouseCoords","clientWidth","clientHeight","isPrimary","clientX","clientY","requestAnimationFrame","update","setFromCamera","intersects","intersectObject","point","gpgpu_webglGpgpuWater","$createElement","_self","_c","_m","staticRenderFns","_h","staticClass","attrs","id","href","target","rel","_v","Component","normalizeComponent","ssrContext","undefined","grad3","grad4","floor","perm","prototype","dot","g","dot3","dot4","w","xin","yin","i1","j1","s","sqrt","G2","t","x0","y0","x1","y1","x2","y2","ii","jj","gi0","gi1","gi2","t0","t1","t2","noise3d","zin","k1","i2","j2","k2","k","G3","z0","z1","z2","x3","y3","z3","kk","gi3","t3","noise4d","l1","l2","i3","j3","k3","l3","F4","G4","l","w0","c","w1","w2","w3","x4","y4","z4","w4","ll","gi4","t4"],"mappings":"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","file":"static/js/5.37dbfa5f76041bb197d0.js","sourcesContent":["import {\r\n\tCamera,\r\n\tClampToEdgeWrapping,\r\n\tDataTexture,\r\n\tFloatType,\r\n\tMesh,\r\n\tNearestFilter,\r\n\tPlaneBufferGeometry,\r\n\tRGBAFormat,\r\n\tScene,\r\n\tShaderMaterial,\r\n\tWebGLRenderTarget\r\n} from \"@/components/build/three.module.js\";\r\n\r\n/**\r\n * GPUComputationRenderer, based on SimulationRenderer by zz85\r\n *\r\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\r\n * for each compute element (texel)\r\n *\r\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\r\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\r\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\r\n *\r\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\r\n * as inputs to render the textures of the next frame.\r\n *\r\n * The render targets of the variables can be used as input textures for your visualization shaders.\r\n *\r\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\r\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\r\n *\r\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\r\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\r\n *\r\n * -------------\r\n *\r\n * Basic use:\r\n *\r\n * // Initialization...\r\n *\r\n * // Create computation renderer\r\n * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\r\n *\r\n * // Create initial state float textures\r\n * var pos0 = gpuCompute.createTexture();\r\n * var vel0 = gpuCompute.createTexture();\r\n * // and fill in here the texture data...\r\n *\r\n * // Add texture variables\r\n * var velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\r\n * var posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\r\n *\r\n * // Add variable dependencies\r\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\r\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\r\n *\r\n * // Add custom uniforms\r\n * velVar.material.uniforms.time = { value: 0.0 };\r\n *\r\n * // Check for completeness\r\n * var error = gpuCompute.init();\r\n * if ( error !== null ) {\r\n *\t\tconsole.error( error );\r\n  * }\r\n *\r\n *\r\n * // In each frame...\r\n *\r\n * // Compute!\r\n * gpuCompute.compute();\r\n *\r\n * // Update texture uniforms in your visualization materials with the gpu renderer output\r\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\r\n *\r\n * // Do your rendering\r\n * renderer.render( myScene, myCamera );\r\n *\r\n * -------------\r\n *\r\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\r\n * Note that the shaders can have multiple input textures.\r\n *\r\n * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\r\n * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\r\n *\r\n * var inputTexture = gpuCompute.createTexture();\r\n *\r\n * // Fill in here inputTexture...\r\n *\r\n * myFilter1.uniforms.theTexture.value = inputTexture;\r\n *\r\n * var myRenderTarget = gpuCompute.createRenderTarget();\r\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\r\n *\r\n * var outputRenderTarget = gpuCompute.createRenderTarget();\r\n *\r\n * // Now use the output texture where you want:\r\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\r\n *\r\n * // And compute each frame, before rendering to screen:\r\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\r\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\r\n *\r\n *\r\n *\r\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\r\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\r\n * @param {WebGLRenderer} renderer The renderer\r\n  */\r\n\r\nvar GPUComputationRenderer = function ( sizeX, sizeY, renderer ) {\r\n\r\n\tthis.variables = [];\r\n\r\n\tthis.currentTextureIndex = 0;\r\n\r\n\tvar dataType = FloatType;\r\n\r\n\tvar scene = new Scene();\r\n\r\n\tvar camera = new Camera();\r\n\tcamera.position.z = 1;\r\n\r\n\tvar passThruUniforms = {\r\n\t\tpassThruTexture: { value: null }\r\n\t};\r\n\r\n\tvar passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\r\n\r\n\tvar mesh = new Mesh( new PlaneBufferGeometry( 2, 2 ), passThruShader );\r\n\tscene.add( mesh );\r\n\r\n\r\n\tthis.setDataType = function ( type ) {\r\n\r\n\t\tdataType = type;\r\n\t\treturn this;\r\n\r\n\t};\r\n\r\n\tthis.addVariable = function ( variableName, computeFragmentShader, initialValueTexture ) {\r\n\r\n\t\tvar material = this.createShaderMaterial( computeFragmentShader );\r\n\r\n\t\tvar variable = {\r\n\t\t\tname: variableName,\r\n\t\t\tinitialValueTexture: initialValueTexture,\r\n\t\t\tmaterial: material,\r\n\t\t\tdependencies: null,\r\n\t\t\trenderTargets: [],\r\n\t\t\twrapS: null,\r\n\t\t\twrapT: null,\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t\tmagFilter: NearestFilter\r\n\t\t};\r\n\r\n\t\tthis.variables.push( variable );\r\n\r\n\t\treturn variable;\r\n\r\n\t};\r\n\r\n\tthis.setVariableDependencies = function ( variable, dependencies ) {\r\n\r\n\t\tvariable.dependencies = dependencies;\r\n\r\n\t};\r\n\r\n\tthis.init = function () {\r\n\r\n\t\tif ( renderer.capabilities.isWebGL2 === false && renderer.extensions.has( 'OES_texture_float' ) === false ) {\r\n\r\n\t\t\treturn 'No OES_texture_float support for float textures.';\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\r\n\r\n\t\t\treturn 'No support for vertex shader textures.';\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < this.variables.length; i ++ ) {\r\n\r\n\t\t\tvar variable = this.variables[ i ];\r\n\r\n\t\t\t// Creates rendertargets and initialize them with input texture\r\n\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\r\n\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\r\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\r\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\r\n\r\n\t\t\t// Adds dependencies uniforms to the ShaderMaterial\r\n\t\t\tvar material = variable.material;\r\n\t\t\tvar uniforms = material.uniforms;\r\n\r\n\t\t\tif ( variable.dependencies !== null ) {\r\n\r\n\t\t\t\tfor ( var d = 0; d < variable.dependencies.length; d ++ ) {\r\n\r\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\r\n\r\n\t\t\t\t\tif ( depVar.name !== variable.name ) {\r\n\r\n\t\t\t\t\t\t// Checks if variable exists\r\n\t\t\t\t\t\tvar found = false;\r\n\t\t\t\t\t\tfor ( var j = 0; j < this.variables.length; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\r\n\r\n\t\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( ! found ) {\r\n\r\n\t\t\t\t\t\t\treturn \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\r\n\r\n\t\t\t\t\tmaterial.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.currentTextureIndex = 0;\r\n\r\n\t\treturn null;\r\n\r\n\t};\r\n\r\n\tthis.compute = function () {\r\n\r\n\t\tvar currentTextureIndex = this.currentTextureIndex;\r\n\t\tvar nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\r\n\r\n\t\tfor ( var i = 0, il = this.variables.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar variable = this.variables[ i ];\r\n\r\n\t\t\t// Sets texture dependencies uniforms\r\n\t\t\tif ( variable.dependencies !== null ) {\r\n\r\n\t\t\t\tvar uniforms = variable.material.uniforms;\r\n\t\t\t\tfor ( var d = 0, dl = variable.dependencies.length; d < dl; d ++ ) {\r\n\r\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\r\n\r\n\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Performs the computation for this variable\r\n\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\r\n\r\n\t\t}\r\n\r\n\t\tthis.currentTextureIndex = nextTextureIndex;\r\n\r\n\t};\r\n\r\n\tthis.getCurrentRenderTarget = function ( variable ) {\r\n\r\n\t\treturn variable.renderTargets[ this.currentTextureIndex ];\r\n\r\n\t};\r\n\r\n\tthis.getAlternateRenderTarget = function ( variable ) {\r\n\r\n\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\r\n\r\n\t};\r\n\r\n\tfunction addResolutionDefine( materialShader ) {\r\n\r\n\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + \" )\";\r\n\r\n\t}\r\n\r\n\tthis.addResolutionDefine = addResolutionDefine;\r\n\r\n\r\n\t// The following functions can be used to compute things manually\r\n\r\n\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\r\n\r\n\t\tuniforms = uniforms || {};\r\n\r\n\t\tvar material = new ShaderMaterial( {\r\n\t\t\tuniforms: uniforms,\r\n\t\t\tvertexShader: getPassThroughVertexShader(),\r\n\t\t\tfragmentShader: computeFragmentShader\r\n\t\t} );\r\n\r\n\t\taddResolutionDefine( material );\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n\tthis.createShaderMaterial = createShaderMaterial;\r\n\r\n\tthis.createRenderTarget = function ( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\r\n\r\n\t\tsizeXTexture = sizeXTexture || sizeX;\r\n\t\tsizeYTexture = sizeYTexture || sizeY;\r\n\r\n\t\twrapS = wrapS || ClampToEdgeWrapping;\r\n\t\twrapT = wrapT || ClampToEdgeWrapping;\r\n\r\n\t\tminFilter = minFilter || NearestFilter;\r\n\t\tmagFilter = magFilter || NearestFilter;\r\n\r\n\t\tvar renderTarget = new WebGLRenderTarget( sizeXTexture, sizeYTexture, {\r\n\t\t\twrapS: wrapS,\r\n\t\t\twrapT: wrapT,\r\n\t\t\tminFilter: minFilter,\r\n\t\t\tmagFilter: magFilter,\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\ttype: dataType,\r\n\t\t\tdepthBuffer: false\r\n\t\t} );\r\n\r\n\t\treturn renderTarget;\r\n\r\n\t};\r\n\r\n\tthis.createTexture = function () {\r\n\r\n\t\tvar data = new Float32Array( sizeX * sizeY * 4 );\r\n\t\treturn new DataTexture( data, sizeX, sizeY, RGBAFormat, FloatType );\r\n\r\n\t};\r\n\r\n\tthis.renderTexture = function ( input, output ) {\r\n\r\n\t\t// Takes a texture, and render out in rendertarget\r\n\t\t// input = Texture\r\n\t\t// output = RenderTarget\r\n\r\n\t\tpassThruUniforms.passThruTexture.value = input;\r\n\r\n\t\tthis.doRenderTarget( passThruShader, output );\r\n\r\n\t\tpassThruUniforms.passThruTexture.value = null;\r\n\r\n\t};\r\n\r\n\tthis.doRenderTarget = function ( material, output ) {\r\n\r\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\r\n\r\n\t\tmesh.material = material;\r\n\t\trenderer.setRenderTarget( output );\r\n\t\trenderer.render( scene, camera );\r\n\t\tmesh.material = passThruShader;\r\n\r\n\t\trenderer.setRenderTarget( currentRenderTarget );\r\n\r\n\t};\r\n\r\n\t// Shaders\r\n\r\n\tfunction getPassThroughVertexShader() {\r\n\r\n\t\treturn\t\"void main()\t{\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"\tgl_Position = vec4( position, 1.0 );\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"}\\n\";\r\n\r\n\t}\r\n\r\n\tfunction getPassThroughFragmentShader() {\r\n\r\n\t\treturn\t\"uniform sampler2D passThruTexture;\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"void main() {\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"\tgl_FragColor = texture2D( passThruTexture, uv );\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"}\\n\";\r\n\r\n\t}\r\n\r\n};\r\n\r\nexport { GPUComputationRenderer };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/jsm/misc/GPUComputationRenderer.js","<template>\r\n    <div class=\"webglGpgpuWater-container\">\r\n        <div id=\"info\">\r\n\t\t\t<a href=\"https://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a> - <span id=\"waterSize\"></span> webgl gpgpu water<br/>\r\n\t\t\tMove mouse to disturb water.<br>\r\n\t\t\tPress mouse button to orbit around. 'W' key toggles wireframe.\r\n\t\t</div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport { GUI } from '@/components/jsm/libs/dat.gui.module.js'\r\nimport { GPUComputationRenderer } from '@/components/jsm/misc/GPUComputationRenderer.js'\r\nimport { SimplexNoise } from '@/components/jsm/math/SimplexNoise.js'\r\nexport default {\r\n    data() {\r\n        return {\r\n            heightmapFragmentShader: null,\r\n            smoothFragmentShader: null,\r\n            readWaterLevelFragmentShader: null,\r\n            waterVertexShader: null,\r\n            gui: null,\r\n            WIDTH: 128,\r\n\t\t\t// Water size in system units\r\n\t\t\tBOUNDS: 512,\r\n\t\t\tBOUNDS_HALF: null,\r\n            container: null,\r\n            stats: null,\r\n            camera: null,\r\n            scene: null,\r\n            renderer: null,\r\n\t\t\tmouseMoved: false,\r\n\t\t\tmouseCoords: null,\r\n\t\t\traycaster: null,\r\n\t\t\twaterMesh: null,\r\n\t\t\tmeshRay: null,\r\n\t\t\tgpuCompute: null,\r\n\t\t\theightmapVariable: null,\r\n\t\t\twaterUniforms: null,\r\n\t\t\tsmoothShader: null,\r\n\t\t\treadWaterLevelShader: null,\r\n\t\t\treadWaterLevelRenderTarget: null,\r\n\t\t\treadWaterLevelImage: null,\r\n\t\t\twaterNormal: null,\r\n\t\t\tNUM_SPHERES: 5,\r\n\t\t\tspheres: [],\r\n\t\t\tspheresEnabled: true,\r\n\t\t\tsimplex: null,\r\n        }\r\n    },\r\n    mounted() {\r\n        this.heightmapFragmentShader = `\r\n            #include <common>\r\n\t\t\tuniform vec2 mousePos;\r\n\t\t\tuniform float mouseSize;\r\n\t\t\tuniform float viscosityConstant;\r\n\t\t\tuniform float heightCompensation;\r\n\t\t\tvoid main()\t{\r\n\t\t\t\tvec2 cellSize = 1.0 / resolution.xy;\r\n\t\t\t\tvec2 uv = gl_FragCoord.xy * cellSize;\r\n\t\t\t\t// heightmapValue.x == height from previous frame\r\n\t\t\t\t// heightmapValue.y == height from penultimate frame\r\n\t\t\t\t// heightmapValue.z, heightmapValue.w not used\r\n\t\t\t\tvec4 heightmapValue = texture2D(heightmap, uv);\r\n\t\t\t\t// Get neighbours\r\n\t\t\t\tvec4 north = texture2D(heightmap, uv + vec2(0.0, cellSize.y));\r\n\t\t\t\tvec4 south = texture2D(heightmap, uv + vec2(0.0, - cellSize.y));\r\n\t\t\t\tvec4 east = texture2D(heightmap, uv + vec2(cellSize.x, 0.0));\r\n\t\t\t\tvec4 west = texture2D(heightmap, uv + vec2(- cellSize.x, 0.0));\r\n\t\t\t\t// https://web.archive.org/web/20080618181901/http://freespace.virgin.net/hugo.elias/graphics/x_water.htm\r\n\t\t\t\tfloat newHeight = ((north.x + south.x + east.x + west.x) * 0.5 - heightmapValue.y) * viscosityConstant;\r\n\t\t\t\t// Mouse influence\r\n\t\t\t\tfloat mousePhase = clamp(length((uv - vec2(0.5)) * BOUNDS - vec2(mousePos.x, - mousePos.y)) * PI / mouseSize, 0.0, PI);\r\n\t\t\t\tnewHeight += (cos(mousePhase) + 1.0) * 0.28;\r\n\t\t\t\theightmapValue.y = heightmapValue.x;\r\n\t\t\t\theightmapValue.x = newHeight;\r\n\t\t\t\tgl_FragColor = heightmapValue;\r\n            }`\r\n        this.smoothFragmentShader = `\r\n            uniform sampler2D smoothTexture;\r\n\t\t\tvoid main()\t{\r\n\t\t\t\tvec2 cellSize = 1.0 / resolution.xy;\r\n\t\t\t\tvec2 uv = gl_FragCoord.xy * cellSize;\r\n\t\t\t\t// Computes the mean of texel and 4 neighbours\r\n\t\t\t\tvec4 textureValue = texture2D(smoothTexture, uv);\r\n\t\t\t\ttextureValue += texture2D(smoothTexture, uv + vec2(0.0, cellSize.y));\r\n\t\t\t\ttextureValue += texture2D(smoothTexture, uv + vec2(0.0, - cellSize.y));\r\n\t\t\t\ttextureValue += texture2D(smoothTexture, uv + vec2(cellSize.x, 0.0));\r\n\t\t\t\ttextureValue += texture2D(smoothTexture, uv + vec2(- cellSize.x, 0.0));\r\n\t\t\t\ttextureValue /= 5.0;\r\n\t\t\t\tgl_FragColor = textureValue;\r\n            }`\r\n        this.readWaterLevelFragmentShader = `\r\n            uniform vec2 point1;\r\n\t\t\tuniform sampler2D levelTexture;\r\n\t\t\t// Integer to float conversion from https://stackoverflow.com/questions/17981163/webgl-read-pixels-from-floating-point-render-target\r\n\t\t\tfloat shift_right(float v, float amt) {\r\n\t\t\t\tv = floor(v) + 0.5;\r\n\t\t\t\treturn floor(v / exp2(amt));\r\n\t\t\t}\r\n\t\t\tfloat shift_left(float v, float amt) {\r\n\t\t\t\treturn floor(v * exp2(amt) + 0.5);\r\n\t\t\t}\r\n\t\t\tfloat mask_last(float v, float bits) {\r\n\t\t\t\treturn mod(v, shift_left(1.0, bits));\r\n\t\t\t}\r\n\t\t\tfloat extract_bits(float num, float from, float to) {\r\n\t\t\t\tfrom = floor(from + 0.5); to = floor(to + 0.5);\r\n\t\t\t\treturn mask_last(shift_right(num, from), to - from);\r\n\t\t\t}\r\n\t\t\tvec4 encode_float(float val) {\r\n\t\t\t\tif (val == 0.0) return vec4(0, 0, 0, 0);\r\n\t\t\t\tfloat sign = val > 0.0 ? 0.0 : 1.0;\r\n\t\t\t\tval = abs(val);\r\n\t\t\t\tfloat exponent = floor(log2(val));\r\n\t\t\t\tfloat biased_exponent = exponent + 127.0;\r\n\t\t\t\tfloat fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0;\r\n\t\t\t\tfloat t = biased_exponent / 2.0;\r\n\t\t\t\tfloat last_bit_of_biased_exponent = fract(t) * 2.0;\r\n\t\t\t\tfloat remaining_bits_of_biased_exponent = floor(t);\r\n\t\t\t\tfloat byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0;\r\n\t\t\t\tfloat byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0;\r\n\t\t\t\tfloat byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0;\r\n\t\t\t\tfloat byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;\r\n\t\t\t\treturn vec4(byte4, byte3, byte2, byte1);\r\n\t\t\t}\r\n\t\t\tvoid main()\t{\r\n\t\t\t\tvec2 cellSize = 1.0 / resolution.xy;\r\n\t\t\t\tfloat waterLevel = texture2D(levelTexture, point1).x;\r\n\t\t\t\tvec2 normal = vec2(\r\n\t\t\t\t\t(texture2D(levelTexture, point1 + vec2(- cellSize.x, 0)).x - texture2D(levelTexture, point1 + vec2(cellSize.x, 0)).x) * WIDTH / BOUNDS,\r\n\t\t\t\t\t(texture2D(levelTexture, point1 + vec2(0, - cellSize.y)).x - texture2D(levelTexture, point1 + vec2(0, cellSize.y)).x) * WIDTH / BOUNDS);\r\n\t\t\t\tif (gl_FragCoord.x < 1.5) {\r\n\t\t\t\t\tgl_FragColor = encode_float(waterLevel);\r\n\t\t\t\t} else if (gl_FragCoord.x < 2.5) {\r\n\t\t\t\t\tgl_FragColor = encode_float(normal.x);\r\n\t\t\t\t} else if (gl_FragCoord.x < 3.5) {\r\n\t\t\t\t\tgl_FragColor = encode_float(normal.y);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tgl_FragColor = encode_float(0.0);\r\n\t\t\t\t}\r\n            }`\r\n        this.waterVertexShader = `\r\n            uniform sampler2D heightmap;\r\n\t\t\t#define PHONG\r\n\t\t\tvarying vec3 vViewPosition;\r\n\t\t\t#ifndef FLAT_SHADED\r\n\t\t\t\tvarying vec3 vNormal;\r\n\t\t\t#endif\r\n\t\t\t#include <common>\r\n\t\t\t#include <uv_pars_vertex>\r\n\t\t\t#include <uv2_pars_vertex>\r\n\t\t\t#include <displacementmap_pars_vertex>\r\n\t\t\t#include <envmap_pars_vertex>\r\n\t\t\t#include <color_pars_vertex>\r\n\t\t\t#include <morphtarget_pars_vertex>\r\n\t\t\t#include <skinning_pars_vertex>\r\n\t\t\t#include <shadowmap_pars_vertex>\r\n\t\t\t#include <logdepthbuf_pars_vertex>\r\n\t\t\t#include <clipping_planes_pars_vertex>\r\n\t\t\tvoid main() {\r\n\t\t\t\tvec2 cellSize = vec2(1.0 / WIDTH, 1.0 / WIDTH);\r\n\t\t\t\t#include <uv_vertex>\r\n\t\t\t\t#include <uv2_vertex>\r\n\t\t\t\t#include <color_vertex>\r\n\t\t\t\t// # include <beginnormal_vertex>\r\n\t\t\t\t// Compute normal from heightmap\r\n\t\t\t\tvec3 objectNormal = vec3(\r\n\t\t\t\t\t(texture2D(heightmap, uv + vec2(- cellSize.x, 0)).x - texture2D(heightmap, uv + vec2(cellSize.x, 0)).x) * WIDTH / BOUNDS,\r\n\t\t\t\t\t(texture2D(heightmap, uv + vec2(0, - cellSize.y)).x - texture2D(heightmap, uv + vec2(0, cellSize.y)).x) * WIDTH / BOUNDS,\r\n\t\t\t\t\t1.0);\r\n\t\t\t\t//<beginnormal_vertex>\r\n\t\t\t\t#include <morphnormal_vertex>\r\n\t\t\t\t#include <skinbase_vertex>\r\n\t\t\t\t#include <skinnormal_vertex>\r\n\t\t\t\t#include <defaultnormal_vertex>\r\n\t\t\t#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\t\t\t\tvNormal = normalize(transformedNormal);\r\n\t\t\t#endif\r\n\t\t\t\t//# include <begin_vertex>\r\n\t\t\t\tfloat heightValue = texture2D(heightmap, uv).x;\r\n\t\t\t\tvec3 transformed = vec3(position.x, position.y, heightValue);\r\n\t\t\t\t//<begin_vertex>\r\n\t\t\t\t#include <morphtarget_vertex>\r\n\t\t\t\t#include <skinning_vertex>\r\n\t\t\t\t#include <displacementmap_vertex>\r\n\t\t\t\t#include <project_vertex>\r\n\t\t\t\t#include <logdepthbuf_vertex>\r\n\t\t\t\t#include <clipping_planes_vertex>\r\n\t\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\t#include <worldpos_vertex>\r\n\t\t\t\t#include <envmap_vertex>\r\n\t\t\t\t#include <shadowmap_vertex>\r\n            }`\r\n        this.BOUNDS_HALF = this.BOUNDS * 0.5\r\n        this.mouseCoords = new this.$THREE.Vector2()\r\n        this.raycaster = new this.$THREE.Raycaster()\r\n        this.waterNormal = new this.$THREE.Vector3()\r\n        this.simplex = new SimplexNoise()\r\n        this.init()\r\n\t\tthis.animate()\r\n    },\r\n    beforeDestroy() {\r\n        this.gui.destroy()\r\n    },\r\n    methods: {\r\n        init() {\r\n            this.container = document.createElement('div')\r\n            document.getElementsByClassName('webglGpgpuWater-container')[0].appendChild(this.container)\r\n            this.camera = new this.$THREE.PerspectiveCamera(75, this.$webglInnerWidth / window.innerHeight, 1, 3000)\r\n            this.camera.position.set(0, 200, 350)\r\n            this.camera.lookAt(0, 0, 0)\r\n            this.scene = new this.$THREE.Scene()\r\n            var sun = new this.$THREE.DirectionalLight(0xFFFFFF, 1.0)\r\n            sun.position.set(300, 400, 175)\r\n            this.scene.add(sun)\r\n            var sun2 = new this.$THREE.DirectionalLight(0x40A040, 0.6)\r\n            sun2.position.set(- 100, 350, - 200)\r\n            this.scene.add(sun2)\r\n            this.renderer = new this.$THREE.WebGLRenderer()\r\n            this.renderer.setPixelRatio(window.devicePixelRatio)\r\n            this.renderer.setSize(this.$webglInnerWidth, window.innerHeight)\r\n            this.container.appendChild(this.renderer.domElement)\r\n            this.stats = new this.$Stats()\r\n            this.stats.dom.style.left = '280px'\r\n            this.container.appendChild(this.stats.dom)\r\n            this.container.style.touchAction = 'none'\r\n            this.container.addEventListener('pointermove', this.onPointerMove, false)\r\n            document.addEventListener('keydown', (event) => {\r\n                // W Pressed: Toggle wireframe\r\n                if (event.keyCode === 87) {\r\n                    this.waterMesh.material.wireframe = ! this.waterMesh.material.wireframe\r\n                    this.waterMesh.material.needsUpdate = true\r\n                }\r\n            }, false)\r\n            window.addEventListener('resize', this.onWindowResize, false)\r\n            this.gui = new GUI()\r\n            var effectController = {\r\n                mouseSize: 20.0,\r\n                viscosity: 0.98,\r\n                spheresEnabled: this.spheresEnabled\r\n            }\r\n            var valuesChanger = () => {\r\n                this.heightmapVariable.material.uniforms[\"mouseSize\"].value = effectController.mouseSize\r\n                this.heightmapVariable.material.uniforms[\"viscosityConstant\"].value = effectController.viscosity\r\n                this.spheresEnabled = effectController.spheresEnabled\r\n                for (var i = 0; i < this.NUM_SPHERES; i ++) {\r\n                    if (this.spheres[i]) {\r\n                        this.spheres[i].visible = this.spheresEnabled\r\n                    }\r\n                }\r\n            }\r\n            this.gui.add(effectController, \"mouseSize\", 1.0, 100.0, 1.0).onChange(valuesChanger)\r\n            this.gui.add(effectController, \"viscosity\", 0.9, 0.999, 0.001).onChange(valuesChanger)\r\n            this.gui.add(effectController, \"spheresEnabled\", 0, 1, 1).onChange(valuesChanger)\r\n            var buttonSmooth = {\r\n                smoothWater: () => {\r\n                    this.smoothWater()\r\n                }\r\n            }\r\n            this.gui.add(buttonSmooth, 'smoothWater')\r\n            this.initWater()\r\n            this.createSpheres()\r\n            valuesChanger()\r\n        },\r\n        initWater() {\r\n            var materialColor = 0x0040C0\r\n            var geometry = new this.$THREE.PlaneBufferGeometry(this.BOUNDS, this.BOUNDS, this.WIDTH - 1, this.WIDTH - 1)\r\n            // material: make a this.$THREE.ShaderMaterial clone of this.$THREE.MeshPhongMaterial, with customized vertex shader\r\n            var material = new this.$THREE.ShaderMaterial({\r\n                uniforms: this.$THREE.UniformsUtils.merge([\r\n                    this.$THREE.ShaderLib['phong'].uniforms,\r\n                    {\r\n                        \"heightmap\": { value: null }\r\n                    }\r\n            ]),\r\n                vertexShader: this.waterVertexShader,\r\n                fragmentShader: this.$THREE.ShaderChunk['meshphong_frag']\r\n            })\r\n            material.lights = true\r\n            // Material attributes from this.$THREE.MeshPhongMaterial\r\n            material.color = new this.$THREE.Color(materialColor)\r\n            material.specular = new this.$THREE.Color(0x111111)\r\n            material.shininess = 50\r\n            // Sets the uniforms with the material values\r\n            material.uniforms[\"diffuse\"].value = material.color\r\n            material.uniforms[\"specular\"].value = material.specular\r\n            material.uniforms[\"shininess\"].value = Math.max(material.shininess, 1e-4)\r\n            material.uniforms[\"opacity\"].value = material.opacity\r\n            // Defines\r\n            material.defines.WIDTH = this.WIDTH.toFixed(1)\r\n            material.defines.BOUNDS = this.BOUNDS.toFixed(1)\r\n            this.waterUniforms = material.uniforms\r\n            this.waterMesh = new this.$THREE.Mesh(geometry, material)\r\n            this.waterMesh.rotation.x = - Math.PI / 2\r\n            this.waterMesh.matrixAutoUpdate = false\r\n            this.waterMesh.updateMatrix()\r\n            this.scene.add(this.waterMesh)\r\n            // this.$THREE.Mesh just for mouse raycasting\r\n            var geometryRay = new this.$THREE.PlaneBufferGeometry(this.BOUNDS, this.BOUNDS, 1, 1)\r\n            this.meshRay = new this.$THREE.Mesh(geometryRay, new this.$THREE.MeshBasicMaterial({ color: 0xFFFFFF, visible: false }))\r\n            this.meshRay.rotation.x = - Math.PI / 2\r\n            this.meshRay.matrixAutoUpdate = false\r\n            this.meshRay.updateMatrix()\r\n            this.scene.add(this.meshRay)\r\n            // Creates the gpu computation class and sets it up\r\n            this.gpuCompute = new GPUComputationRenderer(this.WIDTH, this.WIDTH, this.renderer)\r\n            if (this.isSafari()) {\r\n                this.gpuCompute.setDataType(this.$THREE.HalfFloatType)\r\n            }\r\n            var heightmap0 = this.gpuCompute.createTexture()\r\n            this.fillTexture(heightmap0)\r\n            this.heightmapVariable = this.gpuCompute.addVariable(\"heightmap\", this.heightmapFragmentShader, heightmap0)\r\n            this.gpuCompute.setVariableDependencies(this.heightmapVariable, [this.heightmapVariable])\r\n            this.heightmapVariable.material.uniforms[\"mousePos\"] = { value: new this.$THREE.Vector2(10000, 10000) }\r\n            this.heightmapVariable.material.uniforms[\"mouseSize\"] = { value: 20.0 }\r\n            this.heightmapVariable.material.uniforms[\"viscosityConstant\"] = { value: 0.98 }\r\n            this.heightmapVariable.material.uniforms[\"heightCompensation\"] = { value: 0 }\r\n            this.heightmapVariable.material.defines.BOUNDS = this.BOUNDS.toFixed(1)\r\n            var error = this.gpuCompute.init()\r\n            if (error !== null) {\r\n                console.error(error)\r\n            }\r\n            // Create compute shader to smooth the water surface and velocity\r\n            this.smoothShader = this.gpuCompute.createShaderMaterial(this.smoothFragmentShader, { smoothTexture: { value: null } })\r\n            // Create compute shader to read water level\r\n            this.readWaterLevelShader = this.gpuCompute.createShaderMaterial(this.readWaterLevelFragmentShader, {\r\n                point1: { value: new this.$THREE.Vector2() },\r\n                levelTexture: { value: null }\r\n            })\r\n            this.readWaterLevelShader.defines.WIDTH = this.WIDTH.toFixed(1)\r\n            this.readWaterLevelShader.defines.BOUNDS = this.BOUNDS.toFixed(1)\r\n            // Create a 4x1 pixel image and a render target (Uint8, 4 channels, 1 byte per channel) to read water height and orientation\r\n            this.readWaterLevelImage = new Uint8Array(4 * 1 * 4)\r\n            this.readWaterLevelRenderTarget = new this.$THREE.WebGLRenderTarget(4, 1, {\r\n                wrapS: this.$THREE.ClampToEdgeWrapping,\r\n                wrapT: this.$THREE.ClampToEdgeWrapping,\r\n                minFilter: this.$THREE.NearestFilter,\r\n                magFilter: this.$THREE.NearestFilter,\r\n                format: this.$THREE.RGBAFormat,\r\n                type: this.$THREE.UnsignedByteType,\r\n                depthBuffer: false\r\n            })\r\n        },\r\n        isSafari() {\r\n            return !! navigator.userAgent.match(/Safari/i) && ! navigator.userAgent.match(/Chrome/i)\r\n        },\r\n        fillTexture(texture) {\r\n            var waterMaxHeight = 10\r\n            var that = this\r\n            function noise(x, y) {\r\n                var multR = waterMaxHeight\r\n                var mult = 0.025\r\n                var r = 0\r\n                for (var i = 0; i < 15; i ++) {\r\n                    r += multR * that.simplex.noise(x * mult, y * mult)\r\n                    multR *= 0.53 + 0.025 * i\r\n                    mult *= 1.25\r\n                }\r\n                return r\r\n            }\r\n            var pixels = texture.image.data\r\n            var p = 0\r\n            for (var j = 0; j < this.WIDTH; j ++) {\r\n                for (var i = 0; i < this.WIDTH; i ++) {\r\n                    var x = i * 128 / this.WIDTH\r\n                    var y = j * 128 / this.WIDTH\r\n                    pixels[p + 0] = noise(x, y)\r\n                    pixels[p + 1] = pixels[p + 0]\r\n                    pixels[p + 2] = 0\r\n                    pixels[p + 3] = 1\r\n                    p += 4\r\n                }\r\n            }\r\n        },\r\n        smoothWater() {\r\n            var currentRenderTarget = this.gpuCompute.getCurrentRenderTarget(this.heightmapVariable)\r\n            var alternateRenderTarget = this.gpuCompute.getAlternateRenderTarget(this.heightmapVariable)\r\n            for (var i = 0; i < 10; i ++) {\r\n                this.smoothShader.uniforms[\"smoothTexture\"].value = currentRenderTarget.texture\r\n                this.gpuCompute.doRenderTarget(this.smoothShader, alternateRenderTarget)\r\n                this.smoothShader.uniforms[\"smoothTexture\"].value = alternateRenderTarget.texture\r\n                this.gpuCompute.doRenderTarget(this.smoothShader, currentRenderTarget)\r\n            }\r\n        },\r\n        createSpheres() {\r\n            var sphereTemplate = new this.$THREE.Mesh(new this.$THREE.SphereBufferGeometry(4, 24, 12), new this.$THREE.MeshPhongMaterial({ color: 0xFFFF00 }))\r\n            for (var i = 0; i < this.NUM_SPHERES; i ++) {\r\n                var sphere = sphereTemplate\r\n                if (i < this.NUM_SPHERES - 1) {\r\n                    sphere = sphereTemplate.clone()\r\n                }\r\n                sphere.position.x = (Math.random() - 0.5) * this.BOUNDS * 0.7\r\n                sphere.position.z = (Math.random() - 0.5) * this.BOUNDS * 0.7\r\n                sphere.userData.velocity = new this.$THREE.Vector3()\r\n                this.scene.add(sphere)\r\n                this.spheres[i] = sphere\r\n            }\r\n\r\n        },\r\n        sphereDynamics() {\r\n            var currentRenderTarget = this.gpuCompute.getCurrentRenderTarget(this.heightmapVariable)\r\n            this.readWaterLevelShader.uniforms[\"levelTexture\"].value = currentRenderTarget.texture\r\n            for (var i = 0; i < this.NUM_SPHERES; i ++) {\r\n                var sphere = this.spheres[i]\r\n                if (sphere) {\r\n                    // Read water level and orientation\r\n                    var u = 0.5 * sphere.position.x / this.BOUNDS_HALF + 0.5\r\n                    var v = 1 - (0.5 * sphere.position.z / this.BOUNDS_HALF + 0.5)\r\n                    this.readWaterLevelShader.uniforms[\"point1\"].value.set(u, v)\r\n                    this.gpuCompute.doRenderTarget(this.readWaterLevelShader, this.readWaterLevelRenderTarget)\r\n                    this.renderer.readRenderTargetPixels(this.readWaterLevelRenderTarget, 0, 0, 4, 1, this.readWaterLevelImage)\r\n                    var pixels = new Float32Array(this.readWaterLevelImage.buffer)\r\n                    // Get orientation\r\n                    this.waterNormal.set(pixels[1], 0, - pixels[2])\r\n                    var pos = sphere.position\r\n                    // Set height\r\n                    pos.y = pixels[0]\r\n                    // Move sphere\r\n                    this.waterNormal.multiplyScalar(0.1)\r\n                    sphere.userData.velocity.add(this.waterNormal)\r\n                    sphere.userData.velocity.multiplyScalar(0.998)\r\n                    pos.add(sphere.userData.velocity)\r\n                    if (pos.x < - this.BOUNDS_HALF) {\r\n                        pos.x = - this.BOUNDS_HALF + 0.001\r\n                        sphere.userData.velocity.x *= - 0.3\r\n                    } else if (pos.x > this.BOUNDS_HALF) {\r\n                        pos.x = this.BOUNDS_HALF - 0.001\r\n                        sphere.userData.velocity.x *= - 0.3\r\n                    }\r\n                    if (pos.z < - this.BOUNDS_HALF) {\r\n                        pos.z = - this.BOUNDS_HALF + 0.001\r\n                        sphere.userData.velocity.z *= - 0.3\r\n                    } else if (pos.z > this.BOUNDS_HALF) {\r\n                        pos.z = this.BOUNDS_HALF - 0.001\r\n                        sphere.userData.velocity.z *= - 0.3\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        onWindowResize() {\r\n            this.$onWindowResize(this.camera, this.renderer)\r\n        },\r\n        setMouseCoords(x, y) {\r\n            this.mouseCoords.set((x / this.renderer.domElement.clientWidth) * 2 - 1, - (y / this.renderer.domElement.clientHeight) * 2 + 1)\r\n            this.mouseMoved = true\r\n        },\r\n        onPointerMove(event) {\r\n            if (event.isPrimary === false) return\r\n            this.setMouseCoords(event.clientX, event.clientY)\r\n        },\r\n        animate() {\r\n            requestAnimationFrame(this.animate)\r\n            this.render()\r\n            this.stats.update()\r\n        },\r\n        render() {\r\n            // Set uniforms: mouse interaction\r\n            var uniforms = this.heightmapVariable.material.uniforms\r\n            if (this.mouseMoved) {\r\n                this.raycaster.setFromCamera(this.mouseCoords, this.camera)\r\n                var intersects = this.raycaster.intersectObject(this.meshRay)\r\n                if (intersects.length > 0) {\r\n                    var point = intersects[ 0 ].point\r\n                    uniforms[ \"mousePos\" ].value.set(point.x, point.z)\r\n                } else {\r\n                    uniforms[ \"mousePos\" ].value.set(10000, 10000)\r\n                }\r\n                this.mouseMoved = false\r\n            } else {\r\n                uniforms[ \"mousePos\" ].value.set(10000, 10000)\r\n            }\r\n            // Do the gpu computation\r\n            this.gpuCompute.compute()\r\n            if (this.spheresEnabled) {\r\n                this.sphereDynamics()\r\n            }\r\n            // Get compute output in custom uniform\r\n            this.waterUniforms[\"heightmap\"].value = this.gpuCompute.getCurrentRenderTarget(this.heightmapVariable).texture\r\n            // Render\r\n            this.renderer.render(this.scene, this.camera)\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n.webglGpgpuWater-container {\r\n    width: 100%;\r\n}\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// src/views/gpgpu/webglGpgpuWater.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"webglGpgpuWater-container\"},[_c('div',{attrs:{\"id\":\"info\"}},[_c('a',{attrs:{\"href\":\"https://threejs.org\",\"target\":\"_blank\",\"rel\":\"noopener\"}},[_vm._v(\"three.js\")]),_vm._v(\" - \"),_c('span',{attrs:{\"id\":\"waterSize\"}}),_vm._v(\" webgl gpgpu water\"),_c('br'),_vm._v(\"\\n\\t\\t\\tMove mouse to disturb water.\"),_c('br'),_vm._v(\"\\n\\t\\t\\tPress mouse button to orbit around. 'W' key toggles wireframe.\\n\\t\\t\")])])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-29176310\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/views/gpgpu/webglGpgpuWater.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true,\\\"publicPath\\\":\\\"../../\\\"}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-29176310\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./webglGpgpuWater.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./webglGpgpuWater.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./webglGpgpuWater.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-29176310\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./webglGpgpuWater.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-29176310\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/gpgpu/webglGpgpuWater.vue\n// module id = null\n// module chunks = ","// Ported from Stefan Gustavson's java implementation\r\n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\r\n// Read Stefan's excellent paper for details on how this code works.\r\n//\r\n// Sean McCullough banksean@gmail.com\r\n//\r\n// Added 4D noise\r\n\r\n/**\r\n * You can pass in a random number generator object if you like.\r\n * It is assumed to have a random() method.\r\n */\r\nvar SimplexNoise = function ( r ) {\r\n\r\n\tif ( r == undefined ) r = Math;\r\n\tthis.grad3 = [[ 1, 1, 0 ], [ - 1, 1, 0 ], [ 1, - 1, 0 ], [ - 1, - 1, 0 ],\r\n\t\t[ 1, 0, 1 ], [ - 1, 0, 1 ], [ 1, 0, - 1 ], [ - 1, 0, - 1 ],\r\n\t\t[ 0, 1, 1 ], [ 0, - 1, 1 ], [ 0, 1, - 1 ], [ 0, - 1, - 1 ]];\r\n\r\n\tthis.grad4 = [[ 0, 1, 1, 1 ], [ 0, 1, 1, - 1 ], [ 0, 1, - 1, 1 ], [ 0, 1, - 1, - 1 ],\r\n\t     [ 0, - 1, 1, 1 ], [ 0, - 1, 1, - 1 ], [ 0, - 1, - 1, 1 ], [ 0, - 1, - 1, - 1 ],\r\n\t     [ 1, 0, 1, 1 ], [ 1, 0, 1, - 1 ], [ 1, 0, - 1, 1 ], [ 1, 0, - 1, - 1 ],\r\n\t     [ - 1, 0, 1, 1 ], [ - 1, 0, 1, - 1 ], [ - 1, 0, - 1, 1 ], [ - 1, 0, - 1, - 1 ],\r\n\t     [ 1, 1, 0, 1 ], [ 1, 1, 0, - 1 ], [ 1, - 1, 0, 1 ], [ 1, - 1, 0, - 1 ],\r\n\t     [ - 1, 1, 0, 1 ], [ - 1, 1, 0, - 1 ], [ - 1, - 1, 0, 1 ], [ - 1, - 1, 0, - 1 ],\r\n\t     [ 1, 1, 1, 0 ], [ 1, 1, - 1, 0 ], [ 1, - 1, 1, 0 ], [ 1, - 1, - 1, 0 ],\r\n\t     [ - 1, 1, 1, 0 ], [ - 1, 1, - 1, 0 ], [ - 1, - 1, 1, 0 ], [ - 1, - 1, - 1, 0 ]];\r\n\r\n\tthis.p = [];\r\n\r\n\tfor ( var i = 0; i < 256; i ++ ) {\r\n\r\n\t\tthis.p[ i ] = Math.floor( r.random() * 256 );\r\n\r\n\t}\r\n\r\n\t// To remove the need for index wrapping, double the permutation table length\r\n\tthis.perm = [];\r\n\r\n\tfor ( var i = 0; i < 512; i ++ ) {\r\n\r\n\t\tthis.perm[ i ] = this.p[ i & 255 ];\r\n\r\n\t}\r\n\r\n\t// A lookup table to traverse the simplex around a given point in 4D.\r\n\t// Details can be found where this table is used, in the 4D noise method.\r\n\tthis.simplex = [\r\n\t\t[ 0, 1, 2, 3 ], [ 0, 1, 3, 2 ], [ 0, 0, 0, 0 ], [ 0, 2, 3, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 2, 3, 0 ],\r\n\t\t[ 0, 2, 1, 3 ], [ 0, 0, 0, 0 ], [ 0, 3, 1, 2 ], [ 0, 3, 2, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 3, 2, 0 ],\r\n\t\t[ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],\r\n\t\t[ 1, 2, 0, 3 ], [ 0, 0, 0, 0 ], [ 1, 3, 0, 2 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 2, 3, 0, 1 ], [ 2, 3, 1, 0 ],\r\n\t\t[ 1, 0, 2, 3 ], [ 1, 0, 3, 2 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 2, 0, 3, 1 ], [ 0, 0, 0, 0 ], [ 2, 1, 3, 0 ],\r\n\t\t[ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],\r\n\t\t[ 2, 0, 1, 3 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 3, 0, 1, 2 ], [ 3, 0, 2, 1 ], [ 0, 0, 0, 0 ], [ 3, 1, 2, 0 ],\r\n\t\t[ 2, 1, 0, 3 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 3, 1, 0, 2 ], [ 0, 0, 0, 0 ], [ 3, 2, 0, 1 ], [ 3, 2, 1, 0 ]];\r\n\r\n};\r\n\r\nSimplexNoise.prototype.dot = function ( g, x, y ) {\r\n\r\n\treturn g[ 0 ] * x + g[ 1 ] * y;\r\n\r\n};\r\n\r\nSimplexNoise.prototype.dot3 = function ( g, x, y, z ) {\r\n\r\n\treturn g[ 0 ] * x + g[ 1 ] * y + g[ 2 ] * z;\r\n\r\n};\r\n\r\nSimplexNoise.prototype.dot4 = function ( g, x, y, z, w ) {\r\n\r\n\treturn g[ 0 ] * x + g[ 1 ] * y + g[ 2 ] * z + g[ 3 ] * w;\r\n\r\n};\r\n\r\nSimplexNoise.prototype.noise = function ( xin, yin ) {\r\n\r\n\tvar n0, n1, n2; // Noise contributions from the three corners\r\n\t// Skew the input space to determine which simplex cell we're in\r\n\tvar F2 = 0.5 * ( Math.sqrt( 3.0 ) - 1.0 );\r\n\tvar s = ( xin + yin ) * F2; // Hairy factor for 2D\r\n\tvar i = Math.floor( xin + s );\r\n\tvar j = Math.floor( yin + s );\r\n\tvar G2 = ( 3.0 - Math.sqrt( 3.0 ) ) / 6.0;\r\n\tvar t = ( i + j ) * G2;\r\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y) space\r\n\tvar Y0 = j - t;\r\n\tvar x0 = xin - X0; // The x,y distances from the cell origin\r\n\tvar y0 = yin - Y0;\r\n\t// For the 2D case, the simplex shape is an equilateral triangle.\r\n\t// Determine which simplex we are in.\r\n\tvar i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\r\n\tif ( x0 > y0 ) {\r\n\r\n\t\ti1 = 1; j1 = 0;\r\n\r\n\t\t// lower triangle, XY order: (0,0)->(1,0)->(1,1)\r\n\r\n\t}\telse {\r\n\r\n\t\ti1 = 0; j1 = 1;\r\n\r\n\t} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\r\n\r\n\t// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\r\n\t// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\r\n\t// c = (3-sqrt(3))/6\r\n\tvar x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\r\n\tvar y1 = y0 - j1 + G2;\r\n\tvar x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\r\n\tvar y2 = y0 - 1.0 + 2.0 * G2;\r\n\t// Work out the hashed gradient indices of the three simplex corners\r\n\tvar ii = i & 255;\r\n\tvar jj = j & 255;\r\n\tvar gi0 = this.perm[ ii + this.perm[ jj ] ] % 12;\r\n\tvar gi1 = this.perm[ ii + i1 + this.perm[ jj + j1 ] ] % 12;\r\n\tvar gi2 = this.perm[ ii + 1 + this.perm[ jj + 1 ] ] % 12;\r\n\t// Calculate the contribution from the three corners\r\n\tvar t0 = 0.5 - x0 * x0 - y0 * y0;\r\n\tif ( t0 < 0 ) n0 = 0.0;\r\n\telse {\r\n\r\n\t\tt0 *= t0;\r\n\t\tn0 = t0 * t0 * this.dot( this.grad3[ gi0 ], x0, y0 ); // (x,y) of grad3 used for 2D gradient\r\n\r\n\t}\r\n\r\n\tvar t1 = 0.5 - x1 * x1 - y1 * y1;\r\n\tif ( t1 < 0 ) n1 = 0.0;\r\n\telse {\r\n\r\n\t\tt1 *= t1;\r\n\t\tn1 = t1 * t1 * this.dot( this.grad3[ gi1 ], x1, y1 );\r\n\r\n\t}\r\n\r\n\tvar t2 = 0.5 - x2 * x2 - y2 * y2;\r\n\tif ( t2 < 0 ) n2 = 0.0;\r\n\telse {\r\n\r\n\t\tt2 *= t2;\r\n\t\tn2 = t2 * t2 * this.dot( this.grad3[ gi2 ], x2, y2 );\r\n\r\n\t}\r\n\r\n\t// Add contributions from each corner to get the final noise value.\r\n\t// The result is scaled to return values in the interval [-1,1].\r\n\treturn 70.0 * ( n0 + n1 + n2 );\r\n\r\n};\r\n\r\n// 3D simplex noise\r\nSimplexNoise.prototype.noise3d = function ( xin, yin, zin ) {\r\n\r\n\tvar n0, n1, n2, n3; // Noise contributions from the four corners\r\n\t// Skew the input space to determine which simplex cell we're in\r\n\tvar F3 = 1.0 / 3.0;\r\n\tvar s = ( xin + yin + zin ) * F3; // Very nice and simple skew factor for 3D\r\n\tvar i = Math.floor( xin + s );\r\n\tvar j = Math.floor( yin + s );\r\n\tvar k = Math.floor( zin + s );\r\n\tvar G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too\r\n\tvar t = ( i + j + k ) * G3;\r\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y,z) space\r\n\tvar Y0 = j - t;\r\n\tvar Z0 = k - t;\r\n\tvar x0 = xin - X0; // The x,y,z distances from the cell origin\r\n\tvar y0 = yin - Y0;\r\n\tvar z0 = zin - Z0;\r\n\t// For the 3D case, the simplex shape is a slightly irregular tetrahedron.\r\n\t// Determine which simplex we are in.\r\n\tvar i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\r\n\tvar i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\r\n\tif ( x0 >= y0 ) {\r\n\r\n\t\tif ( y0 >= z0 ) {\r\n\r\n\t\t\ti1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0;\r\n\r\n\t\t\t// X Y Z order\r\n\r\n\t\t} else if ( x0 >= z0 ) {\r\n\r\n\t\t\ti1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1;\r\n\r\n\t\t\t// X Z Y order\r\n\r\n\t\t} else {\r\n\r\n\t\t\ti1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1;\r\n\r\n\t\t} // Z X Y order\r\n\r\n\t} else { // x0<y0\r\n\r\n\t\tif ( y0 < z0 ) {\r\n\r\n\t\t\ti1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1;\r\n\r\n\t\t\t// Z Y X order\r\n\r\n\t\t} else if ( x0 < z0 ) {\r\n\r\n\t\t\ti1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1;\r\n\r\n\t\t\t// Y Z X order\r\n\r\n\t\t} else {\r\n\r\n\t\t\ti1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0;\r\n\r\n\t\t} // Y X Z order\r\n\r\n\t}\r\n\r\n\t// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\r\n\t// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\r\n\t// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\r\n\t// c = 1/6.\r\n\tvar x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\r\n\tvar y1 = y0 - j1 + G3;\r\n\tvar z1 = z0 - k1 + G3;\r\n\tvar x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords\r\n\tvar y2 = y0 - j2 + 2.0 * G3;\r\n\tvar z2 = z0 - k2 + 2.0 * G3;\r\n\tvar x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords\r\n\tvar y3 = y0 - 1.0 + 3.0 * G3;\r\n\tvar z3 = z0 - 1.0 + 3.0 * G3;\r\n\t// Work out the hashed gradient indices of the four simplex corners\r\n\tvar ii = i & 255;\r\n\tvar jj = j & 255;\r\n\tvar kk = k & 255;\r\n\tvar gi0 = this.perm[ ii + this.perm[ jj + this.perm[ kk ] ] ] % 12;\r\n\tvar gi1 = this.perm[ ii + i1 + this.perm[ jj + j1 + this.perm[ kk + k1 ] ] ] % 12;\r\n\tvar gi2 = this.perm[ ii + i2 + this.perm[ jj + j2 + this.perm[ kk + k2 ] ] ] % 12;\r\n\tvar gi3 = this.perm[ ii + 1 + this.perm[ jj + 1 + this.perm[ kk + 1 ] ] ] % 12;\r\n\t// Calculate the contribution from the four corners\r\n\tvar t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\r\n\tif ( t0 < 0 ) n0 = 0.0;\r\n\telse {\r\n\r\n\t\tt0 *= t0;\r\n\t\tn0 = t0 * t0 * this.dot3( this.grad3[ gi0 ], x0, y0, z0 );\r\n\r\n\t}\r\n\r\n\tvar t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\r\n\tif ( t1 < 0 ) n1 = 0.0;\r\n\telse {\r\n\r\n\t\tt1 *= t1;\r\n\t\tn1 = t1 * t1 * this.dot3( this.grad3[ gi1 ], x1, y1, z1 );\r\n\r\n\t}\r\n\r\n\tvar t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\r\n\tif ( t2 < 0 ) n2 = 0.0;\r\n\telse {\r\n\r\n\t\tt2 *= t2;\r\n\t\tn2 = t2 * t2 * this.dot3( this.grad3[ gi2 ], x2, y2, z2 );\r\n\r\n\t}\r\n\r\n\tvar t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\r\n\tif ( t3 < 0 ) n3 = 0.0;\r\n\telse {\r\n\r\n\t\tt3 *= t3;\r\n\t\tn3 = t3 * t3 * this.dot3( this.grad3[ gi3 ], x3, y3, z3 );\r\n\r\n\t}\r\n\r\n\t// Add contributions from each corner to get the final noise value.\r\n\t// The result is scaled to stay just inside [-1,1]\r\n\treturn 32.0 * ( n0 + n1 + n2 + n3 );\r\n\r\n};\r\n\r\n// 4D simplex noise\r\nSimplexNoise.prototype.noise4d = function ( x, y, z, w ) {\r\n\r\n\t// For faster and easier lookups\r\n\tvar grad4 = this.grad4;\r\n\tvar simplex = this.simplex;\r\n\tvar perm = this.perm;\r\n\r\n\t// The skewing and unskewing factors are hairy again for the 4D case\r\n\tvar F4 = ( Math.sqrt( 5.0 ) - 1.0 ) / 4.0;\r\n\tvar G4 = ( 5.0 - Math.sqrt( 5.0 ) ) / 20.0;\r\n\tvar n0, n1, n2, n3, n4; // Noise contributions from the five corners\r\n\t// Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\r\n\tvar s = ( x + y + z + w ) * F4; // Factor for 4D skewing\r\n\tvar i = Math.floor( x + s );\r\n\tvar j = Math.floor( y + s );\r\n\tvar k = Math.floor( z + s );\r\n\tvar l = Math.floor( w + s );\r\n\tvar t = ( i + j + k + l ) * G4; // Factor for 4D unskewing\r\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\r\n\tvar Y0 = j - t;\r\n\tvar Z0 = k - t;\r\n\tvar W0 = l - t;\r\n\tvar x0 = x - X0; // The x,y,z,w distances from the cell origin\r\n\tvar y0 = y - Y0;\r\n\tvar z0 = z - Z0;\r\n\tvar w0 = w - W0;\r\n\r\n\t// For the 4D case, the simplex is a 4D shape I won't even try to describe.\r\n\t// To find out which of the 24 possible simplices we're in, we need to\r\n\t// determine the magnitude ordering of x0, y0, z0 and w0.\r\n\t// The method below is a good way of finding the ordering of x,y,z,w and\r\n\t// then find the correct traversal order for the simplex were in.\r\n\t// First, six pair-wise comparisons are performed between each possible pair\r\n\t// of the four coordinates, and the results are used to add up binary bits\r\n\t// for an integer index.\r\n\tvar c1 = ( x0 > y0 ) ? 32 : 0;\r\n\tvar c2 = ( x0 > z0 ) ? 16 : 0;\r\n\tvar c3 = ( y0 > z0 ) ? 8 : 0;\r\n\tvar c4 = ( x0 > w0 ) ? 4 : 0;\r\n\tvar c5 = ( y0 > w0 ) ? 2 : 0;\r\n\tvar c6 = ( z0 > w0 ) ? 1 : 0;\r\n\tvar c = c1 + c2 + c3 + c4 + c5 + c6;\r\n\tvar i1, j1, k1, l1; // The integer offsets for the second simplex corner\r\n\tvar i2, j2, k2, l2; // The integer offsets for the third simplex corner\r\n\tvar i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\r\n\t// simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\r\n\t// Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\r\n\t// impossible. Only the 24 indices which have non-zero entries make any sense.\r\n\t// We use a thresholding to set the coordinates in turn from the largest magnitude.\r\n\t// The number 3 in the \"simplex\" array is at the position of the largest coordinate.\r\n\ti1 = simplex[ c ][ 0 ] >= 3 ? 1 : 0;\r\n\tj1 = simplex[ c ][ 1 ] >= 3 ? 1 : 0;\r\n\tk1 = simplex[ c ][ 2 ] >= 3 ? 1 : 0;\r\n\tl1 = simplex[ c ][ 3 ] >= 3 ? 1 : 0;\r\n\t// The number 2 in the \"simplex\" array is at the second largest coordinate.\r\n\ti2 = simplex[ c ][ 0 ] >= 2 ? 1 : 0;\r\n\tj2 = simplex[ c ][ 1 ] >= 2 ? 1 : 0; k2 = simplex[ c ][ 2 ] >= 2 ? 1 : 0;\r\n\tl2 = simplex[ c ][ 3 ] >= 2 ? 1 : 0;\r\n\t// The number 1 in the \"simplex\" array is at the second smallest coordinate.\r\n\ti3 = simplex[ c ][ 0 ] >= 1 ? 1 : 0;\r\n\tj3 = simplex[ c ][ 1 ] >= 1 ? 1 : 0;\r\n\tk3 = simplex[ c ][ 2 ] >= 1 ? 1 : 0;\r\n\tl3 = simplex[ c ][ 3 ] >= 1 ? 1 : 0;\r\n\t// The fifth corner has all coordinate offsets = 1, so no need to look that up.\r\n\tvar x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\r\n\tvar y1 = y0 - j1 + G4;\r\n\tvar z1 = z0 - k1 + G4;\r\n\tvar w1 = w0 - l1 + G4;\r\n\tvar x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords\r\n\tvar y2 = y0 - j2 + 2.0 * G4;\r\n\tvar z2 = z0 - k2 + 2.0 * G4;\r\n\tvar w2 = w0 - l2 + 2.0 * G4;\r\n\tvar x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords\r\n\tvar y3 = y0 - j3 + 3.0 * G4;\r\n\tvar z3 = z0 - k3 + 3.0 * G4;\r\n\tvar w3 = w0 - l3 + 3.0 * G4;\r\n\tvar x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords\r\n\tvar y4 = y0 - 1.0 + 4.0 * G4;\r\n\tvar z4 = z0 - 1.0 + 4.0 * G4;\r\n\tvar w4 = w0 - 1.0 + 4.0 * G4;\r\n\t// Work out the hashed gradient indices of the five simplex corners\r\n\tvar ii = i & 255;\r\n\tvar jj = j & 255;\r\n\tvar kk = k & 255;\r\n\tvar ll = l & 255;\r\n\tvar gi0 = perm[ ii + perm[ jj + perm[ kk + perm[ ll ] ] ] ] % 32;\r\n\tvar gi1 = perm[ ii + i1 + perm[ jj + j1 + perm[ kk + k1 + perm[ ll + l1 ] ] ] ] % 32;\r\n\tvar gi2 = perm[ ii + i2 + perm[ jj + j2 + perm[ kk + k2 + perm[ ll + l2 ] ] ] ] % 32;\r\n\tvar gi3 = perm[ ii + i3 + perm[ jj + j3 + perm[ kk + k3 + perm[ ll + l3 ] ] ] ] % 32;\r\n\tvar gi4 = perm[ ii + 1 + perm[ jj + 1 + perm[ kk + 1 + perm[ ll + 1 ] ] ] ] % 32;\r\n\t// Calculate the contribution from the five corners\r\n\tvar t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\r\n\tif ( t0 < 0 ) n0 = 0.0;\r\n\telse {\r\n\r\n\t\tt0 *= t0;\r\n\t\tn0 = t0 * t0 * this.dot4( grad4[ gi0 ], x0, y0, z0, w0 );\r\n\r\n\t}\r\n\r\n\tvar t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\r\n\tif ( t1 < 0 ) n1 = 0.0;\r\n\telse {\r\n\r\n\t\tt1 *= t1;\r\n\t\tn1 = t1 * t1 * this.dot4( grad4[ gi1 ], x1, y1, z1, w1 );\r\n\r\n\t}\r\n\r\n\tvar t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\r\n\tif ( t2 < 0 ) n2 = 0.0;\r\n\telse {\r\n\r\n\t\tt2 *= t2;\r\n\t\tn2 = t2 * t2 * this.dot4( grad4[ gi2 ], x2, y2, z2, w2 );\r\n\r\n\t}\r\n\r\n\tvar t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\r\n\tif ( t3 < 0 ) n3 = 0.0;\r\n\telse {\r\n\r\n\t\tt3 *= t3;\r\n\t\tn3 = t3 * t3 * this.dot4( grad4[ gi3 ], x3, y3, z3, w3 );\r\n\r\n\t}\r\n\r\n\tvar t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\r\n\tif ( t4 < 0 ) n4 = 0.0;\r\n\telse {\r\n\r\n\t\tt4 *= t4;\r\n\t\tn4 = t4 * t4 * this.dot4( grad4[ gi4 ], x4, y4, z4, w4 );\r\n\r\n\t}\r\n\r\n\t// Sum up and scale the result to cover the range [-1,1]\r\n\treturn 27.0 * ( n0 + n1 + n2 + n3 + n4 );\r\n\r\n};\r\n\r\nexport { SimplexNoise };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/jsm/math/SimplexNoise.js"],"sourceRoot":""}