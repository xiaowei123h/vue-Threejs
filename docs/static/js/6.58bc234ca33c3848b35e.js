webpackJsonp([6],{"U/yM":function(t,e){},m9UE:function(t,e,n){"use strict";n.d(e,"a",function(){return r});var i,a,s=n("6+nK"),r=function(){s._2.call(this),this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new s.T([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new s.T([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))};r.prototype=Object.assign(Object.create(s._2.prototype),{constructor:r,isLineSegmentsGeometry:!0,applyMatrix4:function(t){var e=this.attributes.instanceStart,n=this.attributes.instanceEnd;return void 0!==e&&(e.applyMatrix4(t),n.applyMatrix4(t),e.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},setPositions:function(t){var e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));var n=new s._3(e,6,1);return this.setAttribute("instanceStart",new s._6(n,3,0)),this.setAttribute("instanceEnd",new s._6(n,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this},setColors:function(t){var e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));var n=new s._3(e,6,1);return this.setAttribute("instanceColorStart",new s._6(n,3,0)),this.setAttribute("instanceColorEnd",new s._6(n,3,3)),this},fromWireframeGeometry:function(t){return this.setPositions(t.attributes.position.array),this},fromEdgesGeometry:function(t){return this.setPositions(t.attributes.position.array),this},fromMesh:function(t){return this.fromWireframeGeometry(new s._109(t.geometry)),this},fromLineSegments:function(t){var e=t.geometry;return e.isGeometry?this.setPositions(e.vertices):e.isBufferGeometry&&this.setPositions(e.attributes.position.array),this},computeBoundingBox:(a=new s.i,function(){null===this.boundingBox&&(this.boundingBox=new s.i);var t=this.attributes.instanceStart,e=this.attributes.instanceEnd;void 0!==t&&void 0!==e&&(this.boundingBox.setFromBufferAttribute(t),a.setFromBufferAttribute(e),this.boundingBox.union(a))}),computeBoundingSphere:(i=new s._105,function(){null===this.boundingSphere&&(this.boundingSphere=new s._84),null===this.boundingBox&&this.computeBoundingBox();var t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(void 0!==t&&void 0!==e){var n=this.boundingSphere.center;this.boundingBox.getCenter(n);for(var a=0,r=0,o=t.count;r<o;r++)i.fromBufferAttribute(t,r),a=Math.max(a,n.distanceToSquared(i)),i.fromBufferAttribute(e,r),a=Math.max(a,n.distanceToSquared(i));this.boundingSphere.radius=Math.sqrt(a),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}),toJSON:function(){},applyMatrix:function(t){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(t)}})},"ug6/":function(t,e,n){"use strict";n.d(e,"a",function(){return a});var i=n("6+nK");i._100.line={linewidth:{value:1},resolution:{value:new i._104(1,1)},dashScale:{value:1},dashSize:{value:1},dashOffset:{value:0},gapSize:{value:1},opacity:{value:1}},i._78.line={uniforms:i._101.merge([i._100.common,i._100.fog,i._100.line]),vertexShader:"\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"};var a=function(t){i._79.call(this,{type:"LineMaterial",uniforms:i._101.clone(i._78.line.uniforms),vertexShader:i._78.line.vertexShader,fragmentShader:i._78.line.fragmentShader,clipping:!0}),this.dashed=!1,Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(t){this.uniforms.linewidth.value=t}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(t){this.uniforms.dashOffset.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}}}),this.setValues(t)};a.prototype=Object.create(i._79.prototype),a.prototype.constructor=a,a.prototype.isLineMaterial=!0},wRP2:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i,a,s=n("QEtz"),r=n("wIBv"),o=n("ug6/"),c=n("6+nK"),d=n("m9UE"),h=function(t,e){c._29.call(this),this.type="Wireframe",this.geometry=void 0!==t?t:new d.a,this.material=void 0!==e?e:new o.a({color:16777215*Math.random()})};h.prototype=Object.assign(Object.create(c._29.prototype),{constructor:h,isWireframe:!0,computeLineDistances:(i=new c._105,a=new c._105,function(){for(var t=this.geometry,e=t.attributes.instanceStart,n=t.attributes.instanceEnd,s=new Float32Array(2*e.data.count),r=0,o=0,d=e.data.count;r<d;r++,o+=2)i.fromBufferAttribute(e,r),a.fromBufferAttribute(n,r),s[o]=0===o?0:s[o-1],s[o+1]=s[o]+i.distanceTo(a);var h=new c._3(s,2,1);return t.setAttribute("instanceDistanceStart",new c._6(h,1,0)),t.setAttribute("instanceDistanceEnd",new c._6(h,1,1)),this})});var u=function(t){d.a.call(this),this.type="WireframeGeometry2",this.fromWireframeGeometry(new c._109(t))};u.prototype=Object.assign(Object.create(d.a.prototype),{constructor:u,isWireframeGeometry2:!0});var l={data:function(){return{wireframe:null,renderer:null,scene:null,camera:null,camera2:null,controls:null,wireframe1:null,matLine:null,matLineBasic:null,matLineDashed:null,stats:null,gui:null,insetWidth:null,insetHeight:null}},mounted:function(){this.init(),this.animate()},beforeDestroy:function(){this.gui.destroy()},methods:{init:function(){this.renderer=new this.$THREE.WebGLRenderer({antialias:!0}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setClearColor(0,0),this.renderer.setSize(this.$webglInnerWidth,window.innerHeight),document.getElementsByClassName("webglLinesFatWireframe-container")[0].appendChild(this.renderer.domElement),this.scene=new this.$THREE.Scene,this.camera=new this.$THREE.PerspectiveCamera(40,this.$webglInnerWidth/window.innerHeight,1,1e3),this.camera.position.set(-50,0,50),this.camera2=new this.$THREE.PerspectiveCamera(40,1,1,1e3),this.camera2.position.copy(this.camera.position),this.controls=new r.a(this.camera,this.renderer.domElement),this.controls.minDistance=10,this.controls.maxDistance=500;var t=new this.$THREE.IcosahedronBufferGeometry(20,1),e=new u(t);this.matLine=new o.a({color:4227327,linewidth:5,dashed:!1}),this.wireframe=new h(e,this.matLine),this.wireframe.computeLineDistances(),this.wireframe.scale.set(1,1,1),this.scene.add(this.wireframe),t=new this.$THREE.WireframeGeometry(t),this.matLineBasic=new this.$THREE.LineBasicMaterial({color:4227327}),this.matLineDashed=new this.$THREE.LineDashedMaterial({scale:2,dashSize:1,gapSize:1}),this.wireframe1=new this.$THREE.LineSegments(t,this.matLineBasic),this.wireframe1.computeLineDistances(),this.wireframe1.visible=!1,this.scene.add(this.wireframe1),window.addEventListener("resize",this.onWindowResize,!1),this.onWindowResize(),this.stats=new this.$Stats,this.stats.dom.style.left="280px",document.getElementsByClassName("webglLinesFatWireframe-container")[0].appendChild(this.stats.dom),this.initGui()},onWindowResize:function(){this.$onWindowResize(this.camera,this.renderer),this.insetWidth=window.innerHeight/4,this.insetHeight=window.innerHeight/4,this.camera2.aspect=this.insetWidth/this.insetHeight,this.camera2.updateProjectionMatrix()},animate:function(){requestAnimationFrame(this.animate),this.stats.update(),this.renderer.setClearColor(0,0),this.renderer.setViewport(0,0,this.$webglInnerWidth,window.innerHeight),this.matLine.resolution.set(this.$webglInnerWidth,window.innerHeight),this.renderer.render(this.scene,this.camera),this.renderer.setClearColor(2236962,1),this.renderer.clearDepth(),this.renderer.setScissorTest(!0),this.renderer.setScissor(20,20,this.insetWidth,this.insetHeight),this.renderer.setViewport(20,20,this.insetWidth,this.insetHeight),this.camera2.position.copy(this.camera.position),this.camera2.quaternion.copy(this.camera.quaternion),this.matLine.resolution.set(this.insetWidth,this.insetHeight),this.renderer.render(this.scene,this.camera2),this.renderer.setScissorTest(!1)},initGui:function(){var t=this;this.gui=new s.a;var e={"line type":0,"width (px)":5,dashed:!1,"dash scale":1,"dash / gap":1};this.gui.add(e,"line type",{LineGeometry:0,"gl.LINE":1}).onChange(function(e){switch(e){case"0":t.wireframe.visible=!0,t.wireframe1.visible=!1;break;case"1":t.wireframe.visible=!1,t.wireframe1.visible=!0}}),this.gui.add(e,"width (px)",1,10).onChange(function(e){t.matLine.linewidth=e}),this.gui.add(e,"dashed").onChange(function(e){t.matLine.dashed=e,e?t.matLine.defines.USE_DASH="":delete t.matLine.defines.USE_DASH,t.matLine.needsUpdate=!0,t.wireframe1.material=e?t.matLineDashed:t.matLineBasic}),this.gui.add(e,"dash scale",.5,1,.1).onChange(function(e){t.matLine.dashScale=e,t.matLineDashed.scale=e}),this.gui.add(e,"dash / gap",{"2 : 1":0,"1 : 1":1,"1 : 2":2}).onChange(function(e){switch(e){case"0":t.matLine.dashSize=2,t.matLine.gapSize=1,t.matLineDashed.dashSize=2,t.matLineDashed.gapSize=1;break;case"1":t.matLine.dashSize=1,t.matLine.gapSize=1,t.matLineDashed.dashSize=1,t.matLineDashed.gapSize=1;break;case"2":t.matLine.dashSize=1,t.matLine.gapSize=2,t.matLineDashed.dashSize=1,t.matLineDashed.gapSize=2}})}}},f={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"webglLinesFatWireframe-container"},[e("div",{attrs:{id:"container"}}),this._v(" "),e("div",{attrs:{id:"info"}},[e("a",{attrs:{href:"https://threejs.org",target:"_blank"}},[this._v("three.js")]),this._v(" - fat lines")])])}]};var m=n("VU/8")(l,f,!1,function(t){n("U/yM")},"data-v-c64dc97a",null);e.default=m.exports}});
//# sourceMappingURL=6.58bc234ca33c3848b35e.js.map