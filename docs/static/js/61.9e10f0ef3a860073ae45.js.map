{"version":3,"sources":["webpack:///./src/components/jsm/math/ConvexHull.js","webpack:///./src/components/jsm/geometries/ConvexGeometry.js","webpack:///./src/components/jsm/misc/ConvexObjectBreaker.js","webpack:///src/views/physics/physicsAmmoBreak.vue","webpack:///./src/views/physics/physicsAmmoBreak.vue?f1b2","webpack:///./src/views/physics/physicsAmmoBreak.vue"],"names":["ConvexHull","line3","plane","closestPoint","triangle","Visible","v1","Vector3","this","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","Face","normal","midpoint","area","constant","outside","mark","edge","HalfEdge","vertex","face","prev","next","twin","VertexNode","point","head","tail","Object","assign","prototype","setFromPoints","points","Array","isArray","console","error","length","makeEmpty","i","l","push","compute","setFromObject","object","updateMatrixWorld","traverse","node","geometry","undefined","isGeometry","clone","applyMatrix4","matrixWorld","isBufferGeometry","attribute","attributes","position","count","fromBufferAttribute","containsPoint","distanceToPoint","intersectRay","ray","target","tNear","Infinity","tFar","vN","origin","vD","dot","direction","t","Math","min","max","at","intersectsRay","addVertexToFace","append","insertBefore","removeVertexFromFace","remove","removeAllVerticesFromFace","start","end","removeSubList","deleteFaceVertices","absorbingFace","faceVertices","appendChain","nextVertex","resolveUnassignedPoints","isEmpty","first","maxDistance","maxFace","distance","computeExtremes","j","minVertices","maxVertices","copy","getComponent","setComponent","Number","EPSILON","abs","x","y","z","computeInitialHull","Line3","Plane","v0","v2","v3","extremes","index","set","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","create","getEdge","setTwin","reindexFaces","activeFaces","nextVertexToAdd","eyeVertex","eyeFace","computeHorizon","eyePoint","crossEdge","horizon","twinEdge","oppositeFace","addAdjoiningFace","horizonEdge","addNewFaces","firstSideEdge","previousSideEdge","sideEdge","addVertexToHull","clear","cleanup","a","b","c","e0","e1","e2","Triangle","getNormal","getMidpoint","getArea","distanceTo","lengthSquared","last","insertAfter","__webpack_require__","d","__webpack_exports__","ConvexGeometry_ConvexBufferGeometry","ConvexGeometry","Geometry","call","fromBufferGeometry","ConvexBufferGeometry","mergeVertices","constructor","BufferGeometry","normals","setAttribute","Float32BufferAttribute","ConvexObjectBreaker","minSizeForBreak","smallDelta","tempLine1","tempPlane1","tempPlane2","tempPlane_Cut","tempCM1","tempCM2","tempVector3","tempVector3_2","tempVector3_3","tempVector3_P0","tempVector3_P1","tempVector3_P2","tempVector3_N0","tempVector3_N1","tempVector3_AB","tempVector3_CB","tempResultObjects","object1","object2","segments","prepareBreakableObject","mass","velocity","angularVelocity","breakable","userData","subdivideByImpact","pointOfImpact","maxRadialIterations","maxRandomIterations","debris","addVectors","maxTotalIterations","scope","subdivideRadial","subObject","startAngle","endAngle","numIterations","random","angle","PI","sub","applyAxisAngle","add","cutByPlane","obj1","obj2","output","coords","array","numPoints","numFaces","indices","getIndex","getVertexIndex","faceIdx","vert","idx","points1","points2","delta","numPointPairs","p0","p1","n0","n1","a1","b1","c1","a2","b2","c2","localPlane","updateMatrix","transformPlaneToLocalSpace","matrix","va","vb","vc","segment","i0","i1","mark0","mark1","intersection","intersectLine","segmentedObject1","segmentedObject2","newMass","radius1","numPoints1","divideScalar","p","radius2","numPoints2","numObjects","Mesh","material","quaternion","transformFreeVector","v","m","e","elements","transformFreeVectorInverse","transformTiedVectorInverse","resultPlane","referencePoint","coplanarPoint","physicsAmmoBreak","data","container","stats","camera","controls","scene","renderer","textureLoader","clock","mouseCoords","raycaster","ballMaterial","gravityConstant","collisionConfiguration","dispatcher","broadphase","solver","physicsWorld","margin","convexBreaker","rigidBodies","pos","quat","transformAux1","tempBtVec3_1","objectsToRemove","numObjectsToRemove","impactPoint","impactNormal","mounted","_this","$THREE","Clock","Vector2","Raycaster","MeshPhongMaterial","color","ConvexObjectBreaker_ConvexObjectBreaker","Quaternion","$nextTick","Ammo","then","AmmoLib","init","animate","methods","initGraphics","initPhysics","createObjects","initInput","document","getElementById","PerspectiveCamera","$webglInnerWidth","window","innerHeight","Scene","background","Color","WebGLRenderer","setPixelRatio","devicePixelRatio","setSize","shadowMap","enabled","appendChild","domElement","OrbitControls","update","TextureLoader","ambientLight","AmbientLight","light","DirectionalLight","castShadow","shadow","left","right","top","bottom","near","far","mapSize","$Stats","dom","style","addEventListener","onWindowResize","btDefaultCollisionConfiguration","btCollisionDispatcher","btDbvtBroadphase","btSequentialImpulseConstraintSolver","btDiscreteDynamicsWorld","setGravity","btVector3","btTransform","createObject","halfExtents","BoxBufferGeometry","createDebrisFromBreakableObject","_this2","ground","createParalellepipedWithPhysics","receiveShadow","load","texture","wrapS","RepeatWrapping","wrapT","repeat","map","needsUpdate","towerHalfExtents","createMaterial","bridgeHalfExtents","stoneHalfExtents","mountainHalfExtents","mountainPoints","mountain","sx","sy","sz","shape","btBoxShape","setMargin","createRigidBody","createConvexHullPhysicsShape","body","btVecUserData","threeObject","setUserPointer","removeDebris","removeRigidBody","physicsBody","btConvexHullShape","il","setValue","lastOne","addPoint","physicsShape","vel","angVel","transform","setIdentity","setOrigin","setRotation","btQuaternion","w","motionState","btDefaultMotionState","localInertia","calculateLocalInertia","rbInfo","btRigidBodyConstructionInfo","btRigidBody","setFriction","setLinearVelocity","setAngularVelocity","collided","setActivationState","addRigidBody","createRandomColor","floor","_this3","event","clientX","innerWidth","clientY","setFromCamera","ball","SphereBufferGeometry","ballShape","btSphereShape","ballBody","multiplyScalar","$onWindowResize","requestAnimationFrame","render","deltaTime","getDelta","updatePhysics","stepSimulation","objThree","ms","getMotionState","getWorldTransform","getOrigin","q","getRotation","getNumManifolds","contactManifold","getManifoldByIndexInternal","rb0","castObject","getBody0","rb1","getBody1","threeObject0","getUserPointer","threeObject1","userData0","userData1","breakable0","breakable1","collided0","collided1","contact","maxImpulse","jl","getNumContacts","contactPoint","getContactPoint","getDistance","impulse","getAppliedImpulse","get_m_positionWorldOnB","get_m_normalWorldOnB","getLinearVelocity","getAngularVelocity","fragment","physics_physicsAmmoBreak","$createElement","_self","_c","_m","staticRenderFns","_h","staticClass","attrs","id","_v","Component","normalizeComponent","ssrContext"],"mappings":"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","file":"static/js/61.9e10f0ef3a860073ae45.js","sourcesContent":["import {\r\n\tLine3,\r\n\tPlane,\r\n\tTriangle,\r\n\tVector3\r\n} from \"@/components/build/three.module.js\";\r\n\r\n/**\r\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\r\n */\r\n\r\nvar ConvexHull = ( function () {\r\n\r\n\tvar Visible = 0;\r\n\tvar Deleted = 1;\r\n\r\n\tvar v1 = new Vector3();\r\n\r\n\tfunction ConvexHull() {\r\n\r\n\t\tthis.tolerance = - 1;\r\n\r\n\t\tthis.faces = []; // the generated faces of the convex hull\r\n\t\tthis.newFaces = []; // this array holds the faces that are generated within a single iteration\r\n\r\n\t\t// the vertex lists work as follows:\r\n\t\t//\r\n\t\t// let 'a' and 'b' be 'Face' instances\r\n\t\t// let 'v' be points wrapped as instance of 'Vertex'\r\n\t\t//\r\n\t\t//     [v, v, ..., v, v, v, ...]\r\n\t\t//      ^             ^\r\n\t\t//      |             |\r\n\t\t//  a.outside     b.outside\r\n\t\t//\r\n\t\tthis.assigned = new VertexList();\r\n\t\tthis.unassigned = new VertexList();\r\n\r\n\t\tthis.vertices = []; \t// vertices of the hull (internal representation of given geometry data)\r\n\r\n\t}\r\n\r\n\tObject.assign( ConvexHull.prototype, {\r\n\r\n\t\tsetFromPoints: function ( points ) {\r\n\r\n\t\t\tif ( Array.isArray( points ) !== true ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.ConvexHull: Points parameter is not an array.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( points.length < 4 ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.ConvexHull: The algorithm needs at least four points.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tthis.vertices.push( new VertexNode( points[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.compute();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromObject: function ( object ) {\r\n\r\n\t\t\tvar points = [];\r\n\r\n\t\t\tobject.updateMatrixWorld( true );\r\n\r\n\t\t\tobject.traverse( function ( node ) {\r\n\r\n\t\t\t\tvar i, l, point;\r\n\r\n\t\t\t\tvar geometry = node.geometry;\r\n\r\n\t\t\t\tif ( geometry !== undefined ) {\r\n\r\n\t\t\t\t\tif ( geometry.isGeometry ) {\r\n\r\n\t\t\t\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint = vertices[ i ].clone();\r\n\t\t\t\t\t\t\tpoint.applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\tpoints.push( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\t\t\t\tvar attribute = geometry.attributes.position;\r\n\r\n\t\t\t\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tpoint = new Vector3();\r\n\r\n\t\t\t\t\t\t\t\tpoint.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\t\tpoints.push( point );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn this.setFromPoints( points );\r\n\r\n\t\t},\r\n\r\n\t\tcontainsPoint: function ( point ) {\r\n\r\n\t\t\tvar faces = this.faces;\r\n\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\t\t// compute signed distance and check on what half space the point lies\r\n\r\n\t\t\t\tif ( face.distanceToPoint( point ) > this.tolerance ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t},\r\n\r\n\t\tintersectRay: function ( ray, target ) {\r\n\r\n\t\t\t// based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\r\n\r\n\t\t\tvar faces = this.faces;\r\n\r\n\t\t\tvar tNear = - Infinity;\r\n\t\t\tvar tFar = Infinity;\r\n\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\t\t// interpret faces as planes for the further computation\r\n\r\n\t\t\t\tvar vN = face.distanceToPoint( ray.origin );\r\n\t\t\t\tvar vD = face.normal.dot( ray.direction );\r\n\r\n\t\t\t\t// if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\r\n\t\t\t\t// the ray is turned away or parallel to the plane, there is no intersection\r\n\r\n\t\t\t\tif ( vN > 0 && vD >= 0 ) return null;\r\n\r\n\t\t\t\t// compute the distance from the rayâ€™s origin to the intersection with the plane\r\n\r\n\t\t\t\tvar t = ( vD !== 0 ) ? ( - vN / vD ) : 0;\r\n\r\n\t\t\t\t// only proceed if the distance is positive. a negative distance means the intersection point\r\n\t\t\t\t// lies \"behind\" the origin\r\n\r\n\t\t\t\tif ( t <= 0 ) continue;\r\n\r\n\t\t\t\t// now categorized plane as front-facing or back-facing\r\n\r\n\t\t\t\tif ( vD > 0 ) {\r\n\r\n\t\t\t\t\t//  plane faces away from the ray, so this plane is a back-face\r\n\r\n\t\t\t\t\ttFar = Math.min( t, tFar );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// front-face\r\n\r\n\t\t\t\t\ttNear = Math.max( t, tNear );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( tNear > tFar ) {\r\n\r\n\t\t\t\t\t// if tNear ever is greater than tFar, the ray must miss the convex hull\r\n\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// evaluate intersection point\r\n\r\n\t\t\t// always try tNear first since its the closer intersection point\r\n\r\n\t\t\tif ( tNear !== - Infinity ) {\r\n\r\n\t\t\t\tray.at( tNear, target );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tray.at( tFar, target );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t},\r\n\r\n\t\tintersectsRay: function ( ray ) {\r\n\r\n\t\t\treturn this.intersectRay( ray, v1 ) !== null;\r\n\r\n\t\t},\r\n\r\n\t\tmakeEmpty: function () {\r\n\r\n\t\t\tthis.faces = [];\r\n\t\t\tthis.vertices = [];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\r\n\r\n\t\taddVertexToFace: function ( vertex, face ) {\r\n\r\n\t\t\tvertex.face = face;\r\n\r\n\t\t\tif ( face.outside === null ) {\r\n\r\n\t\t\t\tthis.assigned.append( vertex );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.assigned.insertBefore( face.outside, vertex );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tface.outside = vertex;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Removes a vertex from the 'assigned' list of vertices and from the given face\r\n\r\n\t\tremoveVertexFromFace: function ( vertex, face ) {\r\n\r\n\t\t\tif ( vertex === face.outside ) {\r\n\r\n\t\t\t\t// fix face.outside link\r\n\r\n\t\t\t\tif ( vertex.next !== null && vertex.next.face === face ) {\r\n\r\n\t\t\t\t\t// face has at least 2 outside vertices, move the 'outside' reference\r\n\r\n\t\t\t\t\tface.outside = vertex.next;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// vertex was the only outside vertex that face had\r\n\r\n\t\t\t\t\tface.outside = null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.assigned.remove( vertex );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\r\n\r\n\t\tremoveAllVerticesFromFace: function ( face ) {\r\n\r\n\t\t\tif ( face.outside !== null ) {\r\n\r\n\t\t\t\t// reference to the first and last vertex of this face\r\n\r\n\t\t\t\tvar start = face.outside;\r\n\t\t\t\tvar end = face.outside;\r\n\r\n\t\t\t\twhile ( end.next !== null && end.next.face === face ) {\r\n\r\n\t\t\t\t\tend = end.next;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.assigned.removeSubList( start, end );\r\n\r\n\t\t\t\t// fix references\r\n\r\n\t\t\t\tstart.prev = end.next = null;\r\n\t\t\t\tface.outside = null;\r\n\r\n\t\t\t\treturn start;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t// Removes all the visible vertices that 'face' is able to see\r\n\r\n\t\tdeleteFaceVertices: function ( face, absorbingFace ) {\r\n\r\n\t\t\tvar faceVertices = this.removeAllVerticesFromFace( face );\r\n\r\n\t\t\tif ( faceVertices !== undefined ) {\r\n\r\n\t\t\t\tif ( absorbingFace === undefined ) {\r\n\r\n\t\t\t\t\t// mark the vertices to be reassigned to some other face\r\n\r\n\t\t\t\t\tthis.unassigned.appendChain( faceVertices );\r\n\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// if there's an absorbing face try to assign as many vertices as possible to it\r\n\r\n\t\t\t\t\tvar vertex = faceVertices;\r\n\r\n\t\t\t\t\tdo {\r\n\r\n\t\t\t\t\t\t// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\r\n\t\t\t\t\t\t// will be changed by upcoming method calls\r\n\r\n\t\t\t\t\t\tvar nextVertex = vertex.next;\r\n\r\n\t\t\t\t\t\tvar distance = absorbingFace.distanceToPoint( vertex.point );\r\n\r\n\t\t\t\t\t\t// check if 'vertex' is able to see 'absorbingFace'\r\n\r\n\t\t\t\t\t\tif ( distance > this.tolerance ) {\r\n\r\n\t\t\t\t\t\t\tthis.addVertexToFace( vertex, absorbingFace );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tthis.unassigned.append( vertex );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// now assign next vertex\r\n\r\n\t\t\t\t\t\tvertex = nextVertex;\r\n\r\n\t\t\t\t\t} while ( vertex !== null );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Reassigns as many vertices as possible from the unassigned list to the new faces\r\n\r\n\t\tresolveUnassignedPoints: function ( newFaces ) {\r\n\r\n\t\t\tif ( this.unassigned.isEmpty() === false ) {\r\n\r\n\t\t\t\tvar vertex = this.unassigned.first();\r\n\r\n\t\t\t\tdo {\r\n\r\n\t\t\t\t\t// buffer 'next' reference, see .deleteFaceVertices()\r\n\r\n\t\t\t\t\tvar nextVertex = vertex.next;\r\n\r\n\t\t\t\t\tvar maxDistance = this.tolerance;\r\n\r\n\t\t\t\t\tvar maxFace = null;\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < newFaces.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar face = newFaces[ i ];\r\n\r\n\t\t\t\t\t\tif ( face.mark === Visible ) {\r\n\r\n\t\t\t\t\t\t\tvar distance = face.distanceToPoint( vertex.point );\r\n\r\n\t\t\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\t\t\tmaxFace = face;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( maxDistance > 1000 * this.tolerance ) break;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// 'maxFace' can be null e.g. if there are identical vertices\r\n\r\n\t\t\t\t\tif ( maxFace !== null ) {\r\n\r\n\t\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvertex = nextVertex;\r\n\r\n\t\t\t\t} while ( vertex !== null );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Computes the extremes of a simplex which will be the initial hull\r\n\r\n\t\tcomputeExtremes: function () {\r\n\r\n\t\t\tvar min = new Vector3();\r\n\t\t\tvar max = new Vector3();\r\n\r\n\t\t\tvar minVertices = [];\r\n\t\t\tvar maxVertices = [];\r\n\r\n\t\t\tvar i, l, j;\r\n\r\n\t\t\t// initially assume that the first vertex is the min/max\r\n\r\n\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tminVertices[ i ] = maxVertices[ i ] = this.vertices[ 0 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.copy( this.vertices[ 0 ].point );\r\n\t\t\tmax.copy( this.vertices[ 0 ].point );\r\n\r\n\t\t\t// compute the min/max vertex on all six directions\r\n\r\n\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\t\tvar point = vertex.point;\r\n\r\n\t\t\t\t// update the min coordinates\r\n\r\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\tif ( point.getComponent( j ) < min.getComponent( j ) ) {\r\n\r\n\t\t\t\t\t\tmin.setComponent( j, point.getComponent( j ) );\r\n\t\t\t\t\t\tminVertices[ j ] = vertex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// update the max coordinates\r\n\r\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\tif ( point.getComponent( j ) > max.getComponent( j ) ) {\r\n\r\n\t\t\t\t\t\tmax.setComponent( j, point.getComponent( j ) );\r\n\t\t\t\t\t\tmaxVertices[ j ] = vertex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// use min/max vectors to compute an optimal epsilon\r\n\r\n\t\t\tthis.tolerance = 3 * Number.EPSILON * (\r\n\t\t\t\tMath.max( Math.abs( min.x ), Math.abs( max.x ) ) +\r\n\t\t\t\tMath.max( Math.abs( min.y ), Math.abs( max.y ) ) +\r\n\t\t\t\tMath.max( Math.abs( min.z ), Math.abs( max.z ) )\r\n\t\t\t);\r\n\r\n\t\t\treturn { min: minVertices, max: maxVertices };\r\n\r\n\t\t},\r\n\r\n\t\t// Computes the initial simplex assigning to its faces all the points\r\n\t\t// that are candidates to form part of the hull\r\n\r\n\t\tcomputeInitialHull: function () {\r\n\r\n\t\t\tvar line3, plane, closestPoint;\r\n\r\n\t\t\treturn function computeInitialHull() {\r\n\r\n\t\t\t\tif ( line3 === undefined ) {\r\n\r\n\t\t\t\t\tline3 = new Line3();\r\n\t\t\t\t\tplane = new Plane();\r\n\t\t\t\t\tclosestPoint = new Vector3();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar vertex, vertices = this.vertices;\r\n\t\t\t\tvar extremes = this.computeExtremes();\r\n\t\t\t\tvar min = extremes.min;\r\n\t\t\t\tvar max = extremes.max;\r\n\r\n\t\t\t\tvar v0, v1, v2, v3;\r\n\t\t\t\tvar i, l, j;\r\n\r\n\t\t\t\t// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\r\n\t\t\t\t// (max.x - min.x)\r\n\t\t\t\t// (max.y - min.y)\r\n\t\t\t\t// (max.z - min.z)\r\n\r\n\t\t\t\tvar distance, maxDistance = 0;\r\n\t\t\t\tvar index = 0;\r\n\r\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tdistance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );\r\n\r\n\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\tindex = i;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tv0 = min[ index ];\r\n\t\t\t\tv1 = max[ index ];\r\n\r\n\t\t\t\t// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\r\n\r\n\t\t\t\tmaxDistance = 0;\r\n\t\t\t\tline3.set( v0.point, v1.point );\r\n\r\n\t\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvertex = vertices[ i ];\r\n\r\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 ) {\r\n\r\n\t\t\t\t\t\tline3.closestPointToPoint( vertex.point, true, closestPoint );\r\n\r\n\t\t\t\t\t\tdistance = closestPoint.distanceToSquared( vertex.point );\r\n\r\n\t\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\t\tv2 = vertex;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\r\n\r\n\t\t\t\tmaxDistance = - 1;\r\n\t\t\t\tplane.setFromCoplanarPoints( v0.point, v1.point, v2.point );\r\n\r\n\t\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvertex = vertices[ i ];\r\n\r\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {\r\n\r\n\t\t\t\t\t\tdistance = Math.abs( plane.distanceToPoint( vertex.point ) );\r\n\r\n\t\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\t\tv3 = vertex;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar faces = [];\r\n\r\n\t\t\t\tif ( plane.distanceToPoint( v3.point ) < 0 ) {\r\n\r\n\t\t\t\t\t// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\r\n\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tFace.create( v0, v1, v2 ),\r\n\t\t\t\t\t\tFace.create( v3, v1, v0 ),\r\n\t\t\t\t\t\tFace.create( v3, v2, v1 ),\r\n\t\t\t\t\t\tFace.create( v3, v0, v2 )\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// set the twin edge\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tj = ( i + 1 ) % 3;\r\n\r\n\t\t\t\t\t\t// join face[ i ] i > 0, with the first face\r\n\r\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );\r\n\r\n\t\t\t\t\t\t// join face[ i ] with face[ i + 1 ], 1 <= i <= 3\r\n\r\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\r\n\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tFace.create( v0, v2, v1 ),\r\n\t\t\t\t\t\tFace.create( v3, v0, v1 ),\r\n\t\t\t\t\t\tFace.create( v3, v1, v2 ),\r\n\t\t\t\t\t\tFace.create( v3, v2, v0 )\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// set the twin edge\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tj = ( i + 1 ) % 3;\r\n\r\n\t\t\t\t\t\t// join face[ i ] i > 0, with the first face\r\n\r\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );\r\n\r\n\t\t\t\t\t\t// join face[ i ] with face[ i + 1 ]\r\n\r\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// the initial hull is the tetrahedron\r\n\r\n\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\tthis.faces.push( faces[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// initial assignment of vertices to the faces of the tetrahedron\r\n\r\n\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvertex = vertices[ i ];\r\n\r\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {\r\n\r\n\t\t\t\t\t\tmaxDistance = this.tolerance;\r\n\t\t\t\t\t\tvar maxFace = null;\r\n\r\n\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tdistance = this.faces[ j ].distanceToPoint( vertex.point );\r\n\r\n\t\t\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\t\t\tmaxFace = this.faces[ j ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( maxFace !== null ) {\r\n\r\n\t\t\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t};\r\n\r\n\t\t}(),\r\n\r\n\t\t// Removes inactive faces\r\n\r\n\t\treindexFaces: function () {\r\n\r\n\t\t\tvar activeFaces = [];\r\n\r\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\r\n\r\n\t\t\t\tvar face = this.faces[ i ];\r\n\r\n\t\t\t\tif ( face.mark === Visible ) {\r\n\r\n\t\t\t\t\tactiveFaces.push( face );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.faces = activeFaces;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Finds the next vertex to create faces with the current hull\r\n\r\n\t\tnextVertexToAdd: function () {\r\n\r\n\t\t\t// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\r\n\r\n\t\t\tif ( this.assigned.isEmpty() === false ) {\r\n\r\n\t\t\t\tvar eyeVertex, maxDistance = 0;\r\n\r\n\t\t\t\t// grap the first available face and start with the first visible vertex of that face\r\n\r\n\t\t\t\tvar eyeFace = this.assigned.first().face;\r\n\t\t\t\tvar vertex = eyeFace.outside;\r\n\r\n\t\t\t\t// now calculate the farthest vertex that face can see\r\n\r\n\t\t\t\tdo {\r\n\r\n\t\t\t\t\tvar distance = eyeFace.distanceToPoint( vertex.point );\r\n\r\n\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\teyeVertex = vertex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvertex = vertex.next;\r\n\r\n\t\t\t\t} while ( vertex !== null && vertex.face === eyeFace );\r\n\r\n\t\t\t\treturn eyeVertex;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t// Computes a chain of half edges in CCW order called the 'horizon'.\r\n\t\t// For an edge to be part of the horizon it must join a face that can see\r\n\t\t// 'eyePoint' and a face that cannot see 'eyePoint'.\r\n\r\n\t\tcomputeHorizon: function ( eyePoint, crossEdge, face, horizon ) {\r\n\r\n\t\t\t// moves face's vertices to the 'unassigned' vertex list\r\n\r\n\t\t\tthis.deleteFaceVertices( face );\r\n\r\n\t\t\tface.mark = Deleted;\r\n\r\n\t\t\tvar edge;\r\n\r\n\t\t\tif ( crossEdge === null ) {\r\n\r\n\t\t\t\tedge = crossEdge = face.getEdge( 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// start from the next edge since 'crossEdge' was already analyzed\r\n\t\t\t\t// (actually 'crossEdge.twin' was the edge who called this method recursively)\r\n\r\n\t\t\t\tedge = crossEdge.next;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvar twinEdge = edge.twin;\r\n\t\t\t\tvar oppositeFace = twinEdge.face;\r\n\r\n\t\t\t\tif ( oppositeFace.mark === Visible ) {\r\n\r\n\t\t\t\t\tif ( oppositeFace.distanceToPoint( eyePoint ) > this.tolerance ) {\r\n\r\n\t\t\t\t\t\t// the opposite face can see the vertex, so proceed with next edge\r\n\r\n\t\t\t\t\t\tthis.computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// the opposite face can't see the vertex, so this edge is part of the horizon\r\n\r\n\t\t\t\t\t\thorizon.push( edge );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tedge = edge.next;\r\n\r\n\t\t\t} while ( edge !== crossEdge );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\r\n\r\n\t\taddAdjoiningFace: function ( eyeVertex, horizonEdge ) {\r\n\r\n\t\t\t// all the half edges are created in ccw order thus the face is always pointing outside the hull\r\n\r\n\t\t\tvar face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );\r\n\r\n\t\t\tthis.faces.push( face );\r\n\r\n\t\t\t// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\r\n\r\n\t\t\tface.getEdge( - 1 ).setTwin( horizonEdge.twin );\r\n\r\n\t\t\treturn face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex\r\n\r\n\r\n\t\t},\r\n\r\n\t\t//  Adds 'horizon.length' faces to the hull, each face will be linked with the\r\n\t\t//  horizon opposite face and the face on the left/right\r\n\r\n\t\taddNewFaces: function ( eyeVertex, horizon ) {\r\n\r\n\t\t\tthis.newFaces = [];\r\n\r\n\t\t\tvar firstSideEdge = null;\r\n\t\t\tvar previousSideEdge = null;\r\n\r\n\t\t\tfor ( var i = 0; i < horizon.length; i ++ ) {\r\n\r\n\t\t\t\tvar horizonEdge = horizon[ i ];\r\n\r\n\t\t\t\t// returns the right side edge\r\n\r\n\t\t\t\tvar sideEdge = this.addAdjoiningFace( eyeVertex, horizonEdge );\r\n\r\n\t\t\t\tif ( firstSideEdge === null ) {\r\n\r\n\t\t\t\t\tfirstSideEdge = sideEdge;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\r\n\r\n\t\t\t\t\tsideEdge.next.setTwin( previousSideEdge );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.newFaces.push( sideEdge.face );\r\n\t\t\t\tpreviousSideEdge = sideEdge;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// perform final join of new faces\r\n\r\n\t\t\tfirstSideEdge.next.setTwin( previousSideEdge );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Adds a vertex to the hull\r\n\r\n\t\taddVertexToHull: function ( eyeVertex ) {\r\n\r\n\t\t\tvar horizon = [];\r\n\r\n\t\t\tthis.unassigned.clear();\r\n\r\n\t\t\t// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\r\n\r\n\t\t\tthis.removeVertexFromFace( eyeVertex, eyeVertex.face );\r\n\r\n\t\t\tthis.computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );\r\n\r\n\t\t\tthis.addNewFaces( eyeVertex, horizon );\r\n\r\n\t\t\t// reassign 'unassigned' vertices to the new faces\r\n\r\n\t\t\tthis.resolveUnassignedPoints( this.newFaces );\r\n\r\n\t\t\treturn\tthis;\r\n\r\n\t\t},\r\n\r\n\t\tcleanup: function () {\r\n\r\n\t\t\tthis.assigned.clear();\r\n\t\t\tthis.unassigned.clear();\r\n\t\t\tthis.newFaces = [];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tcompute: function () {\r\n\r\n\t\t\tvar vertex;\r\n\r\n\t\t\tthis.computeInitialHull();\r\n\r\n\t\t\t// add all available vertices gradually to the hull\r\n\r\n\t\t\twhile ( ( vertex = this.nextVertexToAdd() ) !== undefined ) {\r\n\r\n\t\t\t\tthis.addVertexToHull( vertex );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.reindexFaces();\r\n\r\n\t\t\tthis.cleanup();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\t//\r\n\r\n\tfunction Face() {\r\n\r\n\t\tthis.normal = new Vector3();\r\n\t\tthis.midpoint = new Vector3();\r\n\t\tthis.area = 0;\r\n\r\n\t\tthis.constant = 0; // signed distance from face to the origin\r\n\t\tthis.outside = null; // reference to a vertex in a vertex list this face can see\r\n\t\tthis.mark = Visible;\r\n\t\tthis.edge = null;\r\n\r\n\t}\r\n\r\n\tObject.assign( Face, {\r\n\r\n\t\tcreate: function ( a, b, c ) {\r\n\r\n\t\t\tvar face = new Face();\r\n\r\n\t\t\tvar e0 = new HalfEdge( a, face );\r\n\t\t\tvar e1 = new HalfEdge( b, face );\r\n\t\t\tvar e2 = new HalfEdge( c, face );\r\n\r\n\t\t\t// join edges\r\n\r\n\t\t\te0.next = e2.prev = e1;\r\n\t\t\te1.next = e0.prev = e2;\r\n\t\t\te2.next = e1.prev = e0;\r\n\r\n\t\t\t// main half edge reference\r\n\r\n\t\t\tface.edge = e0;\r\n\r\n\t\t\treturn face.compute();\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\tObject.assign( Face.prototype, {\r\n\r\n\t\tgetEdge: function ( i ) {\r\n\r\n\t\t\tvar edge = this.edge;\r\n\r\n\t\t\twhile ( i > 0 ) {\r\n\r\n\t\t\t\tedge = edge.next;\r\n\t\t\t\ti --;\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhile ( i < 0 ) {\r\n\r\n\t\t\t\tedge = edge.prev;\r\n\t\t\t\ti ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn edge;\r\n\r\n\t\t},\r\n\r\n\t\tcompute: function () {\r\n\r\n\t\t\tvar triangle;\r\n\r\n\t\t\treturn function compute() {\r\n\r\n\t\t\t\tif ( triangle === undefined ) triangle = new Triangle();\r\n\r\n\t\t\t\tvar a = this.edge.tail();\r\n\t\t\t\tvar b = this.edge.head();\r\n\t\t\t\tvar c = this.edge.next.head();\r\n\r\n\t\t\t\ttriangle.set( a.point, b.point, c.point );\r\n\r\n\t\t\t\ttriangle.getNormal( this.normal );\r\n\t\t\t\ttriangle.getMidpoint( this.midpoint );\r\n\t\t\t\tthis.area = triangle.getArea();\r\n\r\n\t\t\t\tthis.constant = this.normal.dot( this.midpoint );\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t};\r\n\r\n\t\t}(),\r\n\r\n\t\tdistanceToPoint: function ( point ) {\r\n\r\n\t\t\treturn this.normal.dot( point ) - this.constant;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\t// Entity for a Doubly-Connected Edge List (DCEL).\r\n\r\n\tfunction HalfEdge( vertex, face ) {\r\n\r\n\t\tthis.vertex = vertex;\r\n\t\tthis.prev = null;\r\n\t\tthis.next = null;\r\n\t\tthis.twin = null;\r\n\t\tthis.face = face;\r\n\r\n\t}\r\n\r\n\tObject.assign( HalfEdge.prototype, {\r\n\r\n\t\thead: function () {\r\n\r\n\t\t\treturn this.vertex;\r\n\r\n\t\t},\r\n\r\n\t\ttail: function () {\r\n\r\n\t\t\treturn this.prev ? this.prev.vertex : null;\r\n\r\n\t\t},\r\n\r\n\t\tlength: function () {\r\n\r\n\t\t\tvar head = this.head();\r\n\t\t\tvar tail = this.tail();\r\n\r\n\t\t\tif ( tail !== null ) {\r\n\r\n\t\t\t\treturn tail.point.distanceTo( head.point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn - 1;\r\n\r\n\t\t},\r\n\r\n\t\tlengthSquared: function () {\r\n\r\n\t\t\tvar head = this.head();\r\n\t\t\tvar tail = this.tail();\r\n\r\n\t\t\tif ( tail !== null ) {\r\n\r\n\t\t\t\treturn tail.point.distanceToSquared( head.point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn - 1;\r\n\r\n\t\t},\r\n\r\n\t\tsetTwin: function ( edge ) {\r\n\r\n\t\t\tthis.twin = edge;\r\n\t\t\tedge.twin = this;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\t// A vertex as a double linked list node.\r\n\r\n\tfunction VertexNode( point ) {\r\n\r\n\t\tthis.point = point;\r\n\t\tthis.prev = null;\r\n\t\tthis.next = null;\r\n\t\tthis.face = null; // the face that is able to see this vertex\r\n\r\n\t}\r\n\r\n\t// A double linked list that contains vertex nodes.\r\n\r\n\tfunction VertexList() {\r\n\r\n\t\tthis.head = null;\r\n\t\tthis.tail = null;\r\n\r\n\t}\r\n\r\n\tObject.assign( VertexList.prototype, {\r\n\r\n\t\tfirst: function () {\r\n\r\n\t\t\treturn this.head;\r\n\r\n\t\t},\r\n\r\n\t\tlast: function () {\r\n\r\n\t\t\treturn this.tail;\r\n\r\n\t\t},\r\n\r\n\t\tclear: function () {\r\n\r\n\t\t\tthis.head = this.tail = null;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Inserts a vertex before the target vertex\r\n\r\n\t\tinsertBefore: function ( target, vertex ) {\r\n\r\n\t\t\tvertex.prev = target.prev;\r\n\t\t\tvertex.next = target;\r\n\r\n\t\t\tif ( vertex.prev === null ) {\r\n\r\n\t\t\t\tthis.head = vertex;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertex.prev.next = vertex;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.prev = vertex;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Inserts a vertex after the target vertex\r\n\r\n\t\tinsertAfter: function ( target, vertex ) {\r\n\r\n\t\t\tvertex.prev = target;\r\n\t\t\tvertex.next = target.next;\r\n\r\n\t\t\tif ( vertex.next === null ) {\r\n\r\n\t\t\t\tthis.tail = vertex;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertex.next.prev = vertex;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.next = vertex;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Appends a vertex to the end of the linked list\r\n\r\n\t\tappend: function ( vertex ) {\r\n\r\n\t\t\tif ( this.head === null ) {\r\n\r\n\t\t\t\tthis.head = vertex;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.tail.next = vertex;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvertex.prev = this.tail;\r\n\t\t\tvertex.next = null; // the tail has no subsequent vertex\r\n\r\n\t\t\tthis.tail = vertex;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Appends a chain of vertices where 'vertex' is the head.\r\n\r\n\t\tappendChain: function ( vertex ) {\r\n\r\n\t\t\tif ( this.head === null ) {\r\n\r\n\t\t\t\tthis.head = vertex;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.tail.next = vertex;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvertex.prev = this.tail;\r\n\r\n\t\t\t// ensure that the 'tail' reference points to the last vertex of the chain\r\n\r\n\t\t\twhile ( vertex.next !== null ) {\r\n\r\n\t\t\t\tvertex = vertex.next;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.tail = vertex;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Removes a vertex from the linked list\r\n\r\n\t\tremove: function ( vertex ) {\r\n\r\n\t\t\tif ( vertex.prev === null ) {\r\n\r\n\t\t\t\tthis.head = vertex.next;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertex.prev.next = vertex.next;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( vertex.next === null ) {\r\n\r\n\t\t\t\tthis.tail = vertex.prev;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertex.next.prev = vertex.prev;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\r\n\r\n\t\tremoveSubList: function ( a, b ) {\r\n\r\n\t\t\tif ( a.prev === null ) {\r\n\r\n\t\t\t\tthis.head = b.next;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ta.prev.next = b.next;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( b.next === null ) {\r\n\r\n\t\t\t\tthis.tail = a.prev;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tb.next.prev = a.prev;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tisEmpty: function () {\r\n\r\n\t\t\treturn this.head === null;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn ConvexHull;\r\n\r\n} )();\r\n\r\nexport { ConvexHull };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/jsm/math/ConvexHull.js","import {\r\n\tBufferGeometry,\r\n\tFloat32BufferAttribute,\r\n\tGeometry\r\n} from \"@/components/build/three.module.js\";\r\nimport { ConvexHull } from \"../math/ConvexHull.js\";\r\n\r\n// ConvexGeometry\r\n\r\nvar ConvexGeometry = function ( points ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.fromBufferGeometry( new ConvexBufferGeometry( points ) );\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nConvexGeometry.prototype = Object.create( Geometry.prototype );\r\nConvexGeometry.prototype.constructor = ConvexGeometry;\r\n\r\n// ConvexBufferGeometry\r\n\r\nvar ConvexBufferGeometry = function ( points ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\t// buffers\r\n\r\n\tvar vertices = [];\r\n\tvar normals = [];\r\n\r\n\tif ( ConvexHull === undefined ) {\r\n\r\n\t\tconsole.error( 'THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull' );\r\n\r\n\t}\r\n\r\n\tvar convexHull = new ConvexHull().setFromPoints( points );\r\n\r\n\t// generate vertices and normals\r\n\r\n\tvar faces = convexHull.faces;\r\n\r\n\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\tvar face = faces[ i ];\r\n\t\tvar edge = face.edge;\r\n\r\n\t\t// we move along a doubly-connected edge list to access all face points (see HalfEdge docs)\r\n\r\n\t\tdo {\r\n\r\n\t\t\tvar point = edge.head().point;\r\n\r\n\t\t\tvertices.push( point.x, point.y, point.z );\r\n\t\t\tnormals.push( face.normal.x, face.normal.y, face.normal.z );\r\n\r\n\t\t\tedge = edge.next;\r\n\r\n\t\t} while ( edge !== face.edge );\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\r\n};\r\n\r\nConvexBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nConvexBufferGeometry.prototype.constructor = ConvexBufferGeometry;\r\n\r\nexport { ConvexGeometry, ConvexBufferGeometry };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/jsm/geometries/ConvexGeometry.js","import {\r\n\tLine3,\r\n\tMesh,\r\n\tPlane,\r\n\tVector3\r\n} from \"@/components/build/three.module.js\";\r\nimport { ConvexBufferGeometry } from \"../geometries/ConvexGeometry.js\";\r\n\r\n/**\r\n * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.\r\n *\r\n * Usage:\r\n *\r\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\r\n *\r\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)\r\n *\r\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\r\n *\r\n * Requisites for the object:\r\n *\r\n *  - Mesh object must have a BufferGeometry (not Geometry) and a Material\r\n *\r\n *  - Vertex normals must be planar (not smoothed)\r\n *\r\n *  - The geometry must be convex (this is not checked in the library). You can create convex\r\n *  geometries with ConvexBufferGeometry. The BoxBufferGeometry, SphereBufferGeometry and other convex primitives\r\n *  can also be used.\r\n *\r\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\r\n * Use with caution and read the code when using with other libs.\r\n *\r\n * @param {double} minSizeForBreak Min size a debris can have to break.\r\n * @param {double} smallDelta Max distance to consider that a point belongs to a plane.\r\n *\r\n*/\r\n\r\nvar ConvexObjectBreaker = function ( minSizeForBreak, smallDelta ) {\r\n\r\n\tthis.minSizeForBreak = minSizeForBreak || 1.4;\r\n\tthis.smallDelta = smallDelta || 0.0001;\r\n\r\n\tthis.tempLine1 = new Line3();\r\n\tthis.tempPlane1 = new Plane();\r\n\tthis.tempPlane2 = new Plane();\r\n\tthis.tempPlane_Cut = new Plane();\r\n\tthis.tempCM1 = new Vector3();\r\n\tthis.tempCM2 = new Vector3();\r\n\tthis.tempVector3 = new Vector3();\r\n\tthis.tempVector3_2 = new Vector3();\r\n\tthis.tempVector3_3 = new Vector3();\r\n\tthis.tempVector3_P0 = new Vector3();\r\n\tthis.tempVector3_P1 = new Vector3();\r\n\tthis.tempVector3_P2 = new Vector3();\r\n\tthis.tempVector3_N0 = new Vector3();\r\n\tthis.tempVector3_N1 = new Vector3();\r\n\tthis.tempVector3_AB = new Vector3();\r\n\tthis.tempVector3_CB = new Vector3();\r\n\tthis.tempResultObjects = { object1: null, object2: null };\r\n\r\n\tthis.segments = [];\r\n\tvar n = 30 * 30;\r\n\tfor ( var i = 0; i < n; i ++ ) this.segments[ i ] = false;\r\n\r\n};\r\n\r\nConvexObjectBreaker.prototype = {\r\n\r\n\tconstructor: ConvexObjectBreaker,\r\n\r\n\tprepareBreakableObject: function ( object, mass, velocity, angularVelocity, breakable ) {\r\n\r\n\t\t// object is a Object3d (normally a Mesh), must have a BufferGeometry, and it must be convex.\r\n\t\t// Its material property is propagated to its children (sub-pieces)\r\n\t\t// mass must be > 0\r\n\r\n\t\tif ( ! object.geometry.isBufferGeometry ) {\r\n\r\n\t\t\tconsole.error( 'THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar userData = object.userData;\r\n\t\tuserData.mass = mass;\r\n\t\tuserData.velocity = velocity.clone();\r\n\t\tuserData.angularVelocity = angularVelocity.clone();\r\n\t\tuserData.breakable = breakable;\r\n\r\n\t},\r\n\r\n\t/*\r\n\t * @param {int} maxRadialIterations Iterations for radial cuts.\r\n\t * @param {int} maxRandomIterations Max random iterations for not-radial cuts\r\n\t *\r\n\t * Returns the array of pieces\r\n\t */\r\n\tsubdivideByImpact: function ( object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations ) {\r\n\r\n\t\tvar debris = [];\r\n\r\n\t\tvar tempPlane1 = this.tempPlane1;\r\n\t\tvar tempPlane2 = this.tempPlane2;\r\n\r\n\t\tthis.tempVector3.addVectors( pointOfImpact, normal );\r\n\t\ttempPlane1.setFromCoplanarPoints( pointOfImpact, object.position, this.tempVector3 );\r\n\r\n\t\tvar maxTotalIterations = maxRandomIterations + maxRadialIterations;\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tfunction subdivideRadial( subObject, startAngle, endAngle, numIterations ) {\r\n\r\n\t\t\tif ( Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations ) {\r\n\r\n\t\t\t\tdebris.push( subObject );\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar angle = Math.PI;\r\n\r\n\t\t\tif ( numIterations === 0 ) {\r\n\r\n\t\t\t\ttempPlane2.normal.copy( tempPlane1.normal );\r\n\t\t\t\ttempPlane2.constant = tempPlane1.constant;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( numIterations <= maxRadialIterations ) {\r\n\r\n\t\t\t\t\tangle = ( endAngle - startAngle ) * ( 0.2 + 0.6 * Math.random() ) + startAngle;\r\n\r\n\t\t\t\t\t// Rotate tempPlane2 at impact point around normal axis and the angle\r\n\t\t\t\t\tscope.tempVector3_2.copy( object.position ).sub( pointOfImpact ).applyAxisAngle( normal, angle ).add( pointOfImpact );\r\n\t\t\t\t\ttempPlane2.setFromCoplanarPoints( pointOfImpact, scope.tempVector3, scope.tempVector3_2 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tangle = ( ( 0.5 * ( numIterations & 1 ) ) + 0.2 * ( 2 - Math.random() ) ) * Math.PI;\r\n\r\n\t\t\t\t\t// Rotate tempPlane2 at object position around normal axis and the angle\r\n\t\t\t\t\tscope.tempVector3_2.copy( pointOfImpact ).sub( subObject.position ).applyAxisAngle( normal, angle ).add( subObject.position );\r\n\t\t\t\t\tscope.tempVector3_3.copy( normal ).add( subObject.position );\r\n\t\t\t\t\ttempPlane2.setFromCoplanarPoints( subObject.position, scope.tempVector3_3, scope.tempVector3_2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Perform the cut\r\n\t\t\tscope.cutByPlane( subObject, tempPlane2, scope.tempResultObjects );\r\n\r\n\t\t\tvar obj1 = scope.tempResultObjects.object1;\r\n\t\t\tvar obj2 = scope.tempResultObjects.object2;\r\n\r\n\t\t\tif ( obj1 ) {\r\n\r\n\t\t\t\tsubdivideRadial( obj1, startAngle, angle, numIterations + 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( obj2 ) {\r\n\r\n\t\t\t\tsubdivideRadial( obj2, angle, endAngle, numIterations + 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tsubdivideRadial( object, 0, 2 * Math.PI, 0 );\r\n\r\n\t\treturn debris;\r\n\r\n\t},\r\n\r\n\tcutByPlane: function ( object, plane, output ) {\r\n\r\n\t\t// Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\r\n\t\t// object2 can be null if the plane doesn't cut the object.\r\n\t\t// object1 can be null only in case of internal error\r\n\t\t// Returned value is number of pieces, 0 for error.\r\n\r\n\t\tvar geometry = object.geometry;\r\n\t\tvar coords = geometry.attributes.position.array;\r\n\t\tvar normals = geometry.attributes.normal.array;\r\n\r\n\t\tvar numPoints = coords.length / 3;\r\n\t\tvar numFaces = numPoints / 3;\r\n\r\n\t\tvar indices = geometry.getIndex();\r\n\r\n\t\tif ( indices ) {\r\n\r\n\t\t\tindices = indices.array;\r\n\t\t\tnumFaces = indices.length / 3;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getVertexIndex( faceIdx, vert ) {\r\n\r\n\t\t\t// vert = 0, 1 or 2.\r\n\r\n\t\t\tvar idx = faceIdx * 3 + vert;\r\n\r\n\t\t\treturn indices ? indices[ idx ] : idx;\r\n\r\n\t\t}\r\n\r\n\t\tvar points1 = [];\r\n\t\tvar points2 = [];\r\n\r\n\t\tvar delta = this.smallDelta;\r\n\r\n\t\t// Reset segments mark\r\n\t\tvar numPointPairs = numPoints * numPoints;\r\n\t\tfor ( var i = 0; i < numPointPairs; i ++ ) this.segments[ i ] = false;\r\n\r\n\t\tvar p0 = this.tempVector3_P0;\r\n\t\tvar p1 = this.tempVector3_P1;\r\n\t\tvar n0 = this.tempVector3_N0;\r\n\t\tvar n1 = this.tempVector3_N1;\r\n\r\n\t\t// Iterate through the faces to mark edges shared by coplanar faces\r\n\t\tfor ( var i = 0; i < numFaces - 1; i ++ ) {\r\n\r\n\t\t\tvar a1 = getVertexIndex( i, 0 );\r\n\t\t\tvar b1 = getVertexIndex( i, 1 );\r\n\t\t\tvar c1 = getVertexIndex( i, 2 );\r\n\r\n\t\t\t// Assuming all 3 vertices have the same normal\r\n\t\t\tn0.set( normals[ a1 ], normals[ a1 ] + 1, normals[ a1 ] + 2 );\r\n\r\n\t\t\tfor ( var j = i + 1; j < numFaces; j ++ ) {\r\n\r\n\t\t\t\tvar a2 = getVertexIndex( j, 0 );\r\n\t\t\t\tvar b2 = getVertexIndex( j, 1 );\r\n\t\t\t\tvar c2 = getVertexIndex( j, 2 );\r\n\r\n\t\t\t\t// Assuming all 3 vertices have the same normal\r\n\t\t\t\tn1.set( normals[ a2 ], normals[ a2 ] + 1, normals[ a2 ] + 2 );\r\n\r\n\t\t\t\tvar coplanar = 1 - n0.dot( n1 ) < delta;\r\n\r\n\t\t\t\tif ( coplanar ) {\r\n\r\n\t\t\t\t\tif ( a1 === a2 || a1 === b2 || a1 === c2 ) {\r\n\r\n\t\t\t\t\t\tif ( b1 === a2 || b1 === b2 || b1 === c2 ) {\r\n\r\n\t\t\t\t\t\t\tthis.segments[ a1 * numPoints + b1 ] = true;\r\n\t\t\t\t\t\t\tthis.segments[ b1 * numPoints + a1 ] = true;\r\n\r\n\t\t\t\t\t\t}\telse {\r\n\r\n\t\t\t\t\t\t\tthis.segments[ c1 * numPoints + a1 ] = true;\r\n\t\t\t\t\t\t\tthis.segments[ a1 * numPoints + c1 ] = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\telse if ( b1 === a2 || b1 === b2 || b1 === c2 ) {\r\n\r\n\t\t\t\t\t\tthis.segments[ c1 * numPoints + b1 ] = true;\r\n\t\t\t\t\t\tthis.segments[ b1 * numPoints + c1 ] = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Transform the plane to object local space\r\n\t\tvar localPlane = this.tempPlane_Cut;\r\n\t\tobject.updateMatrix();\r\n\t\tConvexObjectBreaker.transformPlaneToLocalSpace( plane, object.matrix, localPlane );\r\n\r\n\t\t// Iterate through the faces adding points to both pieces\r\n\t\tfor ( var i = 0; i < numFaces; i ++ ) {\r\n\r\n\t\t\tvar va = getVertexIndex( i, 0 );\r\n\t\t\tvar vb = getVertexIndex( i, 1 );\r\n\t\t\tvar vc = getVertexIndex( i, 2 );\r\n\r\n\t\t\tfor ( var segment = 0; segment < 3; segment ++ ) {\r\n\r\n\t\t\t\tvar i0 = segment === 0 ? va : ( segment === 1 ? vb : vc );\r\n\t\t\t\tvar i1 = segment === 0 ? vb : ( segment === 1 ? vc : va );\r\n\r\n\t\t\t\tvar segmentState = this.segments[ i0 * numPoints + i1 ];\r\n\r\n\t\t\t\tif ( segmentState ) continue; // The segment already has been processed in another face\r\n\r\n\t\t\t\t// Mark segment as processed (also inverted segment)\r\n\t\t\t\tthis.segments[ i0 * numPoints + i1 ] = true;\r\n\t\t\t\tthis.segments[ i1 * numPoints + i0 ] = true;\r\n\r\n\t\t\t\tp0.set( coords[ 3 * i0 ], coords[ 3 * i0 + 1 ], coords[ 3 * i0 + 2 ] );\r\n\t\t\t\tp1.set( coords[ 3 * i1 ], coords[ 3 * i1 + 1 ], coords[ 3 * i1 + 2 ] );\r\n\r\n\t\t\t\t// mark: 1 for negative side, 2 for positive side, 3 for coplanar point\r\n\t\t\t\tvar mark0 = 0;\r\n\r\n\t\t\t\tvar d = localPlane.distanceToPoint( p0 );\r\n\r\n\t\t\t\tif ( d > delta ) {\r\n\r\n\t\t\t\t\tmark0 = 2;\r\n\t\t\t\t\tpoints2.push( p0.clone() );\r\n\r\n\t\t\t\t} else if ( d < - delta ) {\r\n\r\n\t\t\t\t\tmark0 = 1;\r\n\t\t\t\t\tpoints1.push( p0.clone() );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmark0 = 3;\r\n\t\t\t\t\tpoints1.push( p0.clone() );\r\n\t\t\t\t\tpoints2.push( p0.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// mark: 1 for negative side, 2 for positive side, 3 for coplanar point\r\n\t\t\t\tvar mark1 = 0;\r\n\r\n\t\t\t\tvar d = localPlane.distanceToPoint( p1 );\r\n\r\n\t\t\t\tif ( d > delta ) {\r\n\r\n\t\t\t\t\tmark1 = 2;\r\n\t\t\t\t\tpoints2.push( p1.clone() );\r\n\r\n\t\t\t\t} else if ( d < - delta ) {\r\n\r\n\t\t\t\t\tmark1 = 1;\r\n\t\t\t\t\tpoints1.push( p1.clone() );\r\n\r\n\t\t\t\t}\telse {\r\n\r\n\t\t\t\t\tmark1 = 3;\r\n\t\t\t\t\tpoints1.push( p1.clone() );\r\n\t\t\t\t\tpoints2.push( p1.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ( mark0 === 1 && mark1 === 2 ) || ( mark0 === 2 && mark1 === 1 ) ) {\r\n\r\n\t\t\t\t\t// Intersection of segment with the plane\r\n\r\n\t\t\t\t\tthis.tempLine1.start.copy( p0 );\r\n\t\t\t\t\tthis.tempLine1.end.copy( p1 );\r\n\r\n\t\t\t\t\tvar intersection = new Vector3();\r\n\t\t\t\t\tintersection = localPlane.intersectLine( this.tempLine1, intersection );\r\n\r\n\t\t\t\t\tif ( intersection === undefined ) {\r\n\r\n\t\t\t\t\t\t// Shouldn't happen\r\n\t\t\t\t\t\tconsole.error( \"Internal error: segment does not intersect plane.\" );\r\n\t\t\t\t\t\toutput.segmentedObject1 = null;\r\n\t\t\t\t\t\toutput.segmentedObject2 = null;\r\n\t\t\t\t\t\treturn 0;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpoints1.push( intersection );\r\n\t\t\t\t\tpoints2.push( intersection.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Calculate debris mass (very fast and imprecise):\r\n\t\tvar newMass = object.userData.mass * 0.5;\r\n\r\n\t\t// Calculate debris Center of Mass (again fast and imprecise)\r\n\t\tthis.tempCM1.set( 0, 0, 0 );\r\n\t\tvar radius1 = 0;\r\n\t\tvar numPoints1 = points1.length;\r\n\r\n\t\tif ( numPoints1 > 0 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < numPoints1; i ++ ) this.tempCM1.add( points1[ i ] );\r\n\r\n\t\t\tthis.tempCM1.divideScalar( numPoints1 );\r\n\t\t\tfor ( var i = 0; i < numPoints1; i ++ ) {\r\n\r\n\t\t\t\tvar p = points1[ i ];\r\n\t\t\t\tp.sub( this.tempCM1 );\r\n\t\t\t\tradius1 = Math.max( radius1, p.x, p.y, p.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.tempCM1.add( object.position );\r\n\r\n\t\t}\r\n\r\n\t\tthis.tempCM2.set( 0, 0, 0 );\r\n\t\tvar radius2 = 0;\r\n\t\tvar numPoints2 = points2.length;\r\n\t\tif ( numPoints2 > 0 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < numPoints2; i ++ ) this.tempCM2.add( points2[ i ] );\r\n\r\n\t\t\tthis.tempCM2.divideScalar( numPoints2 );\r\n\t\t\tfor ( var i = 0; i < numPoints2; i ++ ) {\r\n\r\n\t\t\t\tvar p = points2[ i ];\r\n\t\t\t\tp.sub( this.tempCM2 );\r\n\t\t\t\tradius2 = Math.max( radius2, p.x, p.y, p.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.tempCM2.add( object.position );\r\n\r\n\t\t}\r\n\r\n\t\tvar object1 = null;\r\n\t\tvar object2 = null;\r\n\r\n\t\tvar numObjects = 0;\r\n\r\n\t\tif ( numPoints1 > 4 ) {\r\n\r\n\t\t\tobject1 = new Mesh( new ConvexBufferGeometry( points1 ), object.material );\r\n\t\t\tobject1.position.copy( this.tempCM1 );\r\n\t\t\tobject1.quaternion.copy( object.quaternion );\r\n\r\n\t\t\tthis.prepareBreakableObject( object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak );\r\n\r\n\t\t\tnumObjects ++;\r\n\r\n\t\t}\r\n\r\n\t\tif ( numPoints2 > 4 ) {\r\n\r\n\t\t\tobject2 = new Mesh( new ConvexBufferGeometry( points2 ), object.material );\r\n\t\t\tobject2.position.copy( this.tempCM2 );\r\n\t\t\tobject2.quaternion.copy( object.quaternion );\r\n\r\n\t\t\tthis.prepareBreakableObject( object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak );\r\n\r\n\t\t\tnumObjects ++;\r\n\r\n\t\t}\r\n\r\n\t\toutput.object1 = object1;\r\n\t\toutput.object2 = object2;\r\n\r\n\t\treturn numObjects;\r\n\r\n\t}\r\n\r\n};\r\n\r\nConvexObjectBreaker.transformFreeVector = function ( v, m ) {\r\n\r\n\t// input:\r\n\t// vector interpreted as a free vector\r\n\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\r\n\r\n\tvar x = v.x, y = v.y, z = v.z;\r\n\tvar e = m.elements;\r\n\r\n\tv.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\r\n\tv.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\r\n\tv.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\r\n\treturn v;\r\n\r\n};\r\n\r\nConvexObjectBreaker.transformFreeVectorInverse = function ( v, m ) {\r\n\r\n\t// input:\r\n\t// vector interpreted as a free vector\r\n\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\r\n\r\n\tvar x = v.x, y = v.y, z = v.z;\r\n\tvar e = m.elements;\r\n\r\n\tv.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z;\r\n\tv.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z;\r\n\tv.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z;\r\n\r\n\treturn v;\r\n\r\n};\r\n\r\nConvexObjectBreaker.transformTiedVectorInverse = function ( v, m ) {\r\n\r\n\t// input:\r\n\t// vector interpreted as a tied (ordinary) vector\r\n\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\r\n\r\n\tvar x = v.x, y = v.y, z = v.z;\r\n\tvar e = m.elements;\r\n\r\n\tv.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z - e[ 12 ];\r\n\tv.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z - e[ 13 ];\r\n\tv.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z - e[ 14 ];\r\n\r\n\treturn v;\r\n\r\n};\r\n\r\nConvexObjectBreaker.transformPlaneToLocalSpace = function () {\r\n\r\n\tvar v1 = new Vector3();\r\n\r\n\treturn function transformPlaneToLocalSpace( plane, m, resultPlane ) {\r\n\r\n\t\tresultPlane.normal.copy( plane.normal );\r\n\t\tresultPlane.constant = plane.constant;\r\n\r\n\t\tvar referencePoint = ConvexObjectBreaker.transformTiedVectorInverse( plane.coplanarPoint( v1 ), m );\r\n\r\n\t\tConvexObjectBreaker.transformFreeVectorInverse( resultPlane.normal, m );\r\n\r\n\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\r\n\t\tresultPlane.constant = - referencePoint.dot( resultPlane.normal );\r\n\r\n\r\n\t};\r\n\r\n}();\r\n\r\nexport { ConvexObjectBreaker };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/jsm/misc/ConvexObjectBreaker.js","<template>\r\n    <div class=\"physicsAmmoBreak-container\">\r\n        <div id=\"info\">Physics threejs demo with convex objects breaking in real time<br />Press mouse to throw balls and move the camera.</div>\r\n\t    <div id=\"container\"></div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport { OrbitControls } from '@/components/jsm/controls/OrbitControls.js'\r\nimport { ConvexObjectBreaker } from '@/components/jsm/misc/ConvexObjectBreaker.js'\r\nimport { ConvexBufferGeometry } from '@/components/jsm/geometries/ConvexGeometry.js'\r\nexport default {\r\n    data() {\r\n        return {\r\n            // - Global variables -\r\n            // Graphics variables\r\n            container: null,\r\n            stats: null,\r\n            camera: null,\r\n            controls: null,\r\n            scene: null,\r\n            renderer: null,\r\n            textureLoader: null,\r\n            clock: null,\r\n            mouseCoords: null,\r\n            raycaster: null,\r\n            ballMaterial: null,\r\n            // Physics variables\r\n            gravityConstant: 7.8,\r\n            collisionConfiguration: null,\r\n            dispatcher: null,\r\n            broadphase: null,\r\n            solver: null,\r\n            physicsWorld: null,\r\n            margin: 0.05,\r\n            convexBreaker: null,\r\n            // Rigid bodies include all movable objects\r\n            rigidBodies: [],\r\n            pos: null,\r\n            quat: null,\r\n            transformAux1: null,\r\n            tempBtVec3_1: null,\r\n            objectsToRemove: [],\r\n            numObjectsToRemove: 0,\r\n            impactPoint: null,\r\n            impactNormal: null,\r\n        }\r\n    },\r\n    mounted() {\r\n        this.clock = new this.$THREE.Clock()\r\n        this.mouseCoords = new this.$THREE.Vector2()\r\n        this.raycaster = new this.$THREE.Raycaster()\r\n        this.ballMaterial = new this.$THREE.MeshPhongMaterial({ color: 0x202020 })\r\n        this.convexBreaker = new ConvexObjectBreaker()\r\n        this.pos = new this.$THREE.Vector3()\r\n        this.quat = new this.$THREE.Quaternion()\r\n        for (var i = 0; i < 500; i ++) {\r\n            this.objectsToRemove[ i ] = null\r\n        }\r\n        this.impactPoint = new this.$THREE.Vector3()\r\n\t\tthis.impactNormal = new this.$THREE.Vector3()\r\n\t\tthis.$nextTick(() => {\r\n\t\t\tAmmo().then((AmmoLib) => {\r\n\t\t\t\tAmmo = AmmoLib\r\n\t\t\t\tthis.init()\r\n\t\t\t\tthis.animate()\r\n\t\t\t})\r\n\t\t})\r\n    },\r\n    methods: {\r\n        init() {\r\n\t\t\tthis.initGraphics()\r\n\t\t\tthis.initPhysics()\r\n\t\t\tthis.createObjects()\r\n\t\t\tthis.initInput()\r\n        },\r\n        initGraphics() {\r\n\t\t\tthis.container = document.getElementById('container')\r\n\t\t\tthis.camera = new this.$THREE.PerspectiveCamera(60, this.$webglInnerWidth / window.innerHeight, 0.2, 2000)\r\n\t\t\tthis.scene = new this.$THREE.Scene()\r\n\t\t\tthis.scene.background = new this.$THREE.Color(0xbfd1e5)\r\n\t\t\tthis.camera.position.set(- 14, 8, 16)\r\n\t\t\tthis.renderer = new this.$THREE.WebGLRenderer()\r\n\t\t\tthis.renderer.setPixelRatio(window.devicePixelRatio)\r\n\t\t\tthis.renderer.setSize(this.$webglInnerWidth, window.innerHeight)\r\n\t\t\tthis.renderer.shadowMap.enabled = true\r\n\t\t\tthis.container.appendChild(this.renderer.domElement)\r\n\t\t\tthis.controls = new OrbitControls(this.camera, this.renderer.domElement)\r\n\t\t\tthis.controls.target.set(0, 2, 0)\r\n\t\t\tthis.controls.update()\r\n\t\t\tthis.textureLoader = new this.$THREE.TextureLoader()\r\n\t\t\tvar ambientLight = new this.$THREE.AmbientLight(0x707070)\r\n\t\t\tthis.scene.add(ambientLight)\r\n\t\t\tvar light = new this.$THREE.DirectionalLight(0xffffff, 1)\r\n\t\t\tlight.position.set(- 10, 18, 5)\r\n\t\t\tlight.castShadow = true\r\n\t\t\tvar d = 14\r\n\t\t\tlight.shadow.camera.left = - d\r\n\t\t\tlight.shadow.camera.right = d\r\n\t\t\tlight.shadow.camera.top = d\r\n\t\t\tlight.shadow.camera.bottom = - d\r\n\t\t\tlight.shadow.camera.near = 2\r\n\t\t\tlight.shadow.camera.far = 50\r\n\t\t\tlight.shadow.mapSize.x = 1024\r\n\t\t\tlight.shadow.mapSize.y = 1024\r\n\t\t\tthis.scene.add(light)\r\n            this.stats = new this.$Stats()\r\n            this.stats.dom.style.left = '280px'\r\n\t\t\tthis.stats.domElement.style.position = 'absolute'\r\n\t\t\tthis.stats.domElement.style.top = '0px'\r\n\t\t\tthis.container.appendChild(this.stats.domElement)\r\n\t\t\t//\r\n\t\t\twindow.addEventListener('resize', this.onWindowResize, false)\r\n        },\r\n        initPhysics() {\r\n\t\t\t// Physics configuration\r\n\t\t\tthis.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration()\r\n\t\t\tthis.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration)\r\n\t\t\tthis.broadphase = new Ammo.btDbvtBroadphase()\r\n\t\t\tthis.solver = new Ammo.btSequentialImpulseConstraintSolver()\r\n\t\t\tthis.physicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.broadphase, this.solver, this.collisionConfiguration)\r\n\t\t\tthis.physicsWorld.setGravity(new Ammo.btVector3(0, - this.gravityConstant, 0))\r\n\t\t\tthis.transformAux1 = new Ammo.btTransform()\r\n\t\t\tthis.tempBtVec3_1 = new Ammo.btVector3(0, 0, 0)\r\n        },\r\n        createObject(mass, halfExtents, pos, quat, material) {\r\n\t\t\tvar object = new this.$THREE.Mesh(new this.$THREE.BoxBufferGeometry(halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2), material)\r\n\t\t\tobject.position.copy(pos)\r\n\t\t\tobject.quaternion.copy(quat)\r\n\t\t\tthis.convexBreaker.prepareBreakableObject(object, mass, new this.$THREE.Vector3(), new this.$THREE.Vector3(), true)\r\n\t\t\tthis.createDebrisFromBreakableObject(object)\r\n        },\r\n        createObjects() {\r\n\t\t\t// Ground\r\n\t\t\tthis.pos.set(0, - 0.5, 0)\r\n\t\t\tthis.quat.set(0, 0, 0, 1)\r\n\t\t\tvar ground = this.createParalellepipedWithPhysics(40, 1, 40, 0, this.pos, this.quat, new this.$THREE.MeshPhongMaterial({ color: 0xFFFFFF }))\r\n\t\t\tground.receiveShadow = true\r\n\t\t\tthis.textureLoader.load(\"static/textures/grid.png\", (texture) => {\r\n\t\t\t\ttexture.wrapS = this.$THREE.RepeatWrapping\r\n\t\t\t\ttexture.wrapT = this.$THREE.RepeatWrapping\r\n\t\t\t\ttexture.repeat.set(40, 40)\r\n\t\t\t\tground.material.map = texture\r\n\t\t\t\tground.material.needsUpdate = true\r\n\t\t\t})\r\n\t\t\t// Tower 1\r\n\t\t\tvar towerMass = 1000\r\n\t\t\tvar towerHalfExtents = new this.$THREE.Vector3(2, 5, 2)\r\n\t\t\tthis.pos.set(- 8, 5, 0)\r\n\t\t\tthis.quat.set(0, 0, 0, 1)\r\n\t\t\tthis.createObject(towerMass, towerHalfExtents, this.pos, this.quat, this.createMaterial(0xB03014))\r\n\t\t\t// Tower 2\r\n\t\t\tthis.pos.set(8, 5, 0)\r\n\t\t\tthis.quat.set(0, 0, 0, 1)\r\n\t\t\tthis.createObject(towerMass, towerHalfExtents, this.pos, this.quat, this.createMaterial(0xB03214))\r\n\t\t\t//Bridge\r\n\t\t\tvar bridgeMass = 100\r\n\t\t\tvar bridgeHalfExtents = new this.$THREE.Vector3(7, 0.2, 1.5)\r\n\t\t\tthis.pos.set(0, 10.2, 0)\r\n\t\t\tthis.quat.set(0, 0, 0, 1)\r\n\t\t\tthis.createObject(bridgeMass, bridgeHalfExtents, this.pos, this.quat, this.createMaterial(0xB3B865))\r\n\t\t\t// Stones\r\n\t\t\tvar stoneMass = 120\r\n\t\t\tvar stoneHalfExtents = new this.$THREE.Vector3(1, 2, 0.15)\r\n\t\t\tvar numStones = 8\r\n\t\t\tthis.quat.set(0, 0, 0, 1)\r\n\t\t\tfor (var i = 0; i < numStones; i ++) {\r\n\t\t\t\tthis.pos.set(0, 2, 15 * (0.5 - i / (numStones + 1)))\r\n\t\t\t\tthis.createObject(stoneMass, stoneHalfExtents, this.pos, this.quat, this.createMaterial(0xB0B0B0))\r\n\t\t\t}\r\n\t\t\t// Mountain\r\n\t\t\tvar mountainMass = 860\r\n\t\t\tvar mountainHalfExtents = new this.$THREE.Vector3(4, 5, 4)\r\n\t\t\tthis.pos.set(5, mountainHalfExtents.y * 0.5, - 7)\r\n\t\t\tthis.quat.set(0, 0, 0, 1)\r\n\t\t\tvar mountainPoints = []\r\n\t\t\tmountainPoints.push(new this.$THREE.Vector3(mountainHalfExtents.x, - mountainHalfExtents.y, mountainHalfExtents.z))\r\n\t\t\tmountainPoints.push(new this.$THREE.Vector3(- mountainHalfExtents.x, - mountainHalfExtents.y, mountainHalfExtents.z))\r\n\t\t\tmountainPoints.push(new this.$THREE.Vector3(mountainHalfExtents.x, - mountainHalfExtents.y, - mountainHalfExtents.z))\r\n\t\t\tmountainPoints.push(new this.$THREE.Vector3(- mountainHalfExtents.x, - mountainHalfExtents.y, - mountainHalfExtents.z))\r\n\t\t\tmountainPoints.push(new this.$THREE.Vector3(0, mountainHalfExtents.y, 0))\r\n\t\t\tvar mountain = new this.$THREE.Mesh(new ConvexBufferGeometry(mountainPoints), this.createMaterial(0xB03814))\r\n\t\t\tmountain.position.copy(this.pos)\r\n\t\t\tmountain.quaternion.copy(this.quat)\r\n\t\t\tthis.convexBreaker.prepareBreakableObject(mountain, mountainMass, new this.$THREE.Vector3(), new this.$THREE.Vector3(), true)\r\n\t\t\tthis.createDebrisFromBreakableObject(mountain)\r\n        },\r\n        createParalellepipedWithPhysics(sx, sy, sz, mass, pos, quat, material) {\r\n\t\t\tvar object = new this.$THREE.Mesh(new this.$THREE.BoxBufferGeometry(sx, sy, sz, 1, 1, 1), material)\r\n\t\t\tvar shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5))\r\n\t\t\tshape.setMargin(this.margin)\r\n\t\t\tthis.createRigidBody(object, shape, mass, pos, quat)\r\n\t\t\treturn object\r\n        },\r\n        createDebrisFromBreakableObject(object) {\r\n\t\t\tobject.castShadow = true\r\n\t\t\tobject.receiveShadow = true\r\n\t\t\tvar shape = this.createConvexHullPhysicsShape(object.geometry.attributes.position.array)\r\n\t\t\tshape.setMargin(this.margin)\r\n\t\t\tvar body = this.createRigidBody(object, shape, object.userData.mass, null, null, object.userData.velocity, object.userData.angularVelocity)\r\n\t\t\t// Set pointer back to the three object only in the debris objects\r\n\t\t\tvar btVecUserData = new Ammo.btVector3(0, 0, 0)\r\n\t\t\tbtVecUserData.threeObject = object\r\n\t\t\tbody.setUserPointer(btVecUserData)\r\n        },\r\n        removeDebris(object) {\r\n\t\t\tthis.scene.remove(object)\r\n\t\t\tthis.physicsWorld.removeRigidBody(object.userData.physicsBody)\r\n        },\r\n        createConvexHullPhysicsShape(coords) {\r\n\t\t\tvar shape = new Ammo.btConvexHullShape()\r\n\t\t\tfor (var i = 0, il = coords.length; i < il; i += 3) {\r\n\t\t\t\tthis.tempBtVec3_1.setValue(coords[ i ], coords[ i + 1 ], coords[ i + 2 ])\r\n\t\t\t\tvar lastOne = (i >= (il - 3))\r\n\t\t\t\tshape.addPoint(this.tempBtVec3_1, lastOne)\r\n\t\t\t}\r\n\t\t\treturn shape\r\n        },\r\n        createRigidBody(object, physicsShape, mass, pos, quat, vel, angVel) {\r\n\t\t\tif (pos) {\r\n\t\t\t\tobject.position.copy(pos)\r\n\t\t\t} else {\r\n\t\t\t\tpos = object.position\r\n\t\t\t}\r\n\t\t\tif (quat) {\r\n\t\t\t\tobject.quaternion.copy(quat)\r\n\t\t\t} else {\r\n\t\t\t\tquat = object.quaternion\r\n\t\t\t}\r\n\t\t\tvar transform = new Ammo.btTransform()\r\n\t\t\ttransform.setIdentity()\r\n\t\t\ttransform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z))\r\n\t\t\ttransform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w))\r\n\t\t\tvar motionState = new Ammo.btDefaultMotionState(transform)\r\n\t\t\tvar localInertia = new Ammo.btVector3(0, 0, 0)\r\n\t\t\tphysicsShape.calculateLocalInertia(mass, localInertia)\r\n\t\t\tvar rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, physicsShape, localInertia)\r\n\t\t\tvar body = new Ammo.btRigidBody(rbInfo)\r\n\t\t\tbody.setFriction(0.5)\r\n\t\t\tif (vel) {\r\n\t\t\t\tbody.setLinearVelocity(new Ammo.btVector3(vel.x, vel.y, vel.z))\r\n\t\t\t}\r\n\t\t\tif (angVel) {\r\n\t\t\t\tbody.setAngularVelocity(new Ammo.btVector3(angVel.x, angVel.y, angVel.z))\r\n\t\t\t}\r\n\t\t\tobject.userData.physicsBody = body\r\n\t\t\tobject.userData.collided = false\r\n\t\t\tthis.scene.add(object)\r\n\t\t\tif (mass > 0) {\r\n\t\t\t\tthis.rigidBodies.push(object)\r\n\t\t\t\t// Disable deactivation\r\n\t\t\t\tbody.setActivationState(4)\r\n\t\t\t}\r\n\t\t\tthis.physicsWorld.addRigidBody(body)\r\n\t\t\treturn body\r\n        },\r\n        createRandomColor() {\r\n\t\t\treturn Math.floor(Math.random() * (1 << 24))\r\n        },\r\n        createMaterial(color) {\r\n\t\t\tcolor = color || createRandomColor()\r\n\t\t\treturn new this.$THREE.MeshPhongMaterial({ color: color })\r\n        },\r\n        initInput() {\r\n\t\t\twindow.addEventListener('pointerdown', (event) => {\r\n\t\t\t\tthis.mouseCoords.set(\r\n\t\t\t\t\t(event.clientX / (window.innerWidth + 281)) * 2 - 1,\r\n\t\t\t\t\t- (event.clientY / window.innerHeight) * 2 + 1\r\n\t\t\t\t)\r\n\t\t\t\tthis.raycaster.setFromCamera(this.mouseCoords, this.camera)\r\n\t\t\t\t// Creates a ball and throws it\r\n\t\t\t\tvar ballMass = 35\r\n\t\t\t\tvar ballRadius = 0.4\r\n\t\t\t\tvar ball = new this.$THREE.Mesh(new this.$THREE.SphereBufferGeometry(ballRadius, 14, 10), this.ballMaterial)\r\n\t\t\t\tball.castShadow = true\r\n\t\t\t\tball.receiveShadow = true\r\n\t\t\t\tvar ballShape = new Ammo.btSphereShape(ballRadius)\r\n\t\t\t\tballShape.setMargin(this.margin)\r\n\t\t\t\tthis.pos.copy(this.raycaster.ray.direction)\r\n\t\t\t\tthis.pos.add(this.raycaster.ray.origin)\r\n\t\t\t\tthis.quat.set(0, 0, 0, 1)\r\n\t\t\t\tvar ballBody = this.createRigidBody(ball, ballShape, ballMass, this.pos, this.quat)\r\n\t\t\t\tthis.pos.copy(this.raycaster.ray.direction)\r\n\t\t\t\tthis.pos.multiplyScalar(24)\r\n\t\t\t\tballBody.setLinearVelocity(new Ammo.btVector3(this.pos.x, this.pos.y, this.pos.z))\r\n\t\t\t}, false)\r\n        },\r\n        onWindowResize() {\r\n\t\t\tthis.$onWindowResize(this.camera, this.renderer)\r\n        },\r\n        animate() {\r\n\t\t\trequestAnimationFrame(this.animate)\r\n\t\t\tthis.render()\r\n\t\t\tthis.stats.update()\r\n        },\r\n        render() {\r\n\t\t\tvar deltaTime = this.clock.getDelta()\r\n\t\t\tthis.updatePhysics(deltaTime)\r\n\t\t\tthis.renderer.render(this.scene, this.camera)\r\n        },\r\n        updatePhysics(deltaTime) {\r\n\t\t\t// Step world\r\n\t\t\tthis.physicsWorld.stepSimulation(deltaTime, 10)\r\n\t\t\t// Update rigid bodies\r\n\t\t\tfor (var i = 0, il = this.rigidBodies.length; i < il; i ++) {\r\n\t\t\t\tvar objThree = this.rigidBodies[ i ]\r\n\t\t\t\tvar objPhys = objThree.userData.physicsBody\r\n\t\t\t\tvar ms = objPhys.getMotionState()\r\n\t\t\t\tif (ms) {\r\n\t\t\t\t\tms.getWorldTransform(this.transformAux1)\r\n\t\t\t\t\tvar p = this.transformAux1.getOrigin()\r\n\t\t\t\t\tvar q = this.transformAux1.getRotation()\r\n\t\t\t\t\tobjThree.position.set(p.x(), p.y(), p.z())\r\n\t\t\t\t\tobjThree.quaternion.set(q.x(), q.y(), q.z(), q.w())\r\n\t\t\t\t\tobjThree.userData.collided = false\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, il = this.dispatcher.getNumManifolds(); i < il; i ++) {\r\n\t\t\t\tvar contactManifold = this.dispatcher.getManifoldByIndexInternal(i)\r\n\t\t\t\tvar rb0 = Ammo.castObject(contactManifold.getBody0(), Ammo.btRigidBody)\r\n\t\t\t\tvar rb1 = Ammo.castObject(contactManifold.getBody1(), Ammo.btRigidBody)\r\n\t\t\t\tvar threeObject0 = Ammo.castObject(rb0.getUserPointer(), Ammo.btVector3).threeObject\r\n\t\t\t\tvar threeObject1 = Ammo.castObject(rb1.getUserPointer(), Ammo.btVector3).threeObject\r\n\t\t\t\tif (! threeObject0 && ! threeObject1) {\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tvar userData0 = threeObject0 ? threeObject0.userData : null\r\n\t\t\t\tvar userData1 = threeObject1 ? threeObject1.userData : null\r\n\t\t\t\tvar breakable0 = userData0 ? userData0.breakable : false\r\n\t\t\t\tvar breakable1 = userData1 ? userData1.breakable : false\r\n\t\t\t\tvar collided0 = userData0 ? userData0.collided : false\r\n\t\t\t\tvar collided1 = userData1 ? userData1.collided : false\r\n\t\t\t\tif ((! breakable0 && ! breakable1) || (collided0 && collided1)) {\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tvar contact = false\r\n\t\t\t\tvar maxImpulse = 0\r\n\t\t\t\tfor (var j = 0, jl = contactManifold.getNumContacts(); j < jl; j ++) {\r\n\t\t\t\t\tvar contactPoint = contactManifold.getContactPoint(j)\r\n\t\t\t\t\tif (contactPoint.getDistance() < 0) {\r\n\t\t\t\t\t\tcontact = true\r\n\t\t\t\t\t\tvar impulse = contactPoint.getAppliedImpulse()\r\n\t\t\t\t\t\tif (impulse > maxImpulse) {\r\n\t\t\t\t\t\t\tmaxImpulse = impulse\r\n\t\t\t\t\t\t\tvar pos = contactPoint.get_m_positionWorldOnB()\r\n\t\t\t\t\t\t\tvar normal = contactPoint.get_m_normalWorldOnB()\r\n\t\t\t\t\t\t\tthis.impactPoint.set(pos.x(), pos.y(), pos.z())\r\n\t\t\t\t\t\t\tthis.impactNormal.set(normal.x(), normal.y(), normal.z())\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// If no point has contact, abort\r\n\t\t\t\tif (! contact) continue\r\n\t\t\t\t// Subdivision\r\n\t\t\t\tvar fractureImpulse = 250\r\n\t\t\t\tif (breakable0 && ! collided0 && maxImpulse > fractureImpulse) {\r\n\t\t\t\t\tvar debris = this.convexBreaker.subdivideByImpact(threeObject0, this.impactPoint, this.impactNormal, 1, 2, 1.5)\r\n\t\t\t\t\tvar numObjects = debris.length\r\n\t\t\t\t\tfor (var j = 0; j < numObjects; j ++) {\r\n\t\t\t\t\t\tvar vel = rb0.getLinearVelocity()\r\n\t\t\t\t\t\tvar angVel = rb0.getAngularVelocity()\r\n\t\t\t\t\t\tvar fragment = debris[ j ]\r\n\t\t\t\t\t\tfragment.userData.velocity.set(vel.x(), vel.y(), vel.z())\r\n\t\t\t\t\t\tfragment.userData.angularVelocity.set(angVel.x(), angVel.y(), angVel.z())\r\n\t\t\t\t\t\tthis.createDebrisFromBreakableObject(fragment)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.objectsToRemove[ this.numObjectsToRemove ++ ] = threeObject0\r\n\t\t\t\t\tuserData0.collided = true\r\n\t\t\t\t}\r\n\t\t\t\tif (breakable1 && ! collided1 && maxImpulse > fractureImpulse) {\r\n\t\t\t\t\tvar debris = this.convexBreaker.subdivideByImpact(threeObject1, this.impactPoint, this.impactNormal, 1, 2, 1.5)\r\n\t\t\t\t\tvar numObjects = debris.length\r\n\t\t\t\t\tfor (var j = 0; j < numObjects; j ++) {\r\n\t\t\t\t\t\tvar vel = rb1.getLinearVelocity()\r\n\t\t\t\t\t\tvar angVel = rb1.getAngularVelocity()\r\n\t\t\t\t\t\tvar fragment = debris[ j ]\r\n\t\t\t\t\t\tfragment.userData.velocity.set(vel.x(), vel.y(), vel.z())\r\n\t\t\t\t\t\tfragment.userData.angularVelocity.set(angVel.x(), angVel.y(), angVel.z())\r\n\t\t\t\t\t\tthis.createDebrisFromBreakableObject(fragment)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.objectsToRemove[ this.numObjectsToRemove ++ ] = threeObject1\r\n\t\t\t\t\tuserData1.collided = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (var i = 0; i < this.numObjectsToRemove; i ++) {\r\n\t\t\t\tthis.removeDebris(this.objectsToRemove[ i ])\r\n\t\t\t}\r\n\t\t\tthis.numObjectsToRemove = 0\r\n\t\t}\r\n    },\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n.physicsAmmoBreak-container {\r\n    width: 100%;\r\n    color: #333;\r\n}\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// src/views/physics/physicsAmmoBreak.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"physicsAmmoBreak-container\"},[_c('div',{attrs:{\"id\":\"info\"}},[_vm._v(\"Physics threejs demo with convex objects breaking in real time\"),_c('br'),_vm._v(\"Press mouse to throw balls and move the camera.\")]),_vm._v(\" \"),_c('div',{attrs:{\"id\":\"container\"}})])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-14638748\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/views/physics/physicsAmmoBreak.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true,\\\"publicPath\\\":\\\"../../\\\"}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-14638748\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./physicsAmmoBreak.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./physicsAmmoBreak.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./physicsAmmoBreak.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-14638748\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./physicsAmmoBreak.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-14638748\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/physics/physicsAmmoBreak.vue\n// module id = null\n// module chunks = "],"sourceRoot":""}