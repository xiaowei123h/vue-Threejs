webpackJsonp([8],{KuB0:function(e,t){},zH4n:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var o=n("Ml+6"),a=function(e,t){var n,a,i,r,s,c;void 0===t&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),t===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=e,this.domElement=t,this.enabled=!0,this.target=new o.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={LEFT:o.MOUSE.ROTATE,MIDDLE:o.MOUSE.DOLLY,RIGHT:o.MOUSE.PAN},this.touches={ONE:o.TOUCH.ROTATE,TWO:o.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=function(){return v.phi},this.getAzimuthalAngle=function(){return v.theta},this.saveState=function(){l.target0.copy(l.target),l.position0.copy(l.object.position),l.zoom0=l.object.zoom},this.reset=function(){l.target.copy(l.target0),l.object.position.copy(l.position0),l.object.zoom=l.zoom0,l.object.updateProjectionMatrix(),l.dispatchEvent(h),l.update(),p=d.NONE},this.update=(n=new o.Vector3,a=(new o.Quaternion).setFromUnitVectors(e.up,new o.Vector3(0,1,0)),i=a.clone().inverse(),r=new o.Vector3,s=new o.Quaternion,c=2*Math.PI,function(){var e=l.object.position;n.copy(e).sub(l.target),n.applyQuaternion(a),v.setFromVector3(n),l.autoRotate&&p===d.NONE&&N(2*Math.PI/60/60*l.autoRotateSpeed),l.enableDamping?(v.theta+=g.theta*l.dampingFactor,v.phi+=g.phi*l.dampingFactor):(v.theta+=g.theta,v.phi+=g.phi);var t=l.minAzimuthAngle,o=l.maxAzimuthAngle;return isFinite(t)&&isFinite(o)&&(t<-Math.PI?t+=c:t>Math.PI&&(t-=c),o<-Math.PI?o+=c:o>Math.PI&&(o-=c),v.theta=t<o?Math.max(t,Math.min(o,v.theta)):v.theta>(t+o)/2?Math.max(t,v.theta):Math.min(o,v.theta)),v.phi=Math.max(l.minPolarAngle,Math.min(l.maxPolarAngle,v.phi)),v.makeSafe(),v.radius*=b,v.radius=Math.max(l.minDistance,Math.min(l.maxDistance,v.radius)),!0===l.enableDamping?l.target.addScaledVector(E,l.dampingFactor):l.target.add(E),n.setFromSpherical(v),n.applyQuaternion(i),e.copy(l.target).add(n),l.object.lookAt(l.target),!0===l.enableDamping?(g.theta*=1-l.dampingFactor,g.phi*=1-l.dampingFactor,E.multiplyScalar(1-l.dampingFactor)):(g.set(0,0,0),E.set(0,0,0)),b=1,!!(y||r.distanceToSquared(l.object.position)>f||8*(1-s.dot(l.object.quaternion))>f)&&(l.dispatchEvent(h),r.copy(l.object.position),s.copy(l.object.quaternion),y=!1,!0)}),this.dispose=function(){l.domElement.removeEventListener("contextmenu",te,!1),l.domElement.removeEventListener("pointerdown",B,!1),l.domElement.removeEventListener("wheel",q,!1),l.domElement.removeEventListener("touchstart",Q,!1),l.domElement.removeEventListener("touchend",ee,!1),l.domElement.removeEventListener("touchmove",J,!1),l.domElement.ownerDocument.removeEventListener("pointermove",W,!1),l.domElement.ownerDocument.removeEventListener("pointerup",$,!1),l.domElement.removeEventListener("keydown",K,!1)};var l=this,h={type:"change"},m={type:"start"},u={type:"end"},d={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},p=d.NONE,f=1e-6,v=new o.Spherical,g=new o.Spherical,b=1,E=new o.Vector3,y=!1,x=new o.Vector2,T=new o.Vector2,O=new o.Vector2,P=new o.Vector2,M=new o.Vector2,w=new o.Vector2,C=new o.Vector2,L=new o.Vector2,R=new o.Vector2;function A(){return Math.pow(.95,l.zoomSpeed)}function N(e){g.theta-=e}function S(e){g.phi-=e}var _,j=(_=new o.Vector3,function(e,t){_.setFromMatrixColumn(t,0),_.multiplyScalar(-e),E.add(_)}),F=function(){var e=new o.Vector3;return function(t,n){!0===l.screenSpacePanning?e.setFromMatrixColumn(n,1):(e.setFromMatrixColumn(n,0),e.crossVectors(l.object.up,e)),e.multiplyScalar(t),E.add(e)}}(),H=function(){var e=new o.Vector3;return function(t,n){var o=l.domElement;if(l.object.isPerspectiveCamera){var a=l.object.position;e.copy(a).sub(l.target);var i=e.length();i*=Math.tan(l.object.fov/2*Math.PI/180),j(2*t*i/o.clientHeight,l.object.matrix),F(2*n*i/o.clientHeight,l.object.matrix)}else l.object.isOrthographicCamera?(j(t*(l.object.right-l.object.left)/l.object.zoom/o.clientWidth,l.object.matrix),F(n*(l.object.top-l.object.bottom)/l.object.zoom/o.clientHeight,l.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),l.enablePan=!1)}}();function D(e){l.object.isPerspectiveCamera?b/=e:l.object.isOrthographicCamera?(l.object.zoom=Math.max(l.minZoom,Math.min(l.maxZoom,l.object.zoom*e)),l.object.updateProjectionMatrix(),y=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),l.enableZoom=!1)}function k(e){l.object.isPerspectiveCamera?b*=e:l.object.isOrthographicCamera?(l.object.zoom=Math.max(l.minZoom,Math.min(l.maxZoom,l.object.zoom/e)),l.object.updateProjectionMatrix(),y=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),l.enableZoom=!1)}function Y(e){x.set(e.clientX,e.clientY)}function I(e){P.set(e.clientX,e.clientY)}function U(e){if(1==e.touches.length)x.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);x.set(t,n)}}function z(e){if(1==e.touches.length)P.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);P.set(t,n)}}function V(e){var t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY,o=Math.sqrt(t*t+n*n);C.set(0,o)}function X(e){if(1==e.touches.length)T.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);T.set(t,n)}O.subVectors(T,x).multiplyScalar(l.rotateSpeed);var o=l.domElement;N(2*Math.PI*O.x/o.clientHeight),S(2*Math.PI*O.y/o.clientHeight),x.copy(T)}function G(e){if(1==e.touches.length)M.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);M.set(t,n)}w.subVectors(M,P).multiplyScalar(l.panSpeed),H(w.x,w.y),P.copy(M)}function Z(e){var t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY,o=Math.sqrt(t*t+n*n);L.set(0,o),R.set(0,Math.pow(L.y/C.y,l.zoomSpeed)),D(R.y),C.copy(L)}function B(e){if(!1!==l.enabled)switch(e.pointerType){case"mouse":case"pen":!function(e){var t;switch(e.preventDefault(),l.domElement.focus?l.domElement.focus():window.focus(),e.button){case 0:t=l.mouseButtons.LEFT;break;case 1:t=l.mouseButtons.MIDDLE;break;case 2:t=l.mouseButtons.RIGHT;break;default:t=-1}switch(t){case o.MOUSE.DOLLY:if(!1===l.enableZoom)return;!function(e){C.set(e.clientX,e.clientY)}(e),p=d.DOLLY;break;case o.MOUSE.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===l.enablePan)return;I(e),p=d.PAN}else{if(!1===l.enableRotate)return;Y(e),p=d.ROTATE}break;case o.MOUSE.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===l.enableRotate)return;Y(e),p=d.ROTATE}else{if(!1===l.enablePan)return;I(e),p=d.PAN}break;default:p=d.NONE}p!==d.NONE&&(l.domElement.ownerDocument.addEventListener("pointermove",W,!1),l.domElement.ownerDocument.addEventListener("pointerup",$,!1),l.dispatchEvent(m))}(e)}}function W(e){if(!1!==l.enabled)switch(e.pointerType){case"mouse":case"pen":!function(e){if(!1===l.enabled)return;switch(e.preventDefault(),p){case d.ROTATE:if(!1===l.enableRotate)return;!function(e){T.set(e.clientX,e.clientY),O.subVectors(T,x).multiplyScalar(l.rotateSpeed);var t=l.domElement;N(2*Math.PI*O.x/t.clientHeight),S(2*Math.PI*O.y/t.clientHeight),x.copy(T),l.update()}(e);break;case d.DOLLY:if(!1===l.enableZoom)return;!function(e){L.set(e.clientX,e.clientY),R.subVectors(L,C),R.y>0?D(A()):R.y<0&&k(A()),C.copy(L),l.update()}(e);break;case d.PAN:if(!1===l.enablePan)return;!function(e){M.set(e.clientX,e.clientY),w.subVectors(M,P).multiplyScalar(l.panSpeed),H(w.x,w.y),P.copy(M),l.update()}(e)}}(e)}}function $(e){if(!1!==l.enabled)switch(e.pointerType){case"mouse":case"pen":!function(e){if(!1===l.enabled)return;l.domElement.ownerDocument.removeEventListener("pointermove",W,!1),l.domElement.ownerDocument.removeEventListener("pointerup",$,!1),l.dispatchEvent(u),p=d.NONE}()}}function q(e){!1===l.enabled||!1===l.enableZoom||p!==d.NONE&&p!==d.ROTATE||(e.preventDefault(),e.stopPropagation(),l.dispatchEvent(m),function(e){e.deltaY<0?k(A()):e.deltaY>0&&D(A()),l.update()}(e),l.dispatchEvent(u))}function K(e){!1!==l.enabled&&!1!==l.enableKeys&&!1!==l.enablePan&&function(e){var t=!1;switch(e.keyCode){case l.keys.UP:H(0,l.keyPanSpeed),t=!0;break;case l.keys.BOTTOM:H(0,-l.keyPanSpeed),t=!0;break;case l.keys.LEFT:H(l.keyPanSpeed,0),t=!0;break;case l.keys.RIGHT:H(-l.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),l.update())}(e)}function Q(e){if(!1!==l.enabled){switch(e.preventDefault(),e.touches.length){case 1:switch(l.touches.ONE){case o.TOUCH.ROTATE:if(!1===l.enableRotate)return;U(e),p=d.TOUCH_ROTATE;break;case o.TOUCH.PAN:if(!1===l.enablePan)return;z(e),p=d.TOUCH_PAN;break;default:p=d.NONE}break;case 2:switch(l.touches.TWO){case o.TOUCH.DOLLY_PAN:if(!1===l.enableZoom&&!1===l.enablePan)return;!function(e){l.enableZoom&&V(e),l.enablePan&&z(e)}(e),p=d.TOUCH_DOLLY_PAN;break;case o.TOUCH.DOLLY_ROTATE:if(!1===l.enableZoom&&!1===l.enableRotate)return;!function(e){l.enableZoom&&V(e),l.enableRotate&&U(e)}(e),p=d.TOUCH_DOLLY_ROTATE;break;default:p=d.NONE}break;default:p=d.NONE}p!==d.NONE&&l.dispatchEvent(m)}}function J(e){if(!1!==l.enabled)switch(e.preventDefault(),e.stopPropagation(),p){case d.TOUCH_ROTATE:if(!1===l.enableRotate)return;X(e),l.update();break;case d.TOUCH_PAN:if(!1===l.enablePan)return;G(e),l.update();break;case d.TOUCH_DOLLY_PAN:if(!1===l.enableZoom&&!1===l.enablePan)return;!function(e){l.enableZoom&&Z(e),l.enablePan&&G(e)}(e),l.update();break;case d.TOUCH_DOLLY_ROTATE:if(!1===l.enableZoom&&!1===l.enableRotate)return;!function(e){l.enableZoom&&Z(e),l.enableRotate&&X(e)}(e),l.update();break;default:p=d.NONE}}function ee(e){!1!==l.enabled&&(l.dispatchEvent(u),p=d.NONE)}function te(e){!1!==l.enabled&&e.preventDefault()}l.domElement.addEventListener("contextmenu",te,!1),l.domElement.addEventListener("pointerdown",B,!1),l.domElement.addEventListener("wheel",q,!1),l.domElement.addEventListener("touchstart",Q,!1),l.domElement.addEventListener("touchend",ee,!1),l.domElement.addEventListener("touchmove",J,!1),l.domElement.addEventListener("keydown",K,!1),-1===l.domElement.tabIndex&&(l.domElement.tabIndex=0),this.update()};(a.prototype=Object.create(o.EventDispatcher.prototype)).constructor=a;var i=function(e,t){a.call(this,e,t),this.screenSpacePanning=!1,this.mouseButtons.LEFT=o.MOUSE.PAN,this.mouseButtons.RIGHT=o.MOUSE.ROTATE,this.touches.ONE=o.TOUCH.PAN,this.touches.TWO=o.TOUCH.DOLLY_ROTATE};(i.prototype=Object.create(o.EventDispatcher.prototype)).constructor=i;var r={data:function(){return{vertexShader:"",shaderMaterials:{},cube:null,camera:null,scene:null,renderer:null,controls:null}},mounted:function(){this.init()},methods:{init:function(){this.initShaderMaterialsData(),this.createScene(),this.createMesh(),this.createLight(),this.createCamera(),this.createRender(),this.createControls(),this.render()},initShaderMaterialsData:function(){this.vertexShader="    \n        uniform float time;\n        varying vec2 vUv;\n        void main()\n        {\n            vec3 posChanged = position;\n            posChanged.x = posChanged.x*(abs(sin(time*1.0)));\n            posChanged.y = posChanged.y*(abs(cos(time*1.0)));\n            posChanged.z = posChanged.z*(abs(sin(time*1.0)));\n            //gl_Position = projectionMatrix * modelViewMatrix * vec4(position*(abs(sin(time)/2.0)+0.5),1.0);\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(posChanged,1.0);\n        }",this.shaderMaterials["fragment-shader-1"]="precision highp float;\n        uniform float time;\n        uniform float alpha;\n        uniform vec2 resolution;\n        varying vec2 vUv;\n\n        void main2(void)\n        {\n            vec2 position = vUv;\n            float red = 1.0;\n            float green = 0.25 + sin(time) * 0.25;\n            float blue = 0.0;\n            vec3 rgb = vec3(red, green, blue);\n            vec4 color = vec4(rgb, alpha);\n            gl_FragColor = color;\n        }\n\n        #define PI 3.14159\n        #define TWO_PI (PI*2.0)\n        #define N 68.5\n\n        void main(void)\n        {\n            vec2 center = (gl_FragCoord.xy);\n            center.x=-10.12*sin(time/200.0);\n            center.y=-10.12*cos(time/200.0);\n\n            vec2 v = (gl_FragCoord.xy - resolution/20.0) / min(resolution.y,resolution.x) * 15.0;\n            v.x=v.x-10.0;\n            v.y=v.y-200.0;\n            float col = 0.0;\n\n            for(float i = 0.0; i < N; i++)\n            {\n            float a = i * (TWO_PI/N) * 61.95;\n            col += cos(TWO_PI*(v.y * cos(a) + v.x * sin(a) + sin(time*0.004)*100.0 ));\n            }\n            col /= 5.0;\n            gl_FragColor = vec4(col*1.0, -col*1.0,-col*4.0, 1.0);\n        }",this.shaderMaterials["fragment-shader-2"]="\n        uniform float time;\n        uniform vec2 resolution;\n        #define CGFloat float\n        #define M_PI 3.14159265359\n\n        vec3 hsvtorgb(float h, float s, float v)\n        {\n            float c = v * s;\n            h = mod((h * 6.0), 6.0);\n            float x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n            vec3 color;\n\n            if (0.0 <= h && h < 1.0)\n            {\n            color = vec3(c, x, 0.0);\n            }\n            else if (1.0 <= h && h < 2.0)\n            {\n            color = vec3(x, c, 0.0);\n            }\n            else if (2.0 <= h && h < 3.0)\n            {\n            color = vec3(0.0, c, x);\n            }\n            else if (3.0 <= h && h < 4.0)\n            {\n            color = vec3(0.0, x, c);\n            }\n            else if (4.0 <= h && h < 5.0)\n            {\n            color = vec3(x, 0.0, c);\n            }\n            else if (5.0 <= h && h < 6.0)\n            {\n            color = vec3(c, 0.0, x);\n            }\n            else\n            {\n            color = vec3(0.0);\n            }\n\n            color += v - c;\n\n            return color;\n        }\n\n        void main(void)\n        {\n\n            vec2 position = (gl_FragCoord.xy - 0.5 * resolution) / resolution.y;\n            float x = position.x;\n            float y = position.y;\n\n            CGFloat a = atan(x, y);\n\n            CGFloat d = sqrt(x*x+y*y);\n            CGFloat d0 = 0.5*(sin(d-time)+1.5)*d;\n            CGFloat d1 = 5.0;\n\n            CGFloat u = mod(a*d1+sin(d*10.0+time), M_PI*2.0)/M_PI*0.5 - 0.5;\n            CGFloat v = mod(pow(d0*4.0, 0.75),1.0) - 0.5;\n\n            CGFloat dd = sqrt(u*u+v*v);\n\n            CGFloat aa = atan(u, v);\n\n            CGFloat uu = mod(aa*3.0+3.0*cos(dd*30.0-time), M_PI*2.0)/M_PI*0.5 - 0.5;\n\n            CGFloat d2 = sqrt(uu*uu+v*v)*1.5;\n\n            gl_FragColor = vec4( hsvtorgb(dd+time*0.5/d1, sin(dd*time), d2), 1.0 );\n        }",this.shaderMaterials["fragment-shader-3"]="uniform vec2 resolution;\n        uniform float time;\n        vec2 rand(vec2 pos)\n        {\n            return fract( 0.00005 * (pow(pos+2.0, pos.yx + 1.0) * 22222.0));\n        }\n        vec2 rand2(vec2 pos)\n        {\n            return rand(rand(pos));\n        }\n\n        float softnoise(vec2 pos, float scale)\n        {\n            vec2 smplpos = pos * scale;\n            float c0 = rand2((floor(smplpos) + vec2(0.0, 0.0)) / scale).x;\n            float c1 = rand2((floor(smplpos) + vec2(1.0, 0.0)) / scale).x;\n            float c2 = rand2((floor(smplpos) + vec2(0.0, 1.0)) / scale).x;\n            float c3 = rand2((floor(smplpos) + vec2(1.0, 1.0)) / scale).x;\n\n            vec2 a = fract(smplpos);\n            return mix(\n            mix(c0, c1, smoothstep(0.0, 1.0, a.x)),\n            mix(c2, c3, smoothstep(0.0, 1.0, a.x)),\n            smoothstep(0.0, 1.0, a.y));\n        }\n\n        void main(void)\n        {\n            vec2 pos = gl_FragCoord.xy / resolution.y;\n            pos.x += time * 0.1;\n            float color = 0.0;\n            float s = 1.0;\n            for(int i = 0; i < 8; i++)\n            {\n            color += softnoise(pos+vec2(i)*0.02, s * 4.0) / s / 2.0;\n            s *= 2.0;\n            }\n            gl_FragColor = vec4(color);\n        }",this.shaderMaterials["fragment-shader-4"]="uniform float time;\n        uniform vec2 resolution;\n        vec2 rand(vec2 pos)\n        {\n            return fract((pow(pos+2.0,pos.yx+2.0)*555555.0));\n        }\n\n        vec2 rand2(vec2 pos)\n        {\n            return rand(rand(pos));\n        }\n\n        float softnoise(vec2 pos, float scale) {\n            vec2 smplpos = pos * scale;\n            float c0 = rand2((floor(smplpos) + vec2(0.0, 0.0)) / scale).x;\n            float c1 = rand2((floor(smplpos) + vec2(1.0, 0.0)) / scale).x;\n            float c2 = rand2((floor(smplpos) + vec2(0.0, 1.0)) / scale).x;\n            float c3 = rand2((floor(smplpos) + vec2(1.0, 1.0)) / scale).x;\n\n            vec2 a = fract(smplpos);\n            return mix(mix(c0, c1, smoothstep(0.0, 1.0, a.x)),\n            mix(c2, c3, smoothstep(0.0, 1.0, a.x)),\n            smoothstep(0.0, 1.0, a.x));\n        }\n\n        void main( void ) {\n            vec2 pos = gl_FragCoord.xy / resolution.y - time * 0.4;\n\n            float color = 0.0;\n            float s = 1.0;\n            for (int i = 0; i < 6; ++i) {\n            color += softnoise(pos + vec2(0.01 * float(i)), s * 4.0) / s / 2.0;\n            s *= 2.0;\n            }\n            gl_FragColor = vec4(color,mix(color,cos(color),sin(color)),color,1);\n        }",this.shaderMaterials["fragment-shader-5"]="uniform float time;\n        uniform vec2 resolution;\n        void main( void ) {\n\n            vec3 color = vec3(1.0, 0., 0.);\n            vec2 pos = (( 1.4 * gl_FragCoord.xy - resolution.xy) / resolution.xx)*1.5;\n            float r=sqrt(pos.x*pos.x+pos.y*pos.y)/15.0;\n            float size1=2.0*cos(time/60.0);\n            float size2=2.5*sin(time/12.1);\n\n            float rot1=13.00; //82.0+16.0*sin(time/4.0);\n            float rot2=-50.00; //82.0+16.0*sin(time/8.0);\n            float t=sin(time);\n            float a = (60.0)*sin(rot1*atan(pos.x-size1*pos.y/r,pos.y+size1*pos.x/r)+time);\n            a += 200.0*acos(pos.x*2.0+cos(time/2.0))+asin(pos.y*5.0+sin(time/2.0));\n            a=a*(r/50.0);\n            a=200.0*sin(a*5.0)*(r/30.0);\n            if(a>5.0) a=a/200.0;\n            if(a<0.5) a=a*22.5;\n            gl_FragColor = vec4( cos(a/20.0),a*cos(a/200.0),sin(a/8.0), 1.0 );\n        }",this.shaderMaterials["fragment-shader-6"]="uniform float time;\n        uniform vec2 resolution;\n        void main( void )\n        {\n\n            vec2 uPos = ( gl_FragCoord.xy / resolution.xy );//normalize wrt y axis\n            //suPos -= vec2((resolution.x/resolution.y)/2.0, 0.0);//shift origin to center\n\n            uPos.x -= 1.0;\n            uPos.y -= 0.5;\n\n            vec3 color = vec3(0.0);\n            float vertColor = 2.0;\n            for( float i = 0.0; i < 15.0; ++i )\n            {\n            float t = time * (0.9);\n            uPos.y += sin( uPos.x*i + t+i/2.0 ) * 0.1;\n            float fTemp = abs(1.0 / uPos.y / 100.0);\n            vertColor += fTemp;\n            color += vec3( fTemp*(10.0-i)/10.0, fTemp*i/10.0, pow(fTemp,1.5)*1.5 );\n            }\n            vec4 color_final = vec4(color, 1.0);\n            gl_FragColor = color_final;\n        }"},createScene:function(){this.scene=new this.$THREE.Scene},createMesh:function(){var e=new this.$THREE.BoxGeometry(20,20,20),t=[this.createMaterial("fragment-shader-1"),this.createMaterial("fragment-shader-2"),this.createMaterial("fragment-shader-3"),this.createMaterial("fragment-shader-4"),this.createMaterial("fragment-shader-5"),this.createMaterial("fragment-shader-6")];this.cube=new this.$THREE.Mesh(e,t),this.scene.add(this.cube)},createMaterial:function(e){var t={time:{type:"f",value:.2},scale:{type:"f",value:.2},alpha:{type:"f",value:.6},resolution:{type:"v2",value:new this.$THREE.Vector2}},n=document.getElementById("container");return t.resolution.value.x=n.clientWidth,t.resolution.value.y=n.clientHeight,new this.$THREE.ShaderMaterial({uniforms:t,vertexShader:this.vertexShader,fragmentShader:this.shaderMaterials[e],transparent:!0})},createLight:function(){var e=new this.$THREE.AmbientLight(16777215,.1);this.scene.add(e);var t=new this.$THREE.SpotLight(16777215);t.position.set(-40,60,-10),t.castShadow=!0,this.scene.add(t)},createCamera:function(){var e=document.getElementById("container"),t=e.clientWidth/e.clientHeight;this.camera=new this.$THREE.PerspectiveCamera(35,t,.1,1e3),this.camera.position.set(-80,60,40),this.camera.lookAt(new this.$THREE.Vector3(10,0,0)),this.scene.add(this.camera)},createRender:function(){var e=document.getElementById("container");this.renderer=new this.$THREE.WebGLRenderer({antialias:!0,alpha:!0}),this.renderer.setSize(e.clientWidth,e.clientHeight),this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=this.$THREE.PCFSoftShadowMap,this.renderer.setClearColor(new this.$THREE.Color(0,1)),e.appendChild(this.renderer.domElement)},updateFun:function(){this.cube.rotation.y+=.01,this.cube.rotation.x+=.01,this.cube.rotation.z+=.01,this.cube.material.forEach(function(e){e.uniforms.time.value+=.01})},render:function(){this.updateFun(),this.renderer.render(this.scene,this.camera),requestAnimationFrame(this.render)},createControls:function(){this.controls=new a(this.camera,this.renderer.domElement)}}},s={render:function(){var e=this.$createElement;return(this._self._c||e)("div",{attrs:{id:"container"}})},staticRenderFns:[]};var c=n("VU/8")(r,s,!1,function(e){n("KuB0")},null,null);t.default=c.exports}});
//# sourceMappingURL=8.9f16e73e6a45383d13bc.js.map